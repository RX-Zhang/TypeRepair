{"isLenient": "\n    public boolean isLenient() {\n        return false;\n    }", "get": "\n    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }", "add": "\n    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }", "addWrapField": "\n    public long addWrapField(long instant, int months) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\n    }", "getDifferenceAsLong": "\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        if (minuendInstant < subtrahendInstant) {\n            return -getDifference(subtrahendInstant, minuendInstant);\n        }\n\n        int minuendYear = iChronology.getYear(minuendInstant);\n        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n\n        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n\n        // Before adjusting for remainder, account for special case of add\n        // where the day-of-month is forced to the nearest sane value.\n        int minuendDom = iChronology.getDayOfMonth\n            (minuendInstant, minuendYear, minuendMonth);\n        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n            // Last day of the minuend month...\n            int subtrahendDom = iChronology.getDayOfMonth\n                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n            if (subtrahendDom > minuendDom) {\n                // ...and day of subtrahend month is larger.\n                // Note: This works fine, but it ideally shouldn't invoke other\n                // fields from within a field.\n                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n            }\n        }\n\n        // Inlined remainder method to avoid duplicate calls.\n        long minuendRem = minuendInstant\n            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n        long subtrahendRem = subtrahendInstant\n            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n\n        if (minuendRem < subtrahendRem) {\n            difference--;\n        }\n\n        return difference;\n    }", "set": "\n    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }", "getRangeDurationField": "\n    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }", "isLeap": "\n    public boolean isLeap(long instant) {\n        int thisYear = iChronology.getYear(instant);\n        if (iChronology.isLeapYear(thisYear)) {\n            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n        }\n        return false;\n    }", "getLeapAmount": "\n    public int getLeapAmount(long instant) {\n        return isLeap(instant) ? 1 : 0;\n    }", "getLeapDurationField": "\n    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }", "getMinimumValue": "\n    public int getMinimumValue() {\n        return MIN;\n    }", "getMaximumValue": "\n    public int getMaximumValue() {\n        return iMax;\n    }", "roundFloor": "\n    public long roundFloor(long instant) {\n        int year = iChronology.getYear(instant);\n        int month = iChronology.getMonthOfYear(instant, year);\n        return iChronology.getYearMonthMillis(year, month);\n    }", "remainder": "\n    public long remainder(long instant) {\n        return instant - roundFloor(instant);\n    }", "readResolve": "\n    private Object readResolve() {\n        return iChronology.monthOfYear();\n    }"}