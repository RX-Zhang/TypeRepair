{"getMethod": "\n    public Method getMethod() {\n        return invocation.getMethod();\n    }", "getInvocation": "\n    public Invocation getInvocation() {\n        return this.invocation;\n    }", "getMatchers": "\n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }", "toString": "\n    public String toString() {\n        return new PrintSettings().print(matchers, invocation);\n    }", "matches": "\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }", "safelyArgumentsMatch": "\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }", "hasSimilarMethod": "\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }", "hasSameMethod": "\n    public boolean hasSameMethod(Invocation candidate) {\n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n            /* Avoid unnecessary cloning */\n            Class[] params1 = m1.getParameterTypes();\n            Class[] params2 = m2.getParameterTypes();\n            if (params1.length == params2.length) {\n                for (int i = 0; i < params1.length; i++) {\n                if (params1[i] != params2[i])\n                    return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }", "getLocation": "\n    public Location getLocation() {\n        return invocation.getLocation();\n    }", "captureArgumentsFrom": "\n    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            throw new UnsupportedOperationException();\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }", "isVarargMatcher": "\n    private boolean isVarargMatcher(Matcher matcher) {\n        Matcher actualMatcher = matcher;\n        if (actualMatcher instanceof MatcherDecorator) {\n            actualMatcher = ((MatcherDecorator) actualMatcher).getActualMatcher();\n        }\n        return actualMatcher instanceof VarargMatcher;\n    }", "isVariableArgument": "\n    private boolean isVariableArgument(Invocation invocation, int position) {\n        return invocation.getRawArguments().length - 1 == position\n                && invocation.getRawArguments()[position] != null\n                && invocation.getRawArguments()[position].getClass().isArray()\n                && invocation.getMethod().isVarArgs();\n    }", "createFrom": "\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n\n        return out;\n    }"}