{"init": "\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }", "getPattern": "\n    public String getPattern() {\n        return pattern;\n    }", "getTimeZone": "\n    public TimeZone getTimeZone() {\n        return timeZone;\n    }", "getLocale": "\n    public Locale getLocale() {\n        return locale;\n    }", "getParsePattern": "\n    Pattern getParsePattern() {\n        return parsePattern;\n    }", "equals": "\n    public boolean equals(Object obj) {\n        if (! (obj instanceof FastDateParser) ) {\n            return false;\n        }\n        FastDateParser other = (FastDateParser) obj;\n        return pattern.equals(other.pattern)\n            && timeZone.equals(other.timeZone)\n            && locale.equals(other.locale);\n    }", "hashCode": "\n    public int hashCode() {\n        return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode());\n    }", "toString": "\n    public String toString() {\n        return \"FastDateParser[\" + pattern + \",\" + locale + \",\" + timeZone.getID() + \"]\";\n    }", "readObject": "\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }", "parseObject": "\n    public Object parseObject(String source) throws ParseException {\n        return parse(source);\n    }", "parse": "\n    public Date parse(String source) throws ParseException {\n        Date date= parse(source, new ParsePosition(0));\n        if(date==null) {\n            // Add a note re supported date range\n            if (locale.equals(JAPANESE_IMPERIAL)) {\n                throw new ParseException(\n                        \"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n                                \"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n            }\n            throw new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n        }\n        return date;\n    }", "escapeRegex": "\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }", "getDisplayNames": "\n    KeyValue[] getDisplayNames(int field) {\n        Integer fieldInt = Integer.valueOf(field);\n        KeyValue[] fieldKeyValues= nameValues.get(fieldInt);\n        if(fieldKeyValues==null) {\n            DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n            switch(field) {\n            case Calendar.ERA:\n                // DateFormatSymbols#getEras() only returns AD/BC or translations\n                // It does not work for the Thai Buddhist or Japanese Imperial calendars.\n                // see: https://issues.apache.org/jira/browse/TRINIDAD-2126\n                Calendar c = Calendar.getInstance(locale);\n                // N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP\n                String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\n                String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\n                fieldKeyValues= createKeyValues(longEras, shortEras);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n                break;\n            case Calendar.AM_PM:\n                fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\n                break;\n            case Calendar.MONTH:\n                fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid field value \"+field);\n            }\n            KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\n            if(prior!=null) {\n                fieldKeyValues= prior;\n            }\n        }\n        return fieldKeyValues;\n    }", "toArray": "\n    private String[] toArray(Map<String, Integer> era) {\n        String[] eras = new String[era.size()]; // assume no gaps in entry values\n        for(Map.Entry<String, Integer> me : era.entrySet()) {\n            int idx = me.getValue().intValue();\n            final String key = me.getKey();\n            if (key == null) {\n                throw new IllegalArgumentException();\n            }\n            eras[idx] = key;\n        }\n        return eras;\n    }", "createKeyValues": "\n    private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\n        KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\n        copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\n        Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n        return fieldKeyValues;\n    }", "count": "\n    private static int count(String[] values) {\n        int count= 0;\n        if(values!=null) {\n            for(String value : values) {\n                if(value.length()>0) {\n                    ++count;\n                }\n            }\n        }\n        return count;\n    }", "copy": "\n    private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\n        if(values!=null) {\n            for(int i= 0; i<values.length; ++i) {\n                String value= values[i];\n                if(value.length()>0) {\n                    fieldKeyValues[offset++]= new KeyValue(value, i);\n                }\n            }\n        }\n        return offset;\n    }", "adjustYear": "\n    int adjustYear(int twoDigitYear) {\n        int trial= twoDigitYear + thisYear - thisYear%100;\n        if(trial < thisYear+20) {\n            return trial;\n        }\n        return trial-100;\n    }", "isNextNumber": "\n    boolean isNextNumber() {\n        return nextStrategy!=null && nextStrategy.isNumber();\n    }", "getFieldWidth": "\n    int getFieldWidth() {\n        return currentFormatField.length();\n    }", "getStrategy": "\n    private Strategy getStrategy(String formatField) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            //$FALL-THROUGH$\n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return DAY_OF_WEEK_STRATEGY;\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return ERA_STRATEGY;\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'Z':\n            break;\n        case 'a':\n            return AM_PM_STRATEGY;\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'z':\n            break;\n        }\n        TimeZoneStrategy tzs= tzsCache.get(locale);\n        if(tzs==null) {\n            tzs= new TimeZoneStrategy(locale);\n            TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\n            if(inCache!=null) {\n                return inCache;\n            }\n        }\n        return tzs;\n    }", "isNumber": "\n        public boolean isNumber() {\n            char c= formatField.charAt(0);\n            if(c=='\\'') {\n                c= formatField.charAt(1);\n            }\n            return Character.isDigit(c);\n        }", "addRegex": "\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            escapeRegex(regex, formatField, true);\n            return false;\n        }", "setCalendar": "\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n        }", "modify": "\n        public int modify(int iValue) {\n            return iValue;\n        }"}