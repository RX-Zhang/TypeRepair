{"isEmpty": "\n    public static boolean isEmpty(CharSequence str) {\n        return str == null || str.length() == 0;\n    }", "isNotEmpty": "\n    public static boolean isNotEmpty(CharSequence str) {\n        return !StringUtils.isEmpty(str);\n    }", "isBlank": "\n    public static boolean isBlank(CharSequence str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }", "isNotBlank": "\n    public static boolean isNotBlank(CharSequence str) {\n        return !StringUtils.isBlank(str);\n    }", "trim": "\n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }", "trimToNull": "\n    public static String trimToNull(String str) {\n        String ts = trim(str);\n        return isEmpty(ts) ? null : ts;\n    }", "trimToEmpty": "\n    public static String trimToEmpty(String str) {\n        return str == null ? EMPTY : str.trim();\n    }", "strip": "\n    public static String strip(String str) {\n        return strip(str, null);\n    }", "stripToNull": "\n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = strip(str, null);\n        return str.length() == 0 ? null : str;\n    }", "stripToEmpty": "\n    public static String stripToEmpty(String str) {\n        return str == null ? EMPTY : strip(str, null);\n    }", "stripStart": "\n    public static String stripStart(String str, String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }", "stripEnd": "\n    public static String stripEnd(String str, String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != -1)) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }", "stripAll": "\n    public static String[] stripAll(String[] strs) {\n        return stripAll(strs, null);\n    }", "stripAccents": "\n    public static String stripAccents(String input) {\n        if(input == null) {\n            return null;\n        }\n        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n\n            // String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);\n\n            // START of 1.5 reflection - in 1.6 use the line commented out above\n            try {\n                // get java.text.Normalizer.Form class\n                Class normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n\n                // get Normlizer class\n                Class normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);\n\n                // get static method on Normalizer\n                java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n\n                // get Normalizer.NFD field\n                java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");\n\n                // invoke method\n                String decomposed = (String) method.invoke( null, input, nfd.get(null) );\n                // END of 1.5 reflection\n\n                java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n                return accentPattern.matcher(decomposed).replaceAll(\"\");\n            } catch(ClassNotFoundException cnfe) {\n                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n            } catch(NoSuchMethodException nsme) {\n                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n            } catch(NoSuchFieldException nsfe) {\n                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n            } catch(IllegalAccessException iae) {\n                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n            } catch(IllegalArgumentException iae) {\n                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n            } catch(java.lang.reflect.InvocationTargetException ite) {\n                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n            } catch(SecurityException se) {\n                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n        }\n    }", "equals": "\n    public static boolean equals(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equals(str2);\n    }", "equalsIgnoreCase": "\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }", "indexOf": "\n    public static int indexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.indexOf(searchChar);\n    }", "ordinalIndexOf": "\n    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return 0;\n        }\n        int found = 0;\n        int index = INDEX_NOT_FOUND;\n        do {\n            index = str.indexOf(searchStr, index + 1);\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }", "lastIndexOf": "\n    public static int lastIndexOf(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return -1;\n        }\n        return str.lastIndexOf(searchChar);\n    }", "contains": "\n    public static boolean contains(String str, char searchChar) {\n        if (isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) >= 0;\n    }", "containsIgnoreCase": "\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }", "indexOfAny": "\n    public static int indexOfAny(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }", "containsAny": "\n    public static boolean containsAny(String str, char[] searchChars) {\n        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "indexOfAnyBut": "\n    public static int indexOfAnyBut(String str, char[] searchChars) {\n        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return -1;\n        }\n        outer : for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchChars.length; j++) {\n                if (searchChars[j] == ch) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }", "containsOnly": "\n    public static boolean containsOnly(String str, char[] valid) {\n        // All these pre-checks are to maintain API with an older version\n        if ((valid == null) || (str == null)) {\n            return false;\n        }\n        if (str.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(str, valid) == -1;\n    }", "containsNone": "\n    public static boolean containsNone(String str, char[] invalidChars) {\n        if (str == null || invalidChars == null) {\n            return true;\n        }\n        int strSize = str.length();\n        int validSize = invalidChars.length;\n        for (int i = 0; i < strSize; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < validSize; j++) {\n                if (invalidChars[j] == ch) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "lastIndexOfAny": "\n    public static int lastIndexOfAny(String str, String[] searchStrs) {\n        if ((str == null) || (searchStrs == null)) {\n            return -1;\n        }\n        int sz = searchStrs.length;\n        int ret = -1;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.lastIndexOf(search);\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }", "substring": "\n    public static String substring(String str, int start) {\n        if (str == null) {\n            return null;\n        }\n\n        // handle negatives, which means last n characters\n        if (start < 0) {\n            start = str.length() + start; // remember start is negative\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return EMPTY;\n        }\n\n        return str.substring(start);\n    }", "left": "\n    public static String left(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }", "right": "\n    public static String right(String str, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }", "mid": "\n    public static String mid(String str, int pos, int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= (pos + len)) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }", "substringBefore": "\n    public static String substringBefore(String str, String separator) {\n        if (isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }", "substringAfter": "\n    public static String substringAfter(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == -1) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }", "substringBeforeLast": "\n    public static String substringBeforeLast(String str, String separator) {\n        if (isEmpty(str) || isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == -1) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }", "substringAfterLast": "\n    public static String substringAfterLast(String str, String separator) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (isEmpty(separator)) {\n            return EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == -1 || pos == (str.length() - separator.length())) {\n            return EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }", "substringBetween": "\n    public static String substringBetween(String str, String tag) {\n        return substringBetween(str, tag, tag);\n    }", "substringsBetween": "\n    public static String[] substringsBetween(String str, String open, String close) {\n        if (str == null || isEmpty(open) || isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < (strLen - closeLen)) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        } \n        return list.toArray(new String [list.size()]);\n    }", "split": "\n    public static String[] split(String str) {\n        return split(str, null, -1);\n    }", "splitByWholeSeparator": "\n    public static String[] splitByWholeSeparator(String str, String separator) {\n        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n    }", "splitByWholeSeparatorPreserveAllTokens": "\n    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n        return splitByWholeSeparatorWorker(str, separator, -1, true);\n    }", "splitByWholeSeparatorWorker": "\n    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, \n                                                        boolean preserveAllTokens) \n    {\n        if (str == null) {\n            return null;\n        }\n\n        int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n        if ((separator == null) || (EMPTY.equals(separator))) {\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        int separatorLength = separator.length();\n\n        ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }", "splitPreserveAllTokens": "\n    public static String[] splitPreserveAllTokens(String str) {\n        return splitWorker(str, null, -1, true);\n    }", "splitWorker": "\n    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }", "splitByCharacterType": "\n    public static String[] splitByCharacterType(String str) {\n        return splitByCharacterType(str, false);\n    }", "splitByCharacterTypeCamelCase": "\n    public static String[] splitByCharacterTypeCamelCase(String str) {\n        return splitByCharacterType(str, true);\n    }", "join": "\n    public static String join(Object[] array) {\n        return join(array, null);\n    }", "deleteWhitespace": "\n    public static String deleteWhitespace(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }", "removeStart": "\n    public static String removeStart(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)){\n            return str.substring(remove.length());\n        }\n        return str;\n    }", "removeStartIgnoreCase": "\n    public static String removeStartIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }", "removeEnd": "\n    public static String removeEnd(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }", "removeEndIgnoreCase": "\n    public static String removeEndIgnoreCase(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        if (endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }", "remove": "\n    public static String remove(String str, String remove) {\n        if (isEmpty(str) || isEmpty(remove)) {\n            return str;\n        }\n        return replace(str, remove, EMPTY, -1);\n    }", "replaceOnce": "\n    public static String replaceOnce(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, 1);\n    }", "replace": "\n    public static String replace(String text, String searchString, String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }", "replaceEach": "\n    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n        return replaceEach(text, searchList, replacementList, false, 0);\n    }", "replaceEachRepeatedly": "\n    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n        // timeToLive should be 0 if not used or nothing to replace, else it's\n        // the length of the replace array\n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return replaceEach(text, searchList, replacementList, true, timeToLive);\n    }", "replaceChars": "\n    public static String replaceChars(String str, char searchChar, char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }", "overlay": "\n    public static String overlay(String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return new StringBuilder(len + start - end + overlay.length() + 1)\n            .append(str.substring(0, start))\n            .append(overlay)\n            .append(str.substring(end))\n            .toString();\n    }", "chomp": "\n    public static String chomp(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return EMPTY;\n            }\n            return str;\n        }\n\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }", "chop": "\n    public static String chop(String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }", "repeat": "\n    public static String repeat(String str, int repeat) {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }", "padding": "\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = padChar;\n        }\n        return new String(buf);\n    }", "rightPad": "\n    public static String rightPad(String str, int size) {\n        return rightPad(str, size, ' ');\n    }", "leftPad": "\n    public static String leftPad(String str, int size) {\n        return leftPad(str, size, ' ');\n    }", "length": "\n    public static int length(String str) {\n        return str == null ? 0 : str.length();\n    }", "center": "\n    public static String center(String str, int size) {\n        return center(str, size, ' ');\n    }", "upperCase": "\n    public static String upperCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }", "lowerCase": "\n    public static String lowerCase(String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }", "capitalize": "\n    public static String capitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toTitleCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }", "uncapitalize": "\n    public static String uncapitalize(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return new StringBuilder(strLen)\n            .append(Character.toLowerCase(str.charAt(0)))\n            .append(str.substring(1))\n            .toString();\n    }", "swapCase": "\n    public static String swapCase(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }", "countMatches": "\n    public static int countMatches(String str, String sub) {\n        if (isEmpty(str) || isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = str.indexOf(sub, idx)) != -1) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }", "isAlpha": "\n    public static boolean isAlpha(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetter(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }", "isAlphaSpace": "\n    public static boolean isAlphaSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }", "isAlphanumeric": "\n    public static boolean isAlphanumeric(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }", "isAlphanumericSpace": "\n    public static boolean isAlphanumericSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }", "isAsciiPrintable": "\n    public static boolean isAsciiPrintable(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }", "isNumeric": "\n    public static boolean isNumeric(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isDigit(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }", "isNumericSpace": "\n    public static boolean isNumericSpace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                return false;\n            }\n        }\n        return true;\n    }", "isWhitespace": "\n    public static boolean isWhitespace(String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                return false;\n            }\n        }\n        return true;\n    }", "isAllLowerCase": "\n    public static boolean isAllLowerCase(String str) {\n        if (str == null || isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isLowerCase(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }", "isAllUpperCase": "\n    public static boolean isAllUpperCase(String str) {\n        if (str == null || isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (Character.isUpperCase(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }", "defaultString": "\n    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }", "defaultIfEmpty": "\n    public static String defaultIfEmpty(String str, String defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }", "reverse": "\n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }", "reverseDelimited": "\n    public static String reverseDelimited(String str, char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        // could implement manually, but simple way is to reuse other,\n        // probably slower, methods.\n        String[] strs = split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return join(strs, separatorChar);\n    }", "abbreviate": "\n    public static String abbreviate(String str, int maxWidth) {\n        return abbreviate(str, 0, maxWidth);\n    }", "difference": "\n    public static String difference(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifference(str1, str2);\n        if (at == -1) {\n            return EMPTY;\n        }\n        return str2.substring(at);\n    }", "indexOfDifference": "\n    public static int indexOfDifference(String str1, String str2) {\n        if (str1 == str2) {\n            return -1;\n        }\n        if (str1 == null || str2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n            if (str1.charAt(i) != str2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < str2.length() || i < str1.length()) {\n            return i;\n        }\n        return -1;\n    }", "getCommonPrefix": "\n    public static String getCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return EMPTY;\n        }\n        int smallestIndexOfDiff = indexOfDifference(strs);\n        if (smallestIndexOfDiff == -1) {\n            // all strings were identical\n            if (strs[0] == null) {\n                return EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            // there were no common initial characters\n            return EMPTY;\n        } else {\n            // we found a common initial character sequence\n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }  ", "getLevenshteinDistance": "\n    public static int getLevenshteinDistance(String s, String t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n\n        /*\n           The difference between this impl. and the previous is that, rather \n           than creating and retaining a matrix of size s.length()+1 by t.length()+1, \n           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n           is the 'current working' distance array that maintains the newest distance cost\n           counts as we iterate through the characters of String s.  Each time we increment\n           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n           allows us to retain the previous cost counts as required by the algorithm (taking \n           the minimum of the cost count to the left, up one, and diagonally up and to the left\n           of the current cost count being calculated).  (Note that the arrays aren't really \n           copied anymore, just switched...this is clearly much better than cloning an array \n           or doing a System.arraycopy() each time  through the outer loop.)\n\n           Effectively, the difference between the two implementations is this one does not \n           cause an out of memory condition when calculating the LD over two very large strings.\n         */\n\n        int n = s.length(); // length of s\n        int m = t.length(); // length of t\n\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n\n        if (n > m) {\n            // swap the input strings to consume less memory\n            String tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n\n        int p[] = new int[n+1]; //'previous' cost array, horizontally\n        int d[] = new int[n+1]; // cost array, horizontally\n        int _d[]; //placeholder to assist in swapping p and d\n\n        // indexes into strings s and t\n        int i; // iterates through s\n        int j; // iterates through t\n\n        char t_j; // jth character of t\n\n        int cost; // cost\n\n        for (i = 0; i<=n; i++) {\n            p[i] = i;\n        }\n\n        for (j = 1; j<=m; j++) {\n            t_j = t.charAt(j-1);\n            d[0] = j;\n\n            for (i=1; i<=n; i++) {\n                cost = s.charAt(i-1)==t_j ? 0 : 1;\n                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n            }\n\n            // copy current distance counts to 'previous row' distance counts\n            _d = p;\n            p = d;\n            d = _d;\n        }\n\n        // our last action in the above loop was to switch d and p, so p now \n        // actually has the most recent cost counts\n        return p[n];\n    }", "startsWith": "\n    public static boolean startsWith(String str, String prefix) {\n        return startsWith(str, prefix, false);\n    }", "startsWithIgnoreCase": "\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return startsWith(str, prefix, true);\n    }", "startsWithAny": "\n    public static boolean startsWithAny(String string, String[] searchStrings) {\n        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (int i = 0; i < searchStrings.length; i++) {\n            String searchString = searchStrings[i];\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }", "endsWith": "\n    public static boolean endsWith(String str, String suffix) {\n        return endsWith(str, suffix, false);\n    }", "endsWithIgnoreCase": "\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return endsWith(str, suffix, true);\n    }"}