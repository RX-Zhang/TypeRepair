{"addParserWarning": "\n    void addParserWarning(String messageId, String messageArg, int lineno,\n        int charno) {\n      errorReporter.warning(\n          SimpleErrorReporter.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);\n    }", "addTypeWarning": "\n    void addTypeWarning(String messageId, String messageArg, int lineno,\n                    int charno) {\n      errorReporter.warning(\n          \"Bad type annotation. \" +\n          SimpleErrorReporter.getMessage1(messageId, messageArg),\n          getSourceName(), lineno, null, charno);\n    }", "setFileLevelJsDocBuilder": "\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }", "setFileOverviewJSDocInfo": "\n  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }", "getSourceName": "\n  private String getSourceName() {\n    return sourceFile == null ? null : sourceFile.getName();\n  }", "parseInlineTypeDoc": "\n  public JSDocInfo parseInlineTypeDoc() {\n    skipEOLs();\n\n    JsDocToken token = next();\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n    Node typeAst = parseTypeExpression(token);\n    recordTypeNode(lineno, startCharno, typeAst, token == JsDocToken.LC);\n\n    JSTypeExpression expr = createJSTypeExpression(typeAst);\n    if (expr != null) {\n      jsdocBuilder.recordType(expr);\n      return retrieveAndResetParsedJSDocInfo();\n    }\n    return null;\n  }", "recordTypeNode": "\n  private void recordTypeNode(int lineno, int startCharno, Node typeAst,\n      boolean matchingLC) {\n    if (typeAst != null) {\n      int endLineno = stream.getLineno();\n      int endCharno = stream.getCharno();\n      jsdocBuilder.markTypeNode(\n          typeAst, lineno, startCharno, endLineno, endCharno, matchingLC);\n    }\n  }", "parseTypeString": "\n  public static Node parseTypeString(String typeString) {\n    Config config = new Config(\n        Sets.<String>newHashSet(),\n        Sets.<String>newHashSet(),\n        false,\n        LanguageMode.ECMASCRIPT3,\n        false);\n    JsDocInfoParser parser = new JsDocInfoParser(\n        new JsDocTokenStream(typeString),\n        null,\n        null,\n        config,\n        NullErrorReporter.forNewRhino());\n\n    return parser.parseTopLevelTypeExpression(parser.next());\n  }", "parse": "\n  boolean parse() {\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());\n  }", "parseHelperLoop": "\n  private boolean parseHelperLoop(JsDocToken token,\n                                  List<ExtendedTypeInfo> extendedTypes) {\n    while (true) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            token = parseAnnotation(token, extendedTypes);\n          } else {\n            token = next();\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          break;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n          }\n          break;\n      }\n    }\n  }", "parseAnnotation": "\n  private JsDocToken parseAnnotation(JsDocToken token,\n      List<ExtendedTypeInfo> extendedTypes) {\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n\n    String annotationName = stream.getString();\n    Annotation annotation = annotationNames.get(annotationName);\n    if (annotation == null) {\n      parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n          stream.getLineno(), stream.getCharno());\n    } else {\n      // Mark the beginning of the annotation.\n      jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n      switch (annotation) {\n        case NG_INJECT:\n          if (jsdocBuilder.isNgInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordNgInject(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_INJECT:\n          if (jsdocBuilder.isJaggerInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerInject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerInject(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_MODULE:\n          if (jsdocBuilder.isJaggerModuleRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerModule.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerModule(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_PROVIDE:\n          if (jsdocBuilder.isJaggerProvideRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerProvide.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerProvide(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case AUTHOR:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo authorInfo = extractSingleLineBlock();\n            String author = authorInfo.string;\n\n            if (author.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addAuthor(author);\n            }\n            token = authorInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case CONSISTENTIDGENERATOR:\n          if (!jsdocBuilder.recordConsistentIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case STRUCT:\n          if (!jsdocBuilder.recordStruct()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DICT:\n          if (!jsdocBuilder.recordDict()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case CONSTRUCTOR:\n          if (!jsdocBuilder.recordConstructor()) {\n            if (jsdocBuilder.isInterfaceRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DEPRECATED:\n          if (!jsdocBuilder.recordDeprecated()) {\n            parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          // Find the reason/description, if any.\n          ExtractionInfo reasonInfo =\n              extractMultilineTextualBlock(token);\n\n          String reason = reasonInfo.string;\n\n          if (reason.length() > 0) {\n            jsdocBuilder.recordDeprecationReason(reason);\n          }\n\n          token = reasonInfo.token;\n          return token;\n\n        case INTERFACE:\n          if (!jsdocBuilder.recordInterface()) {\n            if (jsdocBuilder.isConstructorRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DESC:\n          if (jsdocBuilder.isDescriptionRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                stream.getLineno(), stream.getCharno());\n            return eatUntilEOLIfNotAnnotation();\n          } else {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            jsdocBuilder.recordDescription(description);\n            token = descriptionInfo.token;\n            return token;\n          }\n\n        case FILE_OVERVIEW:\n          String fileOverview = \"\";\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo fileOverviewInfo =\n                extractMultilineTextualBlock(token,\n                    WhitespaceOption.TRIM);\n\n            fileOverview = fileOverviewInfo.string;\n\n            token = fileOverviewInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n\n          if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n            parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case LICENSE:\n        case PRESERVE:\n          ExtractionInfo preserveInfo =\n              extractMultilineTextualBlock(token,\n                                           WhitespaceOption.PRESERVE);\n\n          String preserve = preserveInfo.string;\n\n          if (preserve.length() > 0) {\n            if (fileLevelJsDocBuilder != null) {\n              fileLevelJsDocBuilder.append(preserve);\n            }\n          }\n\n          token = preserveInfo.token;\n          return token;\n\n        case ENUM:\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          type = null;\n          if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n          }\n\n          if (type == null) {\n            type = createJSTypeExpression(newStringNode(\"number\"));\n          }\n          if (!jsdocBuilder.recordEnumParameterType(type)) {\n            parser.addTypeWarning(\n                \"msg.jsdoc.incompat.type\", lineno, charno);\n          }\n          token = eatUntilEOLIfNotAnnotation(token);\n          return token;\n\n        case EXPORT:\n          if (!jsdocBuilder.recordExport()) {\n            parser.addParserWarning(\"msg.jsdoc.export\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXPOSE:\n          if (!jsdocBuilder.recordExpose()) {\n            parser.addParserWarning(\"msg.jsdoc.expose\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXTERNS:\n          if (!jsdocBuilder.recordExterns()) {\n            parser.addParserWarning(\"msg.jsdoc.externs\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAVA_DISPATCH:\n          if (!jsdocBuilder.recordJavaDispatch()) {\n            parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXTENDS:\n        case IMPLEMENTS:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          boolean matchingRc = false;\n\n          if (token == JsDocToken.LC) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (token == JsDocToken.STRING) {\n            Node typeNode = parseAndRecordTypeNameNode(\n                token, lineno, charno, matchingRc);\n\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            typeNode = wrapNode(Token.BANG, typeNode);\n            type = createJSTypeExpression(typeNode);\n\n            if (annotation == Annotation.EXTENDS) {\n              // record the extended type, check later\n              extendedTypes.add(new ExtendedTypeInfo(\n                  type, stream.getLineno(), stream.getCharno()));\n            } else {\n              Preconditions.checkState(\n                  annotation == Annotation.IMPLEMENTS);\n              if (!jsdocBuilder.recordImplementedInterface(type)) {\n                parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                    lineno, charno);\n              }\n            }\n            token = next();\n            if (matchingRc) {\n              if (token != JsDocToken.RC) {\n                parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                    stream.getLineno(), stream.getCharno());\n              } else {\n                token = next();\n              }\n            } else if (token != JsDocToken.EOL &&\n                token != JsDocToken.EOF && token != JsDocToken.EOC) {\n              parser.addTypeWarning(\"msg.end.annotation.expected\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n          }\n          token = eatUntilEOLIfNotAnnotation(token);\n          return token;\n\n        case HIDDEN:\n          if (!jsdocBuilder.recordHiddenness()) {\n            parser.addParserWarning(\"msg.jsdoc.hidden\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case LENDS:\n          skipEOLs();\n\n          matchingRc = false;\n          if (match(JsDocToken.LC)) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (match(JsDocToken.STRING)) {\n            token = next();\n            if (!jsdocBuilder.recordLends(stream.getString())) {\n              parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          if (matchingRc && !match(JsDocToken.RC)) {\n            parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case MEANING:\n          ExtractionInfo meaningInfo =\n              extractMultilineTextualBlock(token);\n          String meaning = meaningInfo.string;\n          token = meaningInfo.token;\n          if (!jsdocBuilder.recordMeaning(meaning)) {\n            parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case NO_ALIAS:\n          if (!jsdocBuilder.recordNoAlias()) {\n            parser.addParserWarning(\"msg.jsdoc.noalias\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_COMPILE:\n          if (!jsdocBuilder.recordNoCompile()) {\n            parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_TYPE_CHECK:\n          if (!jsdocBuilder.recordNoTypeCheck()) {\n            parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NOT_IMPLEMENTED:\n          return eatUntilEOLIfNotAnnotation();\n\n        case INHERIT_DOC:\n        case OVERRIDE:\n          if (!jsdocBuilder.recordOverride()) {\n            parser.addTypeWarning(\"msg.jsdoc.override\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case THROWS: {\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatUntilEOLIfNotAnnotation();\n            }\n          }\n\n          // *Update* the token to that after the type annotation.\n          token = current();\n\n          // Save the throw type.\n          jsdocBuilder.recordThrowType(type);\n\n          boolean isAnnotationNext = lookAheadForAnnotation();\n\n          // Find the throw's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            if (description.length() > 0) {\n              jsdocBuilder.recordThrowDescription(type, description);\n            }\n\n            token = descriptionInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n        }\n\n        case PARAM:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordParamTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatUntilEOLIfNotAnnotation();\n            }\n            skipEOLs();\n            token = next();\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n          }\n\n          String name = null;\n          boolean isBracketedParam = JsDocToken.LB == token;\n          if (isBracketedParam) {\n            token = next();\n          }\n\n          if (JsDocToken.STRING != token) {\n            parser.addTypeWarning(\"msg.missing.variable.name\",\n                lineno, charno);\n          } else {\n            name = stream.getString();\n\n            if (isBracketedParam) {\n              token = next();\n\n              // Throw out JsDocToolkit's \"default\" parameter\n              // annotation.  It makes no sense under our type\n              // system.\n              if (JsDocToken.EQUALS == token) {\n                token = next();\n                if (JsDocToken.STRING == token) {\n                  token = next();\n                }\n              }\n\n              if (JsDocToken.RB != token) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n              } else if (type != null) {\n                // Make the type expression optional, if it isn't\n                // already.\n                type = JSTypeExpression.makeOptionalArg(type);\n              }\n            }\n\n            // If the param name has a DOT in it, just throw it out\n            // quietly. We do not handle the JsDocToolkit method\n            // for handling properties of params.\n            if (name.indexOf('.') > -1) {\n              name = null;\n            } else if (!jsdocBuilder.recordParameter(name, type)) {\n              if (jsdocBuilder.hasParameter(name)) {\n                parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                    lineno, charno);\n              } else {\n                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                    lineno, charno);\n              }\n            }\n          }\n\n          if (name == null) {\n            token = eatUntilEOLIfNotAnnotation(token);\n            return token;\n          }\n\n          jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n          // Find the parameter's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation()\n              && token != JsDocToken.ANNOTATION) {\n            ExtractionInfo paramDescriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String paramDescription = paramDescriptionInfo.string;\n\n            if (paramDescription.length() > 0) {\n              jsdocBuilder.recordParameterDescription(name,\n                  paramDescription);\n            }\n\n            token = paramDescriptionInfo.token;\n          } else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case PRESERVE_TRY:\n          if (!jsdocBuilder.recordPreserveTry()) {\n            parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_SHADOW:\n          if (!jsdocBuilder.recordNoShadow()) {\n            parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_SIDE_EFFECTS:\n          if (!jsdocBuilder.recordNoSideEffects()) {\n            parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case MODIFIES:\n          token = parseModifiesTag(next());\n          return token;\n\n        case IMPLICIT_CAST:\n          if (!jsdocBuilder.recordImplicitCast()) {\n            parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case SEE:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo referenceInfo = extractSingleLineBlock();\n            String reference = referenceInfo.string;\n\n            if (reference.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addReference(reference);\n            }\n\n            token = referenceInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case STABLEIDGENERATOR:\n          if (!jsdocBuilder.recordStableIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case SUPPRESS:\n          token = parseSuppressTag(next());\n          return token;\n\n        case TEMPLATE: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case IDGENERATOR:\n          token = parseIdGeneratorTag(next());\n          return token;\n\n        case WIZACTION:\n          if (!jsdocBuilder.recordWizaction()) {\n            parser.addParserWarning(\"msg.jsdoc.wizaction\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DISPOSES: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.missing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordDisposesParameter(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.error\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case VERSION:\n          ExtractionInfo versionInfo = extractSingleLineBlock();\n          String version = versionInfo.string;\n\n          if (version.length() == 0) {\n            parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else {\n            if (!jsdocBuilder.recordVersion(version)) {\n               parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n\n          token = versionInfo.token;\n          return token;\n\n        case CONSTANT:\n        case DEFINE:\n        case RETURN:\n        case PRIVATE:\n        case PROTECTED:\n        case PUBLIC:\n        case THIS:\n        case TYPE:\n        case TYPEDEF:\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          Node typeNode = null;\n          boolean hasType = lookAheadForType();\n          boolean isAlternateTypeAnnotation =\n              (annotation == Annotation.PRIVATE ||\n               annotation == Annotation.PROTECTED ||\n               annotation == Annotation.PUBLIC ||\n               annotation == Annotation.CONSTANT);\n          boolean canSkipTypeAnnotation =\n              (isAlternateTypeAnnotation ||\n               annotation == Annotation.RETURN);\n          type = null;\n          if (hasType || !canSkipTypeAnnotation) {\n            skipEOLs();\n            token = next();\n            typeNode = parseAndRecordTypeNode(token);\n\n            if (annotation == Annotation.THIS) {\n              typeNode = wrapNode(Token.BANG, typeNode);\n            }\n            type = createJSTypeExpression(typeNode);\n          }\n\n          // The error was reported during recursive descent\n          // recovering parsing\n          boolean hasError = type == null && !canSkipTypeAnnotation;\n          if (!hasError) {\n            // Record types for @type.\n            // If the @private, @protected, or @public annotations\n            // have a type attached, pretend that they actually wrote:\n            // @type {type}\\n@private\n            // This will have some weird behavior in some cases\n            // (for example, @private can now be used as a type-cast),\n            // but should be mostly OK.\n            if ((type != null && isAlternateTypeAnnotation)\n                || annotation == Annotation.TYPE) {\n              if (!jsdocBuilder.recordType(type)) {\n                parser.addTypeWarning(\n                    \"msg.jsdoc.incompat.type\", lineno, charno);\n              }\n            }\n\n            switch (annotation) {\n              case CONSTANT:\n                if (!jsdocBuilder.recordConstancy()) {\n                  parser.addParserWarning(\"msg.jsdoc.const\",\n                      stream.getLineno(), stream.getCharno());\n                }\n                break;\n\n              case DEFINE:\n                if (!jsdocBuilder.recordDefineType(type)) {\n                  parser.addParserWarning(\"msg.jsdoc.define\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PRIVATE:\n                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.private\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PROTECTED:\n                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.protected\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PUBLIC:\n                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.public\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case RETURN:\n                if (type == null) {\n                  type = createJSTypeExpression(newNode(Token.QMARK));\n                }\n\n                if (!jsdocBuilder.recordReturnType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                  break;\n                }\n\n                // TODO(johnlenz): The extractMultilineTextualBlock method\n                // and friends look directly at the stream, regardless of\n                // last token read, so we don't want to read the first\n                // \"STRING\" out of the stream.\n\n                boolean isAnnotationNext = lookAheadForAnnotation();\n\n                // Find the return's description (if applicable).\n                if (jsdocBuilder.shouldParseDocumentation()\n                    && !isAnnotationNext) {\n                  ExtractionInfo returnDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String returnDescription =\n                      returnDescriptionInfo.string;\n\n                  if (returnDescription.length() > 0) {\n                    jsdocBuilder.recordReturnDescription(\n                        returnDescription);\n                  }\n\n                  token = returnDescriptionInfo.token;\n                } else {\n                  token = eatUntilEOLIfNotAnnotation();\n                }\n                return token;\n\n              case THIS:\n                if (!jsdocBuilder.recordThisType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n\n              case TYPEDEF:\n                if (!jsdocBuilder.recordTypedef(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n            }\n          }\n\n          return eatUntilEOLIfNotAnnotation();\n      }\n    }\n\n    return next();\n  }", "recordDescription": "\n  private JsDocToken recordDescription(JsDocToken token) {\n    // Find marker's description (if applicable).\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n      token = descriptionInfo.token;\n    } else {\n      token = eatTokensUntilEOL(token);\n    }\n    return token;\n  }", "checkExtendedTypes": "\n  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n      // If interface, record the multiple extended interfaces\n      if (jsdocBuilder.isInterfaceRecorded()) {\n        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      } else {\n        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      }\n    }\n  }", "parseSuppressTag": "\n  private JsDocToken parseSuppressTag(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      Set<String> suppressions = new HashSet<String>();\n      while (true) {\n        if (match(JsDocToken.STRING)) {\n          String name = stream.getString();\n          if (!suppressionNames.contains(name)) {\n            parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                stream.getLineno(), stream.getCharno());\n          }\n\n          suppressions.add(stream.getString());\n          token = next();\n        } else {\n          parser.addParserWarning(\"msg.jsdoc.suppress\",\n              stream.getLineno(), stream.getCharno());\n          return token;\n        }\n\n        if (match(JsDocToken.PIPE, JsDocToken.COMMA)) {\n          token = next();\n        } else {\n          break;\n        }\n      }\n\n      if (!match(JsDocToken.RC)) {\n        parser.addParserWarning(\"msg.jsdoc.suppress\",\n            stream.getLineno(), stream.getCharno());\n      } else {\n        token = next();\n        if (!jsdocBuilder.recordSuppressions(suppressions)) {\n          parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n              stream.getLineno(), stream.getCharno());\n        }\n      }\n    }\n    return token;\n  }", "parseModifiesTag": "\n  private JsDocToken parseModifiesTag(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      Set<String> modifies = new HashSet<String>();\n      while (true) {\n        if (match(JsDocToken.STRING)) {\n          String name = stream.getString();\n          if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name)) {\n              parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());\n          }\n\n          modifies.add(stream.getString());\n          token = next();\n        } else {\n          parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());\n          return token;\n        }\n\n        if (match(JsDocToken.PIPE)) {\n          token = next();\n        } else {\n          break;\n        }\n      }\n\n      if (!match(JsDocToken.RC)) {\n        parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());\n      } else {\n        token = next();\n        if (!jsdocBuilder.recordModifies(modifies)) {\n          parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());\n        }\n      }\n    }\n    return token;\n  }", "parseIdGeneratorTag": "\n  private JsDocToken parseIdGeneratorTag(JsDocToken token) {\n    String idgenKind = \"unique\";\n    if (token == JsDocToken.LC) {\n      if (match(JsDocToken.STRING)) {\n        String name = stream.getString();\n        if (!idGeneratorAnnotationKeywords.contains(name)\n            && !jsdocBuilder.hasParameter(name)) {\n            parser.addParserWarning(\"msg.jsdoc.idgen.unknown\", name,\n                stream.getLineno(), stream.getCharno());\n        }\n\n        idgenKind = name;\n        token = next();\n      } else {\n        parser.addParserWarning(\"msg.jsdoc.idgen.bad\",\n            stream.getLineno(), stream.getCharno());\n        return token;\n      }\n\n      if (!match(JsDocToken.RC)) {\n        parser.addParserWarning(\"msg.jsdoc.idgen.bad\",\n            stream.getLineno(), stream.getCharno());\n      } else {\n        token = next();\n      }\n    }\n\n    if (idgenKind.equals(\"unique\")) {\n      if (!jsdocBuilder.recordIdGenerator()) {\n        parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\",\n            stream.getLineno(), stream.getCharno());\n      }\n    } else if (idgenKind.equals(\"consistent\")) {\n      if (!jsdocBuilder.recordConsistentIdGenerator()) {\n        parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\",\n            stream.getLineno(), stream.getCharno());\n      }\n    } else if (idgenKind.equals(\"stable\")) {\n      if (!jsdocBuilder.recordStableIdGenerator()) {\n        parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\",\n            stream.getLineno(), stream.getCharno());\n      }\n    } else if (idgenKind.equals(\"mapped\")) {\n      if (!jsdocBuilder.recordMappedIdGenerator()) {\n        parser.addParserWarning(\"msg.jsdoc.idgen.duplicate\",\n            stream.getLineno(), stream.getCharno());\n      }\n    }\n\n    return token;\n  }", "parseAndRecordTypeNode": "\n  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LC, false);\n  }", "parseAndRecordTypeNameNode": "\n  private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC) {\n    return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);\n  }", "parseAndRecordParamTypeNode": "\n  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parseParamTypeExpressionAnnotation(token);\n    recordTypeNode(lineno, startCharno, typeNode, true);\n    return typeNode;\n  }", "toString": "\n  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }", "createJSTypeExpression": "\n  JSTypeExpression createJSTypeExpression(Node n) {\n    return n == null ? null :\n        new JSTypeExpression(n, getSourceName());\n  }", "extractSingleLineBlock": "\n  private ExtractionInfo extractSingleLineBlock() {\n\n    // Get the current starting point.\n    stream.update();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno() + 1;\n\n    String line = getRemainingJSDocLine().trim();\n\n    // Record the textual description.\n    if (line.length() > 0) {\n      jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());\n    }\n\n    return new ExtractionInfo(line, next());\n  }", "extractMultilineTextualBlock": "\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {\n    return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);\n  }", "extractBlockComment": "\n  private ExtractionInfo extractBlockComment(JsDocToken token) {\n    StringBuilder builder = new StringBuilder();\n\n    boolean ignoreStar = true;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }", "trimEnd": "\n  private static String trimEnd(String s) {\n    int trimCount = 0;\n    while (trimCount < s.length()) {\n      char ch = s.charAt(s.length() - trimCount - 1);\n      if (Character.isWhitespace(ch)) {\n        trimCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (trimCount == 0) {\n      return s;\n    }\n    return s.substring(0, s.length() - trimCount);\n  }", "parseTypeExpressionAnnotation": "\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }", "parseParamTypeExpressionAnnotation": "\n  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }", "parseTypeNameAnnotation": "\n  private Node parseTypeNameAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTypeName(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeName(token);\n    }\n  }", "parseTopLevelTypeExpression": "\n  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }", "parseTypeExpressionList": "\n  private Node parseTypeExpressionList(JsDocToken token) {\n    Node typeExpr = parseTopLevelTypeExpression(token);\n    if (typeExpr == null) {\n      return null;\n    }\n    Node typeList = IR.block();\n    typeList.addChildToBack(typeExpr);\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      typeExpr = parseTopLevelTypeExpression(next());\n      if (typeExpr == null) {\n        return null;\n      }\n      typeList.addChildToBack(typeExpr);\n    }\n    return typeList;\n  }", "parseTypeExpression": "\n  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 8 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // {Array.<?>} - greater than\n      // /** ? */ - EOC (inline types)\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT ||\n          token == JsDocToken.EOC) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }", "parseContextTypeExpression": "\n  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }", "parseBasicTypeExpression": "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }", "parseTypeName": "\n  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }", "parseFunctionType": "\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseContextTypeExpression(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }", "parseParametersType": "\n  private Node parseParametersType(JsDocToken token) {\n    Node paramsType = newNode(Token.PARAM_LIST);\n    boolean isVarArgs = false;\n    Node paramType = null;\n    if (token != JsDocToken.RP) {\n      do {\n        if (paramType != null) {\n          // skip past the comma\n          next();\n          skipEOLs();\n          token = next();\n        }\n\n        if (token == JsDocToken.ELLIPSIS) {\n          // In the latest ES4 proposal, there are no type constraints allowed\n          // on variable arguments. We support the old syntax for backwards\n          // compatibility, but we should gradually tear it out.\n          skipEOLs();\n          if (match(JsDocToken.RP)) {\n            paramType = newNode(Token.ELLIPSIS);\n          } else {\n            skipEOLs();\n            if (!match(JsDocToken.LB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n            }\n\n            next();\n            skipEOLs();\n            paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n            skipEOLs();\n            if (!match(JsDocToken.RB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            skipEOLs();\n            next();\n          }\n\n          isVarArgs = true;\n        } else {\n          paramType = parseTypeExpression(token);\n          if (match(JsDocToken.EQUALS)) {\n            skipEOLs();\n            next();\n            paramType = wrapNode(Token.EQUALS, paramType);\n          }\n        }\n\n        if (paramType == null) {\n          return null;\n        }\n        paramsType.addChildToBack(paramType);\n        if (isVarArgs) {\n          break;\n        }\n      } while (match(JsDocToken.COMMA));\n    }\n\n    if (isVarArgs && match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n    }\n\n    // The right paren will be checked by parseFunctionType\n\n    return paramsType;\n  }", "parseResultType": "\n  private Node parseResultType(JsDocToken token) {\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return newNode(Token.EMPTY);\n    }\n\n    token = next();\n    skipEOLs();\n    if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) {\n      next();\n      return newNode(Token.VOID);\n    } else {\n      return parseTypeExpression(next());\n    }\n  }", "parseUnionType": "\n  private Node parseUnionType(JsDocToken token) {\n    return parseUnionTypeWithAlternate(token, null);\n  }", "parseUnionTypeWithAlternate": "\n  private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {\n    Node union = newNode(Token.PIPE);\n    if (alternate != null) {\n      union.addChildToBack(alternate);\n    }\n\n    Node expr = null;\n    do {\n      if (expr != null) {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n        boolean isPipe = token == JsDocToken.PIPE;\n        if (isPipe && match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n      }\n      expr = parseTypeExpression(token);\n      if (expr == null) {\n        return null;\n      }\n\n      union.addChildToBack(expr);\n      // We support commas for backwards compatibility.\n    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n    if (alternate == null) {\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n    }\n    return union;\n  }", "parseArrayType": "\n  private Node parseArrayType(JsDocToken token) {\n    Node array = newNode(Token.LB);\n    Node arg = null;\n    boolean hasVarArgs = false;\n\n    do {\n      if (arg != null) {\n        next();\n        skipEOLs();\n        token = next();\n      }\n      if (token == JsDocToken.ELLIPSIS) {\n        arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n        hasVarArgs = true;\n      } else {\n        arg = parseTypeExpression(token);\n      }\n\n      if (arg == null) {\n        return null;\n      }\n\n      array.addChildToBack(arg);\n      if (hasVarArgs) {\n        break;\n      }\n      skipEOLs();\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n  }", "parseRecordType": "\n  private Node parseRecordType(JsDocToken token) {\n    Node recordType = newNode(Token.LC);\n    Node fieldTypeList = parseFieldTypeList(token);\n\n    if (fieldTypeList == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RC)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    }\n\n    next();\n\n    recordType.addChildToBack(fieldTypeList);\n    return recordType;\n  }", "parseFieldTypeList": "\n  private Node parseFieldTypeList(JsDocToken token) {\n    Node fieldTypeList = newNode(Token.LB);\n\n    do {\n      Node fieldType = parseFieldType(token);\n\n      if (fieldType == null) {\n        return null;\n      }\n\n      fieldTypeList.addChildToBack(fieldType);\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) {\n        break;\n      }\n\n      // Move to the comma token.\n      next();\n\n      // Move to the token passed the comma.\n      skipEOLs();\n      token = next();\n    } while (true);\n\n    return fieldTypeList;\n  }", "parseFieldType": "\n  private Node parseFieldType(JsDocToken token) {\n    Node fieldName = parseFieldName(token);\n\n    if (fieldName == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return fieldName;\n    }\n\n    // Move to the colon.\n    next();\n\n    // Move to the token after the colon and parse\n    // the type expression.\n    skipEOLs();\n    Node typeExpression = parseTypeExpression(next());\n\n    if (typeExpression == null) {\n      return null;\n    }\n\n    Node fieldType = newNode(Token.COLON);\n    fieldType.addChildToBack(fieldName);\n    fieldType.addChildToBack(typeExpression);\n    return fieldType;\n  }", "parseFieldName": "\n  private Node parseFieldName(JsDocToken token) {\n    switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }\n  }", "wrapNode": "\n  private Node wrapNode(int type, Node n) {\n    return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);\n  }", "newNode": "\n  private Node newNode(int type) {\n    return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);\n  }", "newStringNode": "\n  private Node newStringNode(String s) {\n    return newStringNode(s, stream.getLineno(), stream.getCharno());\n  }", "createTemplateNode": "\n  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = IR.script();\n    templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);\n    return templateNode;\n  }", "reportTypeSyntaxWarning": "\n  private Node reportTypeSyntaxWarning(String warning) {\n    parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());\n    return null;\n  }", "reportGenericTypeSyntaxWarning": "\n  private Node reportGenericTypeSyntaxWarning() {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");\n  }", "eatUntilEOLIfNotAnnotation": "\n  private JsDocToken eatUntilEOLIfNotAnnotation() {\n    return eatUntilEOLIfNotAnnotation(next());\n  }", "eatTokensUntilEOL": "\n  private JsDocToken eatTokensUntilEOL() {\n    return eatTokensUntilEOL(next());\n  }", "restoreLookAhead": "\n  private void restoreLookAhead(JsDocToken token) {\n    unreadToken = token;\n  }", "match": "\n  private boolean match(JsDocToken token) {\n    unreadToken = next();\n    return unreadToken == token;\n  }", "next": "\n  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }", "current": "\n  private JsDocToken current() {\n    JsDocToken t = unreadToken;\n    unreadToken = NO_UNREAD_TOKEN;\n    return t;\n  }", "skipEOLs": "\n  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }", "getRemainingJSDocLine": "\n  private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n    return result;\n  }", "hasParsedFileOverviewDocInfo": "\n  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }", "hasParsedJSDocInfo": "\n  boolean hasParsedJSDocInfo() {\n    return jsdocBuilder.isPopulated();\n  }", "retrieveAndResetParsedJSDocInfo": "\n  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(associatedNode);\n  }", "getFileOverviewJSDocInfo": "\n  JSDocInfo getFileOverviewJSDocInfo() {\n    return fileOverviewJSDocInfo;\n  }", "lookAheadForType": "\n  private boolean lookAheadForType() {\n    return lookAheadFor('{');\n  }\n\n  private boolean lookAheadForAnnotation() {\n    return lookAheadFor('@');\n  }\n\n  /**\n   * Look ahead by advancing the character stream.\n   * Does not modify the token stream.\n   * @return Whether we found the char.\n   */\n  private boolean lookAheadFor(char expect) {\n    boolean matched = false;\n    int c;\n    while (true) {\n      c = stream.getChar();\n      if (c == ' ') {\n        continue;\n      } else if (c == expect) {\n        matched = true;\n        break;\n      } else {\n        break;\n      }\n    }\n    stream.ungetChar(c);\n    return matched;\n  }\n}", "lookAheadForAnnotation": "\n  private boolean lookAheadForAnnotation() {\n    return lookAheadFor('@');\n  }", "lookAheadFor": "\n  private boolean lookAheadFor(char expect) {\n    boolean matched = false;\n    int c;\n    while (true) {\n      c = stream.getChar();\n      if (c == ' ') {\n        continue;\n      } else if (c == expect) {\n        matched = true;\n        break;\n      } else {\n        break;\n      }\n    }\n    stream.ungetChar(c);\n    return matched;\n  }"}