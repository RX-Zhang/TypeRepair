{"abs": "\n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }", "add": "\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }", "conjugate": "\n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n        return createComplex(real, -imaginary);\n    }", "divide": "\n    public Complex divide(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }", "equals": "\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN) {\n                return isNaN;\n            } else {\n                return (real == rhs.real) && (imaginary == rhs.imaginary);\n            }\n        }\n        return false;\n    }", "hashCode": "\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }", "getImaginary": "\n    public double getImaginary() {\n        return imaginary;\n    }", "getReal": "\n    public double getReal() {\n        return real;\n    }", "isNaN": "\n    public boolean isNaN() {\n        return isNaN;\n    }", "isInfinite": "\n    public boolean isInfinite() {\n        return isInfinite;\n    }", "multiply": "\n    public Complex multiply(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            // we don't use Complex.isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }", "negate": "\n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }", "subtract": "\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }", "acos": "\n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }", "asin": "\n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }", "atan": "\n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }", "cos": "\n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n            -FastMath.sin(real) * MathUtils.sinh(imaginary));\n    }", "cosh": "\n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n            MathUtils.sinh(real) * FastMath.sin(imaginary));\n    }", "exp": "\n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n    }", "log": "\n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n            FastMath.atan2(imaginary, real));\n    }", "pow": "\n    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }", "sin": "\n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n            FastMath.cos(real) * MathUtils.sinh(imaginary));\n    }", "sinh": "\n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),\n            MathUtils.cosh(real) * FastMath.sin(imaginary));\n    }", "sqrt": "\n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }", "sqrt1z": "\n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }", "tan": "\n    public Complex tan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }", "tanh": "\n    public Complex tanh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n    }", "getArgument": "\n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }", "nthRoot": "\n    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n\n        if (n <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                    n);\n        }\n\n        List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument()/n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart      = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }", "createComplex": "\n    protected Complex createComplex(double realPart, double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }", "readResolve": "\n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }", "getField": "\n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }", "toString": "\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }"}