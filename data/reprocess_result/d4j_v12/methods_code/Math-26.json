{"abs": "\n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;\n    }", "compareTo": "\n    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }", "doubleValue": "\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }", "equals": "\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            // since fractions are always in lowest terms, numerators and\n            // denominators can be compared directly for equality.\n            Fraction rhs = (Fraction)other;\n            return (numerator == rhs.numerator) &&\n                (denominator == rhs.denominator);\n        }\n        return false;\n    }", "floatValue": "\n    public float floatValue() {\n        return (float)doubleValue();\n    }", "getDenominator": "\n    public int getDenominator() {\n        return denominator;\n    }", "getNumerator": "\n    public int getNumerator() {\n        return numerator;\n    }", "hashCode": "\n    public int hashCode() {\n        return 37 * (37 * 17 + numerator) + denominator;\n    }", "intValue": "\n    public int intValue() {\n        return (int)doubleValue();\n    }", "longValue": "\n    public long longValue() {\n        return (long)doubleValue();\n    }", "negate": "\n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }", "reciprocal": "\n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }", "add": "\n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true /* add */);\n    }", "subtract": "\n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false /* subtract */);\n    }", "addSub": "\n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }\n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        int d1 = ArithmeticUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            int uvp = ArithmeticUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) :\n                 ArithmeticUtils.subAndCheck(uvp, upv),\n                 ArithmeticUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:ArithmeticUtils.gcd(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY,\n                                              w);\n        }\n        return new Fraction (w.intValue(),\n                ArithmeticUtils.mulAndCheck(denominator/d1,\n                        fraction.denominator/d2));\n    }", "multiply": "\n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        // knuth 4.5.1\n        // make sure we don't overflow unless the result *must* overflow.\n        int d1 = ArithmeticUtils.gcd(numerator, fraction.denominator);\n        int d2 = ArithmeticUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (ArithmeticUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                ArithmeticUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }", "divide": "\n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION);\n        }\n        if (fraction.numerator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY,\n                                              fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }", "percentageValue": "\n    public double percentageValue() {\n        return 100 * doubleValue();\n    }", "getReducedFraction": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = ArithmeticUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }", "toString": "\n    public String toString() {\n        String str = null;\n        if (denominator == 1) {\n            str = Integer.toString(numerator);\n        } else if (numerator == 0) {\n            str = \"0\";\n        } else {\n            str = numerator + \" / \" + denominator;\n        }\n        return str;\n    }", "getField": "\n    public FractionField getField() {\n        return FractionField.getInstance();\n    }"}