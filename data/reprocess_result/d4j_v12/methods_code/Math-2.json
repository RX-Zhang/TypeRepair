{"cumulativeProbability": "\n    public double cumulativeProbability(int x) {\n        double ret;\n\n        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x < domain[0]) {\n            ret = 0.0;\n        } else if (x >= domain[1]) {\n            ret = 1.0;\n        } else {\n            ret = innerCumulativeProbability(domain[0], x, 1);\n        }\n\n        return ret;\n    }", "getDomain": "\n    private int[] getDomain(int n, int m, int k) {\n        return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n    }", "getLowerDomain": "\n    private int getLowerDomain(int n, int m, int k) {\n        return FastMath.max(0, m - (n - k));\n    }", "getNumberOfSuccesses": "\n    public int getNumberOfSuccesses() {\n        return numberOfSuccesses;\n    }", "getPopulationSize": "\n    public int getPopulationSize() {\n        return populationSize;\n    }", "getSampleSize": "\n    public int getSampleSize() {\n        return sampleSize;\n    }", "getUpperDomain": "\n    private int getUpperDomain(int m, int k) {\n        return FastMath.min(k, m);\n    }", "probability": "\n    public double probability(int x) {\n        double ret;\n\n        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x < domain[0] || x > domain[1]) {\n            ret = 0.0;\n        } else {\n            double p = (double) sampleSize / (double) populationSize;\n            double q = (double) (populationSize - sampleSize) / (double) populationSize;\n            double p1 = SaddlePointExpansion.logBinomialProbability(x,\n                    numberOfSuccesses, p, q);\n            double p2 =\n                SaddlePointExpansion.logBinomialProbability(sampleSize - x,\n                    populationSize - numberOfSuccesses, p, q);\n            double p3 =\n                SaddlePointExpansion.logBinomialProbability(sampleSize, populationSize, p, q);\n            ret = FastMath.exp(p1 + p2 - p3);\n        }\n\n        return ret;\n    }", "upperCumulativeProbability": "\n    public double upperCumulativeProbability(int x) {\n        double ret;\n\n        final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x <= domain[0]) {\n            ret = 1.0;\n        } else if (x > domain[1]) {\n            ret = 0.0;\n        } else {\n            ret = innerCumulativeProbability(domain[1], x, -1);\n        }\n\n        return ret;\n    }", "innerCumulativeProbability": "\n    private double innerCumulativeProbability(int x0, int x1, int dx) {\n        double ret = probability(x0);\n        while (x0 != x1) {\n            x0 += dx;\n            ret += probability(x0);\n        }\n        return ret;\n    }", "getNumericalMean": "\n    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }", "getNumericalVariance": "\n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }", "calculateNumericalVariance": "\n    protected double calculateNumericalVariance() {\n        final double N = getPopulationSize();\n        final double m = getNumberOfSuccesses();\n        final double n = getSampleSize();\n        return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));\n    }", "getSupportLowerBound": "\n    public int getSupportLowerBound() {\n        return FastMath.max(0,\n                            getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n    }", "getSupportUpperBound": "\n    public int getSupportUpperBound() {\n        return FastMath.min(getNumberOfSuccesses(), getSampleSize());\n    }", "isSupportConnected": "\n    public boolean isSupportConnected() {\n        return true;\n    }"}