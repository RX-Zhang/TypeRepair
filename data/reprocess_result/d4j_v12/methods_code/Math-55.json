{"getX": "\n  public double getX() {\n    return x;\n  }", "getY": "\n  public double getY() {\n    return y;\n  }", "getZ": "\n  public double getZ() {\n    return z;\n  }", "getNorm1": "\n  public double getNorm1() {\n    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n  }", "getNorm": "\n  public double getNorm() {\n    return FastMath.sqrt (x * x + y * y + z * z);\n  }", "getNormSq": "\n  public double getNormSq() {\n    return x * x + y * y + z * z;\n  }", "getNormInf": "\n  public double getNormInf() {\n    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n  }", "getAlpha": "\n  public double getAlpha() {\n    return FastMath.atan2(y, x);\n  }", "getDelta": "\n  public double getDelta() {\n    return FastMath.asin(z / getNorm());\n  }", "add": "\n  public Vector3D add(Vector3D v) {\n    return new Vector3D(x + v.x, y + v.y, z + v.z);\n  }", "subtract": "\n  public Vector3D subtract(Vector3D v) {\n    return new Vector3D(x - v.x, y - v.y, z - v.z);\n  }", "normalize": "\n  public Vector3D normalize() {\n    double s = getNorm();\n    if (s == 0) {\n      throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return scalarMultiply(1 / s);\n  }", "orthogonal": "\n  public Vector3D orthogonal() {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if ((x >= -threshold) && (x <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n      return new Vector3D(0, inverse * z, -inverse * y);\n    } else if ((y >= -threshold) && (y <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n      return new Vector3D(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new Vector3D(inverse * y, -inverse * x, 0);\n\n  }", "angle": "\n  public static double angle(Vector3D v1, Vector3D v2) {\n\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    double dot = dotProduct(v1, v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n      // the vectors are almost aligned, compute using the sine\n      Vector3D v3 = crossProduct(v1, v2);\n      if (dot >= 0) {\n        return FastMath.asin(v3.getNorm() / normProduct);\n      }\n      return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n\n  }", "negate": "\n  public Vector3D negate() {\n    return new Vector3D(-x, -y, -z);\n  }", "scalarMultiply": "\n  public Vector3D scalarMultiply(double a) {\n    return new Vector3D(a * x, a * y, a * z);\n  }", "isNaN": "\n  public boolean isNaN() {\n      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n  }", "isInfinite": "\n  public boolean isInfinite() {\n      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n  }", "equals": "\n  public boolean equals(Object other) {\n\n    if (this == other) {\n      return true;\n    }\n\n    if (other instanceof Vector3D) {\n      final Vector3D rhs = (Vector3D)other;\n      if (rhs.isNaN()) {\n          return this.isNaN();\n      }\n\n      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n    }\n    return false;\n  }", "hashCode": "\n  public int hashCode() {\n      if (isNaN()) {\n          return 8;\n      }\n      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n  }", "dotProduct": "\n  public static double dotProduct(Vector3D v1, Vector3D v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  }", "crossProduct": "\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n  }", "distance1": "\n  public static double distance1(Vector3D v1, Vector3D v2) {\n    final double dx = FastMath.abs(v2.x - v1.x);\n    final double dy = FastMath.abs(v2.y - v1.y);\n    final double dz = FastMath.abs(v2.z - v1.z);\n    return dx + dy + dz;\n  }", "distance": "\n  public static double distance(Vector3D v1, Vector3D v2) {\n    final double dx = v2.x - v1.x;\n    final double dy = v2.y - v1.y;\n    final double dz = v2.z - v1.z;\n    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n  }", "distanceInf": "\n  public static double distanceInf(Vector3D v1, Vector3D v2) {\n    final double dx = FastMath.abs(v2.x - v1.x);\n    final double dy = FastMath.abs(v2.y - v1.y);\n    final double dz = FastMath.abs(v2.z - v1.z);\n    return FastMath.max(FastMath.max(dx, dy), dz);\n  }", "distanceSq": "\n  public static double distanceSq(Vector3D v1, Vector3D v2) {\n    final double dx = v2.x - v1.x;\n    final double dy = v2.y - v1.y;\n    final double dz = v2.z - v1.z;\n    return dx * dx + dy * dy + dz * dz;\n  }", "toString": "\n  public String toString() {\n      return DEFAULT_FORMAT.format(this);\n  }"}