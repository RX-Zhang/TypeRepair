{"getAutoSort": "\n    public boolean getAutoSort() {\n        return this.autoSort;\n    }", "getAllowDuplicateXValues": "\n    public boolean getAllowDuplicateXValues() {\n        return this.allowDuplicateXValues;\n    }", "getItemCount": "\n    public int getItemCount() {\n        return this.data.size();\n    }", "getItems": "\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }", "getMaximumItemCount": "\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }", "setMaximumItemCount": "\n    public void setMaximumItemCount(int maximum) {\n        this.maximumItemCount = maximum;\n        boolean dataRemoved = false;\n        while (this.data.size() > maximum) {\n            this.data.remove(0);\n            dataRemoved = true;\n        }\n        if (dataRemoved) {\n            fireSeriesChanged();\n        }\n    }", "add": "\n    public void add(XYDataItem item) {\n        // argument checking delegated...\n        add(item, true);\n    }", "delete": "\n    public void delete(int start, int end) {\n        for (int i = start; i <= end; i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }", "remove": "\n    public XYDataItem remove(int index) {\n        XYDataItem result = (XYDataItem) this.data.remove(index);\n        fireSeriesChanged();\n        return result;\n    }", "clear": "\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }", "getDataItem": "\n    public XYDataItem getDataItem(int index) {\n        return (XYDataItem) this.data.get(index);\n    }", "getX": "\n    public Number getX(int index) {\n        return getDataItem(index).getX();\n    }", "getY": "\n    public Number getY(int index) {\n        return getDataItem(index).getY();\n    }", "updateByIndex": "\n    public void updateByIndex(int index, Number y) {\n        XYDataItem item = getDataItem(index);\n        item.setY(y);\n        fireSeriesChanged();\n    }", "update": "\n    public void update(Number x, Number y) {\n        int index = indexOf(x);\n        if (index < 0) {\n            throw new SeriesException(\"No observation for x = \" + x);\n        }\n        else {\n            XYDataItem item = getDataItem(index);\n            item.setY(y);\n            fireSeriesChanged();\n        }\n    }", "addOrUpdate": "\n    public XYDataItem addOrUpdate(double x, double y) {\n        return addOrUpdate(new Double(x), new Double(y));\n    }", "indexOf": "\n    public int indexOf(Number x) {\n        if (this.autoSort) {\n            return Collections.binarySearch(this.data, new XYDataItem(x, null));\n        }\n        else {\n            for (int i = 0; i < this.data.size(); i++) {\n                XYDataItem item = (XYDataItem) this.data.get(i);\n                if (item.getX().equals(x)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }", "toArray": "\n    public double[][] toArray() {\n        int itemCount = getItemCount();\n        double[][] result = new double[2][itemCount];\n        for (int i = 0; i < itemCount; i++) {\n            result[0][i] = this.getX(i).doubleValue();\n            Number y = getY(i);\n            if (y != null) {\n                result[1][i] = y.doubleValue();\n            }\n            else {\n                result[1][i] = Double.NaN;\n            }\n        }\n        return result;\n    }", "clone": "\n    public Object clone() throws CloneNotSupportedException {\n        XYSeries clone = (XYSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }", "createCopy": "\n    public XYSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        XYSeries copy = (XYSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                XYDataItem item = (XYDataItem) this.data.get(index);\n                XYDataItem clone = (XYDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Unable to add cloned data item.\");\n                }\n            }\n        }\n        return copy;\n\n    }", "equals": "\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYSeries)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        XYSeries that = (XYSeries) obj;\n        if (this.maximumItemCount != that.maximumItemCount) {\n            return false;\n        }\n        if (this.autoSort != that.autoSort) {\n            return false;\n        }\n        if (this.allowDuplicateXValues != that.allowDuplicateXValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return true;\n    }", "hashCode": "\n    public int hashCode() {\n        int result = super.hashCode();\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            XYDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            XYDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            XYDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (this.autoSort ? 1 : 0);\n        result = 29 * result + (this.allowDuplicateXValues ? 1 : 0);\n        return result;\n    }"}