{"getImpureBooleanValue": "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }", "getPureBooleanValue": "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }", "getStringValue": "\n  static String getStringValue(Node n) {\n    // TODO(user): regex literals as well.\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.STRING_KEY:\n        return n.getString();\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name)) {\n          return name;\n        }\n        break;\n\n      case Token.NUMBER:\n        return getStringValue(n.getDouble());\n\n      case Token.FALSE:\n        return \"false\";\n\n      case Token.TRUE:\n        return \"true\";\n\n      case Token.NULL:\n        return \"null\";\n\n      case Token.VOID:\n        return \"undefined\";\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        return arrayToString(n);\n\n      case Token.OBJECTLIT:\n        return \"[object Object]\";\n    }\n    return null;\n  }", "getArrayElementStringValue": "\n  static String getArrayElementStringValue(Node n) {\n    return (NodeUtil.isNullOrUndefined(n) || n.isEmpty())\n        ? \"\" : getStringValue(n);\n  }", "arrayToString": "\n  static String arrayToString(Node literal) {\n    Node first = literal.getFirstChild();\n    StringBuilder result = new StringBuilder();\n    int nextSlot = 0;\n    int nextSkipSlot = 0;\n    for (Node n = first; n != null; n = n.getNext()) {\n      String childValue = getArrayElementStringValue(n);\n      if (childValue == null) {\n        return null;\n      }\n      if (n != first) {\n        result.append(',');\n      }\n      result.append(childValue);\n\n      nextSlot++;\n    }\n    return result.toString();\n  }", "getNumberValue": "\n  static Double getNumberValue(Node n) {\n    switch (n.getType()) {\n      case Token.TRUE:\n        return 1.0;\n\n      case Token.FALSE:\n      case Token.NULL:\n        return 0.0;\n\n      case Token.NUMBER:\n        return n.getDouble();\n\n      case Token.VOID:\n        if (mayHaveSideEffects(n.getFirstChild())) {\n          return null;\n        } else {\n          return Double.NaN;\n        }\n\n      case Token.NAME:\n        // Check for known constants\n        String name = n.getString();\n        if (name.equals(\"undefined\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"NaN\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"Infinity\")) {\n          return Double.POSITIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NEG:\n        if (n.getChildCount() == 1 && n.getFirstChild().isName()\n            && n.getFirstChild().getString().equals(\"Infinity\")) {\n          return Double.NEGATIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.\n        }\n        break;\n\n      case Token.STRING:\n        return getStringNumberValue(n.getString());\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        String value = getStringValue(n);\n        return value != null ? getStringNumberValue(value) : null;\n    }\n\n    return null;\n  }", "getStringNumberValue": "\n  static Double getStringNumberValue(String rawJsString) {\n    if (rawJsString.contains(\"\\u000b\")) {\n      // vertical tab is not always whitespace\n      return null;\n    }\n\n    String s = trimJsWhiteSpace(rawJsString);\n    // return ScriptRuntime.toNumber(s);\n    if (s.length() == 0) {\n      return 0.0;\n    }\n\n    if (s.length() > 2\n        && s.charAt(0) == '0'\n        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n      // Attempt to convert hex numbers.\n      try {\n        return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n      } catch (NumberFormatException e) {\n        return Double.NaN;\n      }\n    }\n\n    if (s.length() > 3\n        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n        && s.charAt(1) == '0'\n        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n      // hex numbers with explicit signs vary between browsers.\n      return null;\n    }\n\n    // Firefox and IE treat the \"Infinity\" differently. Firefox is case\n    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n    if (s.equals(\"infinity\")\n        || s.equals(\"-infinity\")\n        || s.equals(\"+infinity\")) {\n      return null;\n    }\n\n    try {\n      return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n      return Double.NaN;\n    }\n  }", "trimJsWhiteSpace": "\n  static String trimJsWhiteSpace(String s) {\n    int start = 0;\n    int end = s.length();\n    while (end > 0\n        && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {\n      end--;\n    }\n    while (start < end\n        && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {\n      start++;\n    }\n    return s.substring(start, end);\n  }", "isStrWhiteSpaceChar": "\n  public static TernaryValue isStrWhiteSpaceChar(int c) {\n    switch (c) {\n      case '\\u000B': // <VT>\n        return TernaryValue.UNKNOWN;  // IE says \"no\", ECMAScript says \"yes\"\n      case ' ': // <SP>\n      case '\\n': // <LF>\n      case '\\r': // <CR>\n      case '\\t': // <TAB>\n      case '\\u00A0': // <NBSP>\n      case '\\u000C': // <FF>\n      case '\\u2028': // <LS>\n      case '\\u2029': // <PS>\n      case '\\uFEFF': // <BOM>\n        return TernaryValue.TRUE;\n      default:\n        return (Character.getType(c) == Character.SPACE_SEPARATOR)\n            ? TernaryValue.TRUE : TernaryValue.FALSE;\n    }\n  }", "getFunctionName": "\n  static String getFunctionName(Node n) {\n    Preconditions.checkState(n.isFunction());\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.NAME:\n        // var name = function() ...\n        // var name2 = function name1() ...\n        return parent.getQualifiedName();\n\n      case Token.ASSIGN:\n        // qualified.name = function() ...\n        // qualified.name2 = function name1() ...\n        return parent.getFirstChild().getQualifiedName();\n\n      default:\n        // function name() ...\n        String name = n.getFirstChild().getQualifiedName();\n        return name;\n    }\n  }", "getNearestFunctionName": "\n  public static String getNearestFunctionName(Node n) {\n    if (!n.isFunction()) {\n      return null;\n    }\n\n    String name = getFunctionName(n);\n    if (name != null) {\n      return name;\n    }\n\n    // Check for the form { 'x' : function() { } }\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.SETTER_DEF:\n      case Token.GETTER_DEF:\n      case Token.STRING_KEY:\n        // Return the name of the literal's key.\n        return parent.getString();\n      case Token.NUMBER:\n        return getStringValue(parent);\n    }\n\n    return null;\n  }", "isImmutableValue": "\n  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.NOT:\n        return isImmutableValue(n.getFirstChild());\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }", "isSymmetricOperation": "\n  static boolean isSymmetricOperation(Node n) {\n    switch (n.getType()) {\n      case Token.EQ: // equal\n      case Token.NE: // not equal\n      case Token.SHEQ: // exactly equal\n      case Token.SHNE: // exactly not equal\n      case Token.MUL: // multiply, unlike add it only works on numbers\n                      // or results NaN if any of the operators is not a number\n        return true;\n    }\n    return false;\n  }", "isRelationalOperation": "\n  static boolean isRelationalOperation(Node n) {\n    switch (n.getType()) {\n      case Token.GT: // equal\n      case Token.GE: // not equal\n      case Token.LT: // exactly equal\n      case Token.LE: // exactly not equal\n        return true;\n    }\n    return false;\n  }", "getInverseOperator": "\n  static int getInverseOperator(int type) {\n    switch (type) {\n      case Token.GT:\n        return Token.LT;\n      case Token.LT:\n        return Token.GT;\n      case Token.GE:\n        return Token.LE;\n      case Token.LE:\n        return Token.GE;\n    }\n    return Token.ERROR;\n  }", "isLiteralValue": "\n  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.OBJECTLIT:\n        // Return true only if all values are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }", "isValidDefineValue": "\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return isValidDefineValue(val.getFirstChild(), defines)\n            && isValidDefineValue(val.getLastChild(), defines);\n\n      // Unary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n      case Token.POS:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }", "isEmptyBlock": "\n  static boolean isEmptyBlock(Node block) {\n    if (!block.isBlock()) {\n      return false;\n    }\n\n    for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {\n      if (!n.isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }", "isSimpleOperator": "\n  static boolean isSimpleOperator(Node n) {\n    return isSimpleOperatorType(n.getType());\n  }", "isSimpleOperatorType": "\n  static boolean isSimpleOperatorType(int type) {\n    switch (type) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }", "newExpr": "\n  static Node newExpr(Node child) {\n    return IR.exprResult(child).srcref(child);\n  }", "mayEffectMutableState": "\n  static boolean mayEffectMutableState(Node n) {\n    return mayEffectMutableState(n, null);\n  }", "mayHaveSideEffects": "\n  static boolean mayHaveSideEffects(Node n) {\n    return mayHaveSideEffects(n, null);\n  }", "checkForStateChangeHelper": "\n  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    // Rather than id which ops may have side effects, id the ones\n    // that we know to be safe\n    switch (n.getType()) {\n      // other side-effect free statements and expressions\n      case Token.AND:\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n      case Token.HOOK:\n      case Token.IF:\n      case Token.IN:\n      case Token.PARAM_LIST:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.SWITCH:\n      case Token.TRY:\n      case Token.EMPTY:\n        break;\n\n      // Throws are by definition side effects\n      case Token.THROW:\n        return true;\n\n      case Token.OBJECTLIT:\n        if (checkForNewObjects) {\n          return true;\n        }\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (checkForStateChangeHelper(\n                  c.getFirstChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n        }\n        return false;\n\n      case Token.ARRAYLIT:\n      case Token.REGEXP:\n        if (checkForNewObjects) {\n          return true;\n        }\n        break;\n\n      case Token.VAR:    // empty var statement (no declaration)\n      case Token.NAME:   // variable by itself\n        if (n.getFirstChild() != null) {\n          return true;\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Function expressions don't have side-effects, but function\n        // declarations change the namespace. Either way, we don't need to\n        // check the children, since they aren't executed at declaration time.\n        return checkForNewObjects || !isFunctionExpression(n);\n\n      case Token.NEW:\n        if (checkForNewObjects) {\n          return true;\n        }\n\n        if (!constructorCallHasSideEffects(n)) {\n          // loop below will see if the constructor parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      case Token.CALL:\n        // calls to functions that have no side effects have the no\n        // side effect property set.\n        if (!functionCallHasSideEffects(n, compiler)) {\n          // loop below will see if the function parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      default:\n        if (isSimpleOperator(n)) {\n          break;\n        }\n\n        if (isAssignmentOp(n)) {\n          Node assignTarget = n.getFirstChild();\n          if (assignTarget.isName()) {\n            return true;\n          }\n\n          // Assignments will have side effects if\n          // a) The RHS has side effects, or\n          // b) The LHS has side effects, or\n          // c) A name on the LHS will exist beyond the life of this statement.\n          if (checkForStateChangeHelper(\n                  n.getFirstChild(), checkForNewObjects, compiler) ||\n              checkForStateChangeHelper(\n                  n.getLastChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n\n          if (isGet(assignTarget)) {\n            // If the object being assigned to is a local object, don't\n            // consider this a side-effect as it can't be referenced\n            // elsewhere.  Don't do this recursively as the property might\n            // be an alias of another object, unlike a literal below.\n            Node current = assignTarget.getFirstChild();\n            if (evaluatesToLocalValue(current)) {\n              return false;\n            }\n\n            // A literal value as defined by \"isLiteralValue\" is guaranteed\n            // not to be an alias, or any components which are aliases of\n            // other objects.\n            // If the root object is a literal don't consider this a\n            // side-effect.\n            while (isGet(current)) {\n              current = current.getFirstChild();\n            }\n\n            return !isLiteralValue(current, true);\n          } else {\n            // TODO(johnlenz): remove this code and make this an exception. This\n            // is here only for legacy reasons, the AST is not valid but\n            // preserve existing behavior.\n            return !isLiteralValue(assignTarget, true);\n          }\n        }\n\n        return true;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "constructorCallHasSideEffects": "\n  static boolean constructorCallHasSideEffects(Node callNode) {\n    return constructorCallHasSideEffects(callNode, null);\n  }", "functionCallHasSideEffects": "\n  static boolean functionCallHasSideEffects(Node callNode) {\n    return functionCallHasSideEffects(callNode, null);\n  }", "callHasLocalResult": "\n  static boolean callHasLocalResult(Node n) {\n    Preconditions.checkState(n.isCall());\n    return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;\n  }", "newHasLocalResult": "\n  static boolean newHasLocalResult(Node n) {\n    Preconditions.checkState(n.isNew());\n    return n.isOnlyModifiesThisCall();\n  }", "nodeTypeMayHaveSideEffects": "\n  static boolean nodeTypeMayHaveSideEffects(Node n) {\n    return nodeTypeMayHaveSideEffects(n, null);\n  }", "canBeSideEffected": "\n  static boolean canBeSideEffected(Node n) {\n    Set<String> emptySet = Collections.emptySet();\n    return canBeSideEffected(n, emptySet);\n  }", "precedence": "\n  static int precedence(int type) {\n    switch (type) {\n      case Token.COMMA:  return 0;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN: return 1;\n      case Token.HOOK:   return 2;  // ?: operator\n      case Token.OR:     return 3;\n      case Token.AND:    return 4;\n      case Token.BITOR:  return 5;\n      case Token.BITXOR: return 6;\n      case Token.BITAND: return 7;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:   return 8;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:     return 9;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:   return 10;\n      case Token.SUB:\n      case Token.ADD:    return 11;\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:    return 12;\n      case Token.INC:\n      case Token.DEC:\n      case Token.NEW:\n      case Token.DELPROP:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG:    return 13;\n\n      case Token.CALL:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      // Data values\n      case Token.ARRAYLIT:\n      case Token.EMPTY:  // TODO(johnlenz): remove this.\n      case Token.FALSE:\n      case Token.FUNCTION:\n      case Token.NAME:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.THIS:\n      case Token.TRUE:\n        return 15;\n\n      default: throw new Error(\"Unknown precedence for \" +\n                               Token.name(type) +\n                               \" (type \" + type + \")\");\n    }\n  }", "isUndefined": "\n  static boolean isUndefined(Node n) {\n    switch (n.getType()) {\n      case Token.VOID:\n        return true;\n      case Token.NAME:\n        return n.getString().equals(\"undefined\");\n    }\n    return false;\n  }", "isNullOrUndefined": "\n  static boolean isNullOrUndefined(Node n) {\n    return n.isNull() || isUndefined(n);\n  }", "allResultsMatch": "\n  static boolean allResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return allResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return allResultsMatch(n.getFirstChild(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n        return allResultsMatch(n.getFirstChild().getNext(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      default:\n        return p.apply(n);\n    }\n  }", "anyResultsMatch": "\n  static boolean anyResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return anyResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return anyResultsMatch(n.getFirstChild(), p)\n            || anyResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n        return anyResultsMatch(n.getFirstChild().getNext(), p)\n            || anyResultsMatch(n.getLastChild(), p);\n      default:\n        return p.apply(n);\n    }\n  }", "apply": "\n    public boolean apply(Node n) {\n      return isNumericResultHelper(n);\n    }", "isNumericResult": "\n  static boolean isNumericResult(Node n) {\n    return allResultsMatch(n, NUMBERIC_RESULT_PREDICATE);\n  }", "isNumericResultHelper": "\n  static boolean isNumericResultHelper(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n        return !mayBeString(n.getFirstChild())\n            && !mayBeString(n.getLastChild());\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n      case Token.INC:\n      case Token.DEC:\n      case Token.POS:\n      case Token.NEG:\n      case Token.NUMBER:\n        return true;\n      case Token.NAME:\n        String name = n.getString();\n        if (name.equals(\"NaN\")) {\n          return true;\n        }\n        if (name.equals(\"Infinity\")) {\n          return true;\n        }\n        return false;\n      default:\n        return false;\n    }\n  }", "isBooleanResult": "\n  static boolean isBooleanResult(Node n) {\n    return allResultsMatch(n, BOOLEAN_RESULT_PREDICATE);\n  }", "isBooleanResultHelper": "\n  static boolean isBooleanResultHelper(Node n) {\n    switch (n.getType()) {\n      // Primitives\n      case Token.TRUE:\n      case Token.FALSE:\n      // Comparisons\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      // Queries\n      case Token.IN:\n      case Token.INSTANCEOF:\n      // Inversion\n      case Token.NOT:\n      // delete operator returns a boolean.\n      case Token.DELPROP:\n        return true;\n      default:\n        return false;\n    }\n  }", "mayBeString": "\n  static boolean mayBeString(Node n) {\n    return mayBeString(n, true);\n  }", "mayBeStringHelper": "\n  static boolean mayBeStringHelper(Node n) {\n    return !isNumericResult(n) && !isBooleanResult(n)\n        && !isUndefined(n) && !n.isNull();\n  }", "isAssociative": "\n  static boolean isAssociative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }", "isCommutative": "\n  static boolean isCommutative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }", "isAssignmentOp": "\n  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }", "getOpFromAssignmentOp": "\n  static int getOpFromAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN_BITOR:\n        return Token.BITOR;\n      case Token.ASSIGN_BITXOR:\n        return Token.BITXOR;\n      case Token.ASSIGN_BITAND:\n        return Token.BITAND;\n      case Token.ASSIGN_LSH:\n        return Token.LSH;\n      case Token.ASSIGN_RSH:\n        return Token.RSH;\n      case Token.ASSIGN_URSH:\n        return Token.URSH;\n      case Token.ASSIGN_ADD:\n        return Token.ADD;\n      case Token.ASSIGN_SUB:\n        return Token.SUB;\n      case Token.ASSIGN_MUL:\n        return Token.MUL;\n      case Token.ASSIGN_DIV:\n        return Token.DIV;\n      case Token.ASSIGN_MOD:\n        return Token.MOD;\n    }\n    throw new IllegalArgumentException(\"Not an assignment op:\" + n);\n  }", "containsFunction": "\n  static boolean containsFunction(Node n) {\n    return containsType(n, Token.FUNCTION);\n  }", "referencesThis": "\n  static boolean referencesThis(Node n) {\n    Node start = (n.isFunction()) ? n.getLastChild() : n;\n    return containsType(start, Token.THIS, MATCH_NOT_FUNCTION);\n  }", "isGet": "\n  static boolean isGet(Node n) {\n    return n.isGetProp() || n.isGetElem();\n  }", "isVarDeclaration": "\n  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.isName() && n.getParent().isVar();\n  }", "getAssignedValue": "\n  static Node getAssignedValue(Node n) {\n    Preconditions.checkState(n.isName());\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      return n.getFirstChild();\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      return n.getNext();\n    } else {\n      return null;\n    }\n  }", "isExprAssign": "\n  static boolean isExprAssign(Node n) {\n    return n.isExprResult()\n        && n.getFirstChild().isAssign();\n  }", "isExprCall": "\n  static boolean isExprCall(Node n) {\n    return n.isExprResult()\n        && n.getFirstChild().isCall();\n  }", "isForIn": "\n  static boolean isForIn(Node n) {\n    return n.isFor()\n        && n.getChildCount() == 3;\n  }", "isLoopStructure": "\n  static boolean isLoopStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }", "getLoopCodeBlock": "\n  static Node getLoopCodeBlock(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.WHILE:\n        return n.getLastChild();\n      case Token.DO:\n        return n.getFirstChild();\n      default:\n        return null;\n    }\n  }", "isWithinLoop": "\n  static boolean isWithinLoop(Node n) {\n    for (Node parent : n.getAncestors()) {\n      if (NodeUtil.isLoopStructure(parent)) {\n        return true;\n      }\n\n      if (parent.isFunction()) {\n        break;\n      }\n    }\n    return false;\n  }", "isControlStructure": "\n  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        return false;\n    }\n  }", "isControlStructureCodeBlock": "\n  static boolean isControlStructureCodeBlock(Node parent, Node n) {\n    switch (parent.getType()) {\n      case Token.FOR:\n      case Token.WHILE:\n      case Token.LABEL:\n      case Token.WITH:\n        return parent.getLastChild() == n;\n      case Token.DO:\n        return parent.getFirstChild() == n;\n      case Token.IF:\n        return parent.getFirstChild() != n;\n      case Token.TRY:\n        return parent.getFirstChild() == n || parent.getLastChild() == n;\n      case Token.CATCH:\n        return parent.getLastChild() == n;\n      case Token.SWITCH:\n      case Token.CASE:\n        return parent.getFirstChild() != n;\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        Preconditions.checkState(isControlStructure(parent));\n        return false;\n    }\n  }", "getConditionExpression": "\n  static Node getConditionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.IF:\n      case Token.WHILE:\n        return n.getFirstChild();\n      case Token.DO:\n        return n.getLastChild();\n      case Token.FOR:\n        switch (n.getChildCount()) {\n          case 3:\n            return null;\n          case 4:\n            return n.getFirstChild().getNext();\n        }\n        throw new IllegalArgumentException(\"malformed 'for' statement \" + n);\n      case Token.CASE:\n        return null;\n    }\n    throw new IllegalArgumentException(n + \" does not have a condition.\");\n  }", "isStatementBlock": "\n  static boolean isStatementBlock(Node n) {\n    return n.isScript() || n.isBlock();\n  }", "isStatement": "\n  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }", "isStatementParent": "\n  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }", "isSwitchCase": "\n  static boolean isSwitchCase(Node n) {\n    return n.isCase() || n.isDefaultCase();\n  }", "isReferenceName": "\n  static boolean isReferenceName(Node n) {\n    return n.isName() && !n.getString().isEmpty();\n  }", "isTryFinallyNode": "\n  static boolean isTryFinallyNode(Node parent, Node child) {\n    return parent.isTry() && parent.getChildCount() == 3\n        && child == parent.getLastChild();\n  }", "isTryCatchNodeContainer": "\n  static boolean isTryCatchNodeContainer(Node n) {\n    Node parent = n.getParent();\n    return parent.isTry()\n        && parent.getFirstChild().getNext() == n;\n  }", "removeChild": "\n  static void removeChild(Node parent, Node node) {\n    if (isTryFinallyNode(parent, node)) {\n      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {\n        // A finally can only be removed if there is a catch.\n        parent.removeChild(node);\n      } else {\n        // Otherwise, only its children can be removed.\n        node.detachChildren();\n      }\n    } else if (node.isCatch()) {\n      // The CATCH can can only be removed if there is a finally clause.\n      Node tryNode = node.getParent().getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachFromParent();\n    } else if (isTryCatchNodeContainer(node)) {\n      // The container node itself can't be removed, but the contained CATCH\n      // can if there is a 'finally' clause\n      Node tryNode = node.getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachChildren();\n    } else if (node.isBlock()) {\n      // Simply empty the block.  This maintains source location and\n      // \"synthetic\"-ness.\n      node.detachChildren();\n    } else if (isStatementBlock(parent)\n        || isSwitchCase(node)) {\n      // A statement in a block can simply be removed.\n      parent.removeChild(node);\n    } else if (parent.isVar()) {\n      if (parent.hasMoreThanOneChild()) {\n        parent.removeChild(node);\n      } else {\n        // Remove the node from the parent, so it can be reused.\n        parent.removeChild(node);\n        // This would leave an empty VAR, remove the VAR itself.\n        removeChild(parent.getParent(), parent);\n      }\n    } else if (parent.isLabel()\n        && node == parent.getLastChild()) {\n      // Remove the node from the parent, so it can be reused.\n      parent.removeChild(node);\n      // A LABEL without children can not be referred to, remove it.\n      removeChild(parent.getParent(), parent);\n    } else if (parent.isFor()\n        && parent.getChildCount() == 4) {\n      // Only Token.FOR can have an Token.EMPTY other control structure\n      // need something for the condition. Others need to be replaced\n      // or the structure removed.\n      parent.replaceChild(node, IR.empty());\n    } else {\n      throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n          node.toString() + \" of \" + parent.toString());\n    }\n  }", "maybeAddFinally": "\n  static void maybeAddFinally(Node tryNode) {\n    Preconditions.checkState(tryNode.isTry());\n    if (!NodeUtil.hasFinally(tryNode)) {\n      tryNode.addChildrenToBack(IR.block().srcref(tryNode));\n    }\n  }", "tryMergeBlock": "\n  static boolean tryMergeBlock(Node block) {\n    Preconditions.checkState(block.isBlock());\n    Node parent = block.getParent();\n    // Try to remove the block if its parent is a block/script or if its\n    // parent is label and it has exactly one child.\n    if (isStatementBlock(parent)) {\n      Node previous = block;\n      while (block.hasChildren()) {\n        Node child = block.removeFirstChild();\n        parent.addChildAfter(child, previous);\n        previous = child;\n      }\n      parent.removeChild(block);\n      return true;\n    } else {\n      return false;\n    }\n  }", "isCallOrNew": "\n  static boolean isCallOrNew(Node node) {\n    return node.isCall() || node.isNew();\n  }", "getFunctionBody": "\n  static Node getFunctionBody(Node fn) {\n    Preconditions.checkArgument(fn.isFunction());\n    return fn.getLastChild();\n  }", "isFunctionDeclaration": "\n  static boolean isFunctionDeclaration(Node n) {\n    return n.isFunction() && isStatement(n);\n  }", "isHoistedFunctionDeclaration": "\n  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().isScript()\n            || n.getParent().getParent().isFunction());\n  }", "isFunctionExpression": "\n  static boolean isFunctionExpression(Node n) {\n    return n.isFunction() && !isStatement(n);\n  }", "isBleedingFunctionName": "\n  static boolean isBleedingFunctionName(Node n) {\n    return n.isName() && !n.getString().isEmpty() &&\n        isFunctionExpression(n.getParent());\n  }", "isEmptyFunctionExpression": "\n  static boolean isEmptyFunctionExpression(Node node) {\n    return isFunctionExpression(node) && isEmptyBlock(node.getLastChild());\n  }", "isVarArgsFunction": "\n  static boolean isVarArgsFunction(Node function) {\n    // TODO(johnlenz): rename this function\n    Preconditions.checkArgument(function.isFunction());\n    return isNameReferenced(\n        function.getLastChild(),\n        \"arguments\",\n        MATCH_NOT_FUNCTION);\n  }", "isObjectCallMethod": "\n  static boolean isObjectCallMethod(Node callNode, String methodName) {\n    if (callNode.isCall()) {\n      Node functionIndentifyingExpression = callNode.getFirstChild();\n      if (isGet(functionIndentifyingExpression)) {\n        Node last = functionIndentifyingExpression.getLastChild();\n        if (last != null && last.isString()) {\n          String propName = last.getString();\n          return (propName.equals(methodName));\n        }\n      }\n    }\n    return false;\n  }", "isFunctionObjectCall": "\n  static boolean isFunctionObjectCall(Node callNode) {\n    return isObjectCallMethod(callNode, \"call\");\n  }", "isFunctionObjectApply": "\n  static boolean isFunctionObjectApply(Node callNode) {\n    return isObjectCallMethod(callNode, \"apply\");\n  }", "isVarOrSimpleAssignLhs": "\n  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n    return (parent.isAssign() && parent.getFirstChild() == n) ||\n           parent.isVar();\n  }", "isLValue": "\n  public static boolean isLValue(Node n) {\n    Preconditions.checkArgument(n.isName() || n.isGetProp() ||\n        n.isGetElem());\n    Node parent = n.getParent();\n    if (parent == null) {\n      return false;\n    }\n    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n)\n        || parent.isVar()\n        || (parent.isFunction() && parent.getFirstChild() == n)\n        || parent.isDec()\n        || parent.isInc()\n        || parent.isParamList()\n        || parent.isCatch();\n  }", "isObjectLitKey": "\n  static boolean isObjectLitKey(Node node, Node parent) {\n    switch (node.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }", "getObjectLitKeyName": "\n  static String getObjectLitKeyName(Node key) {\n    switch (key.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return key.getString();\n    }\n    throw new IllegalStateException(\"Unexpected node type: \" + key);\n  }", "getObjectLitKeyTypeFromValueType": "\n  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {\n    if (valueType != null) {\n      switch (key.getType()) {\n        case Token.GETTER_DEF:\n          // GET must always return a function type.\n          if (valueType.isFunctionType()) {\n            FunctionType fntype = valueType.toMaybeFunctionType();\n            valueType = fntype.getReturnType();\n          } else {\n            return null;\n          }\n          break;\n        case Token.SETTER_DEF:\n          if (valueType.isFunctionType()) {\n            // SET must always return a function type.\n            FunctionType fntype = valueType.toMaybeFunctionType();\n            Node param = fntype.getParametersNode().getFirstChild();\n            // SET function must always have one parameter.\n            valueType = param.getJSType();\n          } else {\n            return null;\n          }\n          break;\n      }\n    }\n    return valueType;\n  }", "isGetOrSetKey": "\n  static boolean isGetOrSetKey(Node node) {\n    switch (node.getType()) {\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }", "opToStr": "\n  static String opToStr(int operator) {\n    switch (operator) {\n      case Token.BITOR: return \"|\";\n      case Token.OR: return \"||\";\n      case Token.BITXOR: return \"^\";\n      case Token.AND: return \"&&\";\n      case Token.BITAND: return \"&\";\n      case Token.SHEQ: return \"===\";\n      case Token.EQ: return \"==\";\n      case Token.NOT: return \"!\";\n      case Token.NE: return \"!=\";\n      case Token.SHNE: return \"!==\";\n      case Token.LSH: return \"<<\";\n      case Token.IN: return \"in\";\n      case Token.LE: return \"<=\";\n      case Token.LT: return \"<\";\n      case Token.URSH: return \">>>\";\n      case Token.RSH: return \">>\";\n      case Token.GE: return \">=\";\n      case Token.GT: return \">\";\n      case Token.MUL: return \"*\";\n      case Token.DIV: return \"/\";\n      case Token.MOD: return \"%\";\n      case Token.BITNOT: return \"~\";\n      case Token.ADD: return \"+\";\n      case Token.SUB: return \"-\";\n      case Token.POS: return \"+\";\n      case Token.NEG: return \"-\";\n      case Token.ASSIGN: return \"=\";\n      case Token.ASSIGN_BITOR: return \"|=\";\n      case Token.ASSIGN_BITXOR: return \"^=\";\n      case Token.ASSIGN_BITAND: return \"&=\";\n      case Token.ASSIGN_LSH: return \"<<=\";\n      case Token.ASSIGN_RSH: return \">>=\";\n      case Token.ASSIGN_URSH: return \">>>=\";\n      case Token.ASSIGN_ADD: return \"+=\";\n      case Token.ASSIGN_SUB: return \"-=\";\n      case Token.ASSIGN_MUL: return \"*=\";\n      case Token.ASSIGN_DIV: return \"/=\";\n      case Token.ASSIGN_MOD: return \"%=\";\n      case Token.VOID: return \"void\";\n      case Token.TYPEOF: return \"typeof\";\n      case Token.INSTANCEOF: return \"instanceof\";\n      default: return null;\n    }\n  }", "opToStrNoFail": "\n  static String opToStrNoFail(int operator) {\n    String res = opToStr(operator);\n    if (res == null) {\n      throw new Error(\"Unknown op \" + operator + \": \" +\n                      Token.name(operator));\n    }\n    return res;\n  }", "containsType": "\n  static boolean containsType(Node node,\n                              int type,\n                              Predicate<Node> traverseChildrenPred) {\n    return has(node, new MatchNodeType(type), traverseChildrenPred);\n  }", "redeclareVarsInsideBranch": "\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n              .srcref(nameNode))\n          .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }", "copyNameAnnotations": "\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }", "getAddingRoot": "\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null != (ancestor = ancestor.getParent())) {\n      int type = ancestor.getType();\n      if (type == Token.SCRIPT) {\n        addingRoot = ancestor;\n        break;\n      } else if (type == Token.FUNCTION) {\n        addingRoot = ancestor.getLastChild();\n        break;\n      }\n    }\n\n    // make sure that the adding root looks ok\n    Preconditions.checkState(addingRoot.isBlock() ||\n        addingRoot.isScript());\n    Preconditions.checkState(addingRoot.getFirstChild() == null ||\n        !addingRoot.getFirstChild().isScript());\n    return addingRoot;\n  }", "newQualifiedNameNode": "\n  public static Node newQualifiedNameNode(\n      CodingConvention convention, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(convention, name);\n    }\n    Node node = newName(convention, name.substring(0, endPos));\n    int startPos;\n    do {\n      startPos = endPos + 1;\n      endPos = name.indexOf('.', startPos);\n      String part = (endPos == -1\n                     ? name.substring(startPos)\n                     : name.substring(startPos, endPos));\n      Node propNode = IR.string(part);\n      if (convention.isConstantKey(part)) {\n        propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n      node = IR.getprop(node, propNode);\n    } while (endPos != -1);\n\n    return node;\n  }", "getRootOfQualifiedName": "\n  static Node getRootOfQualifiedName(Node qName) {\n    for (Node current = qName; true;\n         current = current.getFirstChild()) {\n      if (current.isName() || current.isThis()) {\n        return current;\n      }\n      Preconditions.checkState(current.isGetProp());\n    }\n  }", "setDebugInformation": "\n  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n    node.copyInformationFromForTree(basisNode);\n    node.putProp(Node.ORIGINALNAME_PROP, originalName);\n  }", "newName": "\n  private static Node newName(\n      CodingConvention convention, String name) {\n    Node nameNode = IR.name(name);\n    if (convention.isConstant(name)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    return nameNode;\n  }", "isLatin": "\n  static boolean isLatin(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }", "isValidSimpleName": "\n  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }", "isValidQualifiedName": "\n  public static boolean isValidQualifiedName(String name) {\n    if (name.endsWith(\".\") || name.startsWith(\".\")) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }", "isValidPropertyName": "\n  static boolean isValidPropertyName(String name) {\n    return isValidSimpleName(name);\n  }", "visit": "\n    public void visit(Node n) {\n      if (n.isName()) {\n        Node parent = n.getParent();\n        if (parent != null && parent.isVar()) {\n          String name = n.getString();\n          if (!vars.containsKey(name)) {\n            vars.put(name, n);\n          }\n        }\n      }\n    }", "getVarsDeclaredInBranch": "\n  static Collection<Node> getVarsDeclaredInBranch(Node root) {\n    VarCollector collector = new VarCollector();\n    visitPreOrder(\n        root,\n        collector,\n        MATCH_NOT_FUNCTION);\n    return collector.vars.values();\n  }", "isPrototypePropertyDeclaration": "\n  static boolean isPrototypePropertyDeclaration(Node n) {\n    if (!isExprAssign(n)) {\n      return false;\n    }\n    return isPrototypeProperty(n.getFirstChild().getFirstChild());\n  }", "isPrototypeProperty": "\n  static boolean isPrototypeProperty(Node n) {\n    String lhsString = n.getQualifiedName();\n    if (lhsString == null) {\n      return false;\n    }\n    int prototypeIdx = lhsString.indexOf(\".prototype.\");\n    return prototypeIdx != -1;\n  }", "getPrototypeClassName": "\n  static Node getPrototypeClassName(Node qName) {\n    Node cur = qName;\n    while (cur.isGetProp()) {\n      if (cur.getLastChild().getString().equals(\"prototype\")) {\n        return cur.getFirstChild();\n      } else {\n        cur = cur.getFirstChild();\n      }\n    }\n    return null;\n  }", "getPrototypePropertyName": "\n  static String getPrototypePropertyName(Node qName) {\n    String qNameStr = qName.getQualifiedName();\n    int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n    int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n    return qNameStr.substring(memberIndex);\n  }", "newUndefinedNode": "\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode != null) {\n        node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }", "newVarNode": "\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value != null) {\n      Preconditions.checkState(value.getNext() == null);\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }", "getNodeTypeReferenceCount": "\n  static int getNodeTypeReferenceCount(\n      Node node, int type, Predicate<Node> traverseChildrenPred) {\n    return getCount(node, new MatchNodeType(type), traverseChildrenPred);\n  }", "isNameReferenced": "\n  static boolean isNameReferenced(Node node,\n                                  String name,\n                                  Predicate<Node> traverseChildrenPred) {\n    return has(node, new MatchNameNode(name), traverseChildrenPred);\n  }", "getNameReferenceCount": "\n  static int getNameReferenceCount(Node node, String name) {\n    return getCount(\n        node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());\n  }", "has": "\n  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "getCount": "\n  static int getCount(\n      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {\n    int total = 0;\n\n    if (pred.apply(n)) {\n      total++;\n    }\n\n    if (traverseChildrenPred.apply(n)) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        total += getCount(c, pred, traverseChildrenPred);\n      }\n    }\n\n    return total;\n  }", "visitPreOrder": "\n  static void visitPreOrder(Node node,\n                     Visitor visitor,\n                     Predicate<Node> traverseChildrenPred) {\n    visitor.visit(node);\n\n    if (traverseChildrenPred.apply(node)) {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        visitPreOrder(c, visitor, traverseChildrenPred);\n      }\n    }\n  }", "visitPostOrder": "\n  static void visitPostOrder(Node node,\n                     Visitor visitor,\n                     Predicate<Node> traverseChildrenPred) {\n    if (traverseChildrenPred.apply(node)) {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        visitPostOrder(c, visitor, traverseChildrenPred);\n      }\n    }\n\n    visitor.visit(node);\n  }", "hasFinally": "\n  static boolean hasFinally(Node n) {\n    Preconditions.checkArgument(n.isTry());\n    return n.getChildCount() == 3;\n  }", "getCatchBlock": "\n  static Node getCatchBlock(Node n) {\n    Preconditions.checkArgument(n.isTry());\n    return n.getFirstChild().getNext();\n  }", "hasCatchHandler": "\n  static boolean hasCatchHandler(Node n) {\n    Preconditions.checkArgument(n.isBlock());\n    return n.hasChildren() && n.getFirstChild().isCatch();\n  }", "getFunctionParameters": "\n  public static Node getFunctionParameters(Node fnNode) {\n    // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n    Preconditions.checkArgument(fnNode.isFunction());\n    return fnNode.getFirstChild().getNext();\n  }", "isConstantName": "\n  static boolean isConstantName(Node node) {\n    return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n  }", "isConstantByConvention": "\n  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    String name = node.getString();\n    if (parent.isGetProp() &&\n        node == parent.getLastChild()) {\n      return convention.isConstantKey(name);\n    } else if (isObjectLitKey(node, parent)) {\n      return convention.isConstantKey(name);\n    } else {\n      return convention.isConstant(name);\n    }\n  }", "getFunctionJSDocInfo": "\n  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n    Preconditions.checkState(n.isFunction());\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.isAssign()) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.isName()) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }", "getSourceName": "\n  public static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getSourceFileName();\n      n = n.getParent();\n    }\n    return sourceName;\n  }", "getSourceFile": "\n  public static StaticSourceFile getSourceFile(Node n) {\n    StaticSourceFile sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getStaticSourceFile();\n      n = n.getParent();\n    }\n    return sourceName;\n  }", "getInputId": "\n  public static InputId getInputId(Node n) {\n    while (n != null && !n.isScript()) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.isScript()) ? n.getInputId() : null;\n  }", "newCallNode": "\n  static Node newCallNode(Node callTarget, Node... parameters) {\n    boolean isFreeCall = !isGet(callTarget);\n    Node call = IR.call(callTarget);\n    call.putBooleanProp(Node.FREE_CALL, isFreeCall);\n    for (Node parameter : parameters) {\n      call.addChildToBack(parameter);\n    }\n    return call;\n  }", "evaluatesToLocalValue": "\n  static boolean evaluatesToLocalValue(Node value) {\n    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());\n  }", "getNthSibling": "\n  private static Node getNthSibling(Node first, int index) {\n    Node sibling = first;\n    while (index != 0 && sibling != null) {\n      sibling = sibling.getNext();\n      index--;\n    }\n    return sibling;\n  }", "getArgumentForFunction": "\n  static Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n  }", "getArgumentForCallOrNew": "\n  static Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n      call.getFirstChild().getNext(), index);\n  }", "isToStringMethodCall": "\n  private static boolean isToStringMethodCall(Node call) {\n    Node getNode = call.getFirstChild();\n    if (isGet(getNode)) {\n      Node propNode = getNode.getLastChild();\n      return propNode.isString() && \"toString\".equals(propNode.getString());\n    }\n    return false;\n  }", "getBestJSDocInfo": "\n  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      if (parent == null) {\n        return null;\n      }\n\n      if (parent.isName()) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isAssign()) {\n        return parent.getJSDocInfo();\n      } else if (isObjectLitKey(parent, parent.getParent())) {\n        return parent.getJSDocInfo();\n      } else if (parent.isFunction()) {\n        return parent.getJSDocInfo();\n      } else if (parent.isVar() && parent.hasOneChild()) {\n        return parent.getJSDocInfo();\n      } else if ((parent.isHook() && parent.getFirstChild() != n) ||\n                 parent.isOr() ||\n                 parent.isAnd() ||\n                 (parent.isComma() && parent.getFirstChild() != n)) {\n        return getBestJSDocInfo(parent);\n      }\n    }\n    return info;\n  }", "getBestLValue": "\n  static Node getBestLValue(Node n) {\n    Node parent = n.getParent();\n    boolean isFunctionDeclaration = isFunctionDeclaration(n);\n    if (isFunctionDeclaration) {\n      return n.getFirstChild();\n    } else if (parent.isName()) {\n      return parent;\n    } else if (parent.isAssign()) {\n      return parent.getFirstChild();\n    } else if (isObjectLitKey(parent, parent.getParent())) {\n      return parent;\n    } else if (\n        (parent.isHook() && parent.getFirstChild() != n) ||\n        parent.isOr() ||\n        parent.isAnd() ||\n        (parent.isComma() && parent.getFirstChild() != n)) {\n      return getBestLValue(parent);\n    }\n    return null;\n  }", "getRValueOfLValue": "\n  static Node getRValueOfLValue(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.ASSIGN:\n        return n.getNext();\n      case Token.VAR:\n        return n.getFirstChild();\n      case Token.FUNCTION:\n        return parent;\n    }\n    return null;\n  }", "getBestLValueOwner": "\n  static Node getBestLValueOwner(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      return getBestLValue(lValue.getParent());\n    } else if (isGet(lValue)) {\n      return lValue.getFirstChild();\n    }\n\n    return null;\n  }", "getBestLValueName": "\n  static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }", "isExpressionResultUsed": "\n  static boolean isExpressionResultUsed(Node expr) {\n    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n    Node parent = expr.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n        return false;\n      case Token.HOOK:\n      case Token.AND:\n      case Token.OR:\n        return (expr == parent.getFirstChild())\n            ? true : isExpressionResultUsed(parent);\n      case Token.COMMA:\n        Node gramps = parent.getParent();\n        if (gramps.isCall() &&\n            parent == gramps.getFirstChild()) {\n          // Semantically, a direct call to eval is different from an indirect\n          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n          // expression to a comma to be a no-op if it's used to indirect\n          // an eval. This we pretend that this is \"used\".\n          if (expr == parent.getFirstChild() &&\n              parent.getChildCount() == 2 &&\n              expr.getNext().isName() &&\n              \"eval\".equals(expr.getNext().getString())) {\n            return true;\n          }\n        }\n\n        return (expr == parent.getFirstChild())\n            ? false : isExpressionResultUsed(parent);\n      case Token.FOR:\n        if (!NodeUtil.isForIn(parent)) {\n          // Only an expression whose result is in the condition part of the\n          // expression is used.\n          return (parent.getChildAtIndex(1) == expr);\n        }\n        break;\n    }\n    return true;\n  }", "isExecutedExactlyOnce": "\n  static boolean isExecutedExactlyOnce(Node n) {\n    inspect: do {\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.IF:\n        case Token.HOOK:\n        case Token.AND:\n        case Token.OR:\n          if (parent.getFirstChild() != n) {\n            return false;\n          }\n          // other ancestors may be conditional\n          continue inspect;\n        case Token.FOR:\n          if (NodeUtil.isForIn(parent)) {\n            if (parent.getChildAtIndex(1) != n) {\n              return false;\n            }\n          } else {\n            if (parent.getFirstChild() != n) {\n              return false;\n            }\n          }\n          // other ancestors may be conditional\n          continue inspect;\n        case Token.WHILE:\n        case Token.DO:\n          return false;\n        case Token.TRY:\n          // Consider all code under a try/catch to be conditionally executed.\n          if (!hasFinally(parent) || parent.getLastChild() != n) {\n            return false;\n          }\n          continue inspect;\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n          return false;\n        case Token.SCRIPT:\n        case Token.FUNCTION:\n          // Done, we've reached the scope root.\n          break inspect;\n      }\n    } while ((n = n.getParent()) != null);\n    return true;\n  }", "booleanNode": "\n  static Node booleanNode(boolean value) {\n    return value ? IR.trueNode() : IR.falseNode();\n  }", "numberNode": "\n  static Node numberNode(double value, Node srcref) {\n    Node result;\n    if (Double.isNaN(value)) {\n      result = IR.name(\"NaN\");\n    } else if (value == Double.POSITIVE_INFINITY) {\n      result = IR.name(\"Infinity\");\n    } else if (value == Double.NEGATIVE_INFINITY) {\n      result = IR.neg(IR.name(\"Infinity\"));\n    } else {\n      result = IR.number(value);\n    }\n    if (srcref != null) {\n      result.srcrefTree(srcref);\n    }\n    return result;\n  }"}