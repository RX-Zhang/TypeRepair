{"process": "\n  public void process(Node externs, Node root) {\n    Preconditions.checkNotNull(externs);\n    Preconditions.checkNotNull(root);\n    NodeTraversal.traverse(compiler, root, this);\n  }", "enterScope": "\n  public void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    // Global scope _SHOULD_ work, however, liveness won't finish without\n    // -Xmx1024 in closure. We might have to look at coding conventions for\n    // exported variables as well.\n    if (scope.isGlobal()) {\n      return;\n    }\n\n    // We are not going to do any dead assignment elimination in when there is\n    // at least one inner function because in most browsers, when there is a\n    // closure, ALL the variables are saved (escaped).\n    Node fnBlock = t.getScopeRoot().getLastChild();\n    if (NodeUtil.containsFunction(fnBlock)) {\n      return;\n    }\n\n    // We don't do any dead assignment elimination if there are no assigns\n    // to eliminate. :)\n    if (!NodeUtil.has(fnBlock, matchRemovableAssigns,\n            Predicates.<Node>alwaysTrue())) {\n      return;\n    }\n\n    // Computes liveness information first.\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    tryRemoveDeadAssignments(t, cfg);\n  }", "exitScope": "\n  public void exitScope(NodeTraversal t) {\n  }", "visit": "\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }", "tryRemoveDeadAssignments": "\n  private void tryRemoveDeadAssignments(NodeTraversal t,\n      ControlFlowGraph<Node> cfg) {\n    Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();\n\n    for (DiGraphNode<Node, Branch> cfgNode : nodes) {\n      FlowState<LiveVariableLattice> state =\n          cfgNode.getAnnotation();\n      Node n = cfgNode.getValue();\n      if (n == null) {\n        continue;\n      }\n      switch (n.getType()) {\n        case Token.IF:\n        case Token.WHILE:\n        case Token.DO:\n          tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state);\n          continue;\n        case Token.FOR:\n          if (!NodeUtil.isForIn(n)) {\n            tryRemoveAssignment(\n                t, NodeUtil.getConditionExpression(n), state);\n          }\n          continue;\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            tryRemoveAssignment(t, n.getFirstChild(), state);\n          }\n          continue;\n        // TODO(user): case Token.VAR: Remove var a=1;a=2;.....\n      }\n\n      tryRemoveAssignment(t, n, state);\n    }\n  }", "tryRemoveAssignment": "\n  private void tryRemoveAssignment(NodeTraversal t, Node n,\n      FlowState<LiveVariableLattice> state) {\n    tryRemoveAssignment(t, n, n, state);\n  }", "isVariableStillLiveWithinExpression": "\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      for(Node sibling = n.getNext(); sibling != null;\n          sibling = sibling.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n          VariableLiveness state = isVariableReadBeforeKill(sibling, variable);\n\n          // If we see a READ or KILL there is no need to continue.\n          if (state == VariableLiveness.READ) {\n            return true;\n          } else if (state == VariableLiveness.KILL) {\n            return false;\n          }\n        }\n      }\n      n = n.getParent();\n    }\n    return false;\n  }", "isVariableReadBeforeKill": "\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Expressions are evaluated left-right, depth first.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }"}