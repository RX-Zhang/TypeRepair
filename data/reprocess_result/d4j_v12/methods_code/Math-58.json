{"fit": "\n    public double[] fit(double[] initialGuess) {\n        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n\n                public double value(double x, double[] p) {\n                    double v = Double.POSITIVE_INFINITY;\n                    try {\n                        v = g.value(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        // Do nothing.\n                    }\n                    return v;\n                }\n\n                public double[] gradient(double x, double[] p) {\n                    double[] v = { Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY };\n                    try {\n                        v = g.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        // Do nothing.\n                    }\n                    return v;\n                }\n            };\n\n        return fit(f, initialGuess);\n    }", "guess": "\n        public double[] guess() {\n            if (parameters == null) {\n                parameters = basicGuess(observations);\n            }\n            return parameters.clone();\n        }", "basicGuess": "\n        private double[] basicGuess(WeightedObservedPoint[] points) {\n            Arrays.sort(points, createWeightedObservedPointComparator());\n            double[] params = new double[3];\n\n            int maxYIdx = findMaxY(points);\n            params[0] = points[maxYIdx].getY();\n            params[1] = points[maxYIdx].getX();\n\n            double fwhmApprox;\n            try {\n                double halfY = params[0] + ((params[1] - params[0]) / 2.0);\n                double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n                double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\n                fwhmApprox = fwhmX2 - fwhmX1;\n            } catch (OutOfRangeException e) {\n                fwhmApprox = points[points.length - 1].getX() - points[0].getX();\n            }\n            params[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\n\n            return params;\n        }", "findMaxY": "\n        private int findMaxY(WeightedObservedPoint[] points) {\n            int maxYIdx = 0;\n            for (int i = 1; i < points.length; i++) {\n                if (points[i].getY() > points[maxYIdx].getY()) {\n                    maxYIdx = i;\n                }\n            }\n            return maxYIdx;\n        }", "interpolateXAtY": "\n        private double interpolateXAtY(WeightedObservedPoint[] points,\n                                       int startIdx, int idxStep, double y)\n            throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\n            WeightedObservedPoint pointA = twoPoints[0];\n            WeightedObservedPoint pointB = twoPoints[1];\n            if (pointA.getY() == y) {\n                return pointA.getX();\n            }\n            if (pointB.getY() == y) {\n                return pointB.getX();\n            }\n            return pointA.getX() +\n                   (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) /\n                    (pointB.getY() - pointA.getY()));\n        }", "getInterpolationPointsForY": "\n        private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n                                                                   int startIdx, int idxStep, double y)\n            throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            for (int i = startIdx;\n                 (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\n                 i += idxStep) {\n                if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\n                    return (idxStep < 0) ?\n                           new WeightedObservedPoint[] { points[i + idxStep], points[i] } :\n                           new WeightedObservedPoint[] { points[i], points[i + idxStep] };\n                }\n            }\n\n            double minY = Double.POSITIVE_INFINITY;\n            double maxY = Double.NEGATIVE_INFINITY;\n            for (final WeightedObservedPoint point : points) {\n                minY = Math.min(minY, point.getY());\n                maxY = Math.max(maxY, point.getY());\n            }\n            throw new OutOfRangeException(y, minY, maxY);\n        }", "isBetween": "\n        private boolean isBetween(double value, double boundary1, double boundary2) {\n            return (value >= boundary1 && value <= boundary2) ||\n                   (value >= boundary2 && value <= boundary1);\n        }", "createWeightedObservedPointComparator": "\n        private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n            return new Comparator<WeightedObservedPoint>() {\n                public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\n                    if (p1 == null && p2 == null) {\n                        return 0;\n                    }\n                    if (p1 == null) {\n                        return -1;\n                    }\n                    if (p2 == null) {\n                        return 1;\n                    }\n                    if (p1.getX() < p2.getX()) {\n                        return -1;\n                    }\n                    if (p1.getX() > p2.getX()) {\n                        return 1;\n                    }\n                    if (p1.getY() < p2.getY()) {\n                        return -1;\n                    }\n                    if (p1.getY() > p2.getY()) {\n                        return 1;\n                    }\n                    if (p1.getWeight() < p2.getWeight()) {\n                        return -1;\n                    }\n                    if (p1.getWeight() > p2.getWeight()) {\n                        return 1;\n                    }\n                    return 0;\n                }\n            };\n        }"}