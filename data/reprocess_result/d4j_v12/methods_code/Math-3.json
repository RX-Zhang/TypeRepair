{"scale": "\n    public static double[] scale(double val, final double[] arr) {\n        double[] newArr = new double[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            newArr[i] = arr[i] * val;\n        }\n        return newArr;\n    }", "scaleInPlace": "\n    public static void scaleInPlace(double val, final double[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] *= val;\n        }\n    }", "ebeAdd": "\n    public static double[] ebeAdd(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] += b[i];\n        }\n        return result;\n    }", "ebeSubtract": "\n    public static double[] ebeSubtract(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] -= b[i];\n        }\n        return result;\n    }", "ebeMultiply": "\n    public static double[] ebeMultiply(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] *= b[i];\n        }\n        return result;\n    }", "ebeDivide": "\n    public static double[] ebeDivide(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] /= b[i];\n        }\n        return result;\n    }", "distance1": "\n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }", "distance": "\n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }", "distanceInf": "\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }", "isMonotonic": "\n    public static  <T extends Comparable<? super T>> boolean isMonotonic(T[] val,\n                                      OrderDirection dir,\n                                      boolean strict) {\n        T previous = val[0];\n        final int max = val.length;\n        for (int i = 1; i < max; i++) {\n            final int comp;\n            switch (dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                       return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous = val[i];\n        }\n        return true;\n    }", "checkOrder": "\n    public static boolean checkOrder(double[] val, OrderDirection dir,\n                                     boolean strict, boolean abort)\n        throws NonMonotonicSequenceException {\n        double previous = val[0];\n        final int max = val.length;\n\n        int index;\n        ITEM:\n        for (index = 1; index < max; index++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous = val[index];\n        }\n\n        if (index == max) {\n            // Loop completed.\n            return true;\n        }\n\n        // Loop early exit means wrong ordering.\n        if (abort) {\n            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n        } else {\n            return false;\n        }\n    }", "checkRectangular": "\n    public static void checkRectangular(final long[][] in)\n        throws NullArgumentException, DimensionMismatchException {\n        MathUtils.checkNotNull(in);\n        for (int i = 1; i < in.length; i++) {\n            if (in[i].length != in[0].length) {\n                throw new DimensionMismatchException(\n                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                        in[i].length, in[0].length);\n            }\n        }\n    }", "checkPositive": "\n    public static void checkPositive(final double[] in)\n        throws NotStrictlyPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] <= 0) {\n                throw new NotStrictlyPositiveException(in[i]);\n            }\n        }\n    }", "checkNonNegative": "\n    public static void checkNonNegative(final long[] in)\n        throws NotPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] < 0) {\n                throw new NotPositiveException(in[i]);\n            }\n        }\n    }", "safeNorm": "\n    public static double safeNorm(double[] v) {\n        double rdwarf = 3.834e-20;\n        double rgiant = 1.304e+19;\n        double s1 = 0;\n        double s2 = 0;\n        double s3 = 0;\n        double x1max = 0;\n        double x3max = 0;\n        double floatn = v.length;\n        double agiant = rgiant / floatn;\n        for (int i = 0; i < v.length; i++) {\n            double xabs = Math.abs(v[i]);\n            if (xabs < rdwarf || xabs > agiant) {\n                if (xabs > rdwarf) {\n                    if (xabs > x1max) {\n                        double r = x1max / xabs;\n                        s1= 1 + s1 * r * r;\n                        x1max = xabs;\n                    } else {\n                        double r = xabs / x1max;\n                        s1 += r * r;\n                    }\n                } else {\n                    if (xabs > x3max) {\n                        double r = x3max / xabs;\n                        s3= 1 + s3 * r * r;\n                        x3max = xabs;\n                    } else {\n                        if (xabs != 0) {\n                            double r = xabs / x3max;\n                            s3 += r * r;\n                        }\n                    }\n                }\n            } else {\n                s2 += xabs * xabs;\n            }\n        }\n        double norm;\n        if (s1 != 0) {\n            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n        } else {\n            if (s2 == 0) {\n                norm = x3max * Math.sqrt(s3);\n            } else {\n                if (s2 >= x3max) {\n                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                } else {\n                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                }\n            }\n        }\n        return norm;\n    }", "sortInPlace": "\n    public static void sortInPlace(double[] x, double[] ... yList)\n        throws DimensionMismatchException, NullArgumentException {\n        sortInPlace(x, OrderDirection.INCREASING, yList);\n    }", "copyOf": "\n     public static int[] copyOf(int[] source) {\n         return copyOf(source, source.length);\n     }", "linearCombination": "\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n            // Revert to scalar multiplication.\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }", "equals": "\n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "equalsIncludingNaN": "\n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "normalizeArray": "\n     public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }", "buildArray": "\n     public static <T> T[] buildArray(final Field<T> field, final int length) {\n         @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n         T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n     }", "convolve": "\n     public static double[] convolve(double[] x, double[] h)\n         throws NullArgumentException,\n                NoDataException {\n         MathUtils.checkNotNull(x);\n         MathUtils.checkNotNull(h);\n\n         final int xLen = x.length;\n         final int hLen = h.length;\n\n         if (xLen == 0 || hLen == 0) {\n             throw new NoDataException();\n         }\n\n         // initialize the output array\n         final int totalLength = xLen + hLen - 1;\n         final double[] y = new double[totalLength];\n\n         // straightforward implementation of the convolution sum\n         for (int n = 0; n < totalLength; n++) {\n             double yn = 0;\n             int k = FastMath.max(0, n + 1 - xLen);\n             int j = n - k;\n             while (k < hLen && j >= 0) {\n                 yn += x[j--] * h[k++];\n             }\n             y[n] = yn;\n         }\n\n         return y;\n     }"}