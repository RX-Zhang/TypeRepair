{"abs": "\n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }", "add": "\n    public Complex add(Complex addend) throws NullArgumentException {\n        MathUtils.checkNotNull(addend);\n        if (isNaN || addend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real + addend.getReal(),\n                             imaginary + addend.getImaginary());\n    }", "conjugate": "\n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real, -imaginary);\n    }", "divide": "\n    public Complex divide(Complex divisor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(divisor);\n        if (isNaN || divisor.isNaN) {\n            return NaN;\n        }\n\n        final double c = divisor.getReal();\n        final double d = divisor.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (divisor.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }", "reciprocal": "\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }", "equals": "\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex)other;\n            if (c.isNaN) {\n                return isNaN;\n            } else {\n                return (real == c.real) && (imaginary == c.imaginary);\n            }\n        }\n        return false;\n    }", "hashCode": "\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }", "getImaginary": "\n    public double getImaginary() {\n        return imaginary;\n    }", "getReal": "\n    public double getReal() {\n        return real;\n    }", "isNaN": "\n    public boolean isNaN() {\n        return isNaN;\n    }", "isInfinite": "\n    public boolean isInfinite() {\n        return isInfinite;\n    }", "multiply": "\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN || factor.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }", "negate": "\n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }", "subtract": "\n    public Complex subtract(Complex subtrahend)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(subtrahend);\n        if (isNaN || subtrahend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - subtrahend.getReal(),\n                             imaginary - subtrahend.getImaginary());\n    }", "acos": "\n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n    }", "asin": "\n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n    }", "atan": "\n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(I).divide(I.subtract(this)).log()\n                .multiply(I.divide(createComplex(2.0, 0.0)));\n    }", "cos": "\n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary),\n                             -FastMath.sin(real) * FastMath.sinh(imaginary));\n    }", "cosh": "\n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary),\n                             FastMath.sinh(real) * FastMath.sin(imaginary));\n    }", "exp": "\n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary),\n                             expReal * FastMath.sin(imaginary));\n    }", "log": "\n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n                             FastMath.atan2(imaginary, real));\n    }", "pow": "\n    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }", "sin": "\n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary),\n                             FastMath.cos(real) * FastMath.sinh(imaginary));\n    }", "sinh": "\n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary),\n            FastMath.cosh(real) * FastMath.sin(imaginary));\n    }", "sqrt": "\n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                                 FastMath.copySign(1d, imaginary) * t);\n        }\n    }", "sqrt1z": "\n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }", "tan": "\n    public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n            return NaN;\n        }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d,\n                             FastMath.sinh(imaginary2) / d);\n    }", "tanh": "\n    public Complex tanh() {\n        if (isNaN || Double.isInfinite(imaginary)) {\n            return NaN;\n        }\n        if (real > 20.0) {\n            return createComplex(1.0, 0.0);\n        }\n        if (real < -20.0) {\n            return createComplex(-1.0, 0.0);\n        }\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(FastMath.sinh(real2) / d,\n                             FastMath.sin(imaginary2) / d);\n    }", "getArgument": "\n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }", "nthRoot": "\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                           n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }", "createComplex": "\n    protected Complex createComplex(double realPart,\n                                    double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }", "valueOf": "\n    public static Complex valueOf(double realPart,\n                                  double imaginaryPart) {\n        if (Double.isNaN(realPart) ||\n            Double.isNaN(imaginaryPart)) {\n            return NaN;\n        }\n        return new Complex(realPart, imaginaryPart);\n    }", "readResolve": "\n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }", "getField": "\n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }", "toString": "\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }"}