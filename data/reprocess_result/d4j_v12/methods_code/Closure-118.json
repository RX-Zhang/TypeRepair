{"getTypes": "\n    UnionFind<T> getTypes() {\n      if (types == null) {\n        types = new StandardUnionFind<T>();\n      }\n      return types;\n    }", "addType": "\n    boolean addType(T type, T top, T relatedType) {\n      checkState(!skipRenaming, \"Attempt to record skipped property: %s\", name);\n      if (typeSystem.isInvalidatingType(top)) {\n        invalidate();\n        return false;\n      } else {\n        if (typeSystem.isTypeToSkip(top)) {\n          addTypeToSkip(top);\n        }\n\n        if (relatedType == null) {\n          getTypes().add(top);\n        } else {\n          getTypes().union(top, relatedType);\n        }\n        typeSystem.recordInterfaces(type, top, this);\n        return true;\n      }\n    }", "addTypeToSkip": "\n    void addTypeToSkip(T type) {\n      for (T skipType : typeSystem.getTypesToSkipForType(type)) {\n        typesToSkip.add(skipType);\n        getTypes().union(skipType, type);\n      }\n    }", "expandTypesToSkip": "\n    void expandTypesToSkip() {\n      // If we are not going to rename any properties, then we do not need to\n      // update the list of invalid types, as they are all invalid.\n      if (shouldRename()) {\n        int count = 0;\n        while (true) {\n          // It should usually only take one time through this do-while.\n          checkState(++count < 10, \"Stuck in loop expanding types to skip.\");\n\n          // Make sure that the representative type for each type to skip is\n          // marked as being skipped.\n          Set<T> rootTypesToSkip = Sets.newHashSet();\n          for (T subType : typesToSkip) {\n            rootTypesToSkip.add(types.find(subType));\n          }\n          typesToSkip.addAll(rootTypesToSkip);\n\n          Set<T> newTypesToSkip = Sets.newHashSet();\n          Set<T> allTypes = types.elements();\n          int originalTypesSize = allTypes.size();\n          for (T subType : allTypes) {\n            if (!typesToSkip.contains(subType)\n                && typesToSkip.contains(types.find(subType))) {\n              newTypesToSkip.add(subType);\n            }\n          }\n\n          for (T newType : newTypesToSkip) {\n            addTypeToSkip(newType);\n          }\n\n          // If there were not any new types added, we are done here.\n          if (types.elements().size() == originalTypesSize) {\n            break;\n          }\n        }\n      }\n    }", "shouldRename": "\n    boolean shouldRename() {\n      return !skipRenaming && types != null\n          && types.allEquivalenceClasses().size() > 1;\n    }", "invalidate": "\n    boolean invalidate() {\n      boolean changed = !skipRenaming;\n      skipRenaming = true;\n      types = null;\n      return changed;\n    }", "scheduleRenaming": "\n    boolean scheduleRenaming(Node node, T type) {\n      if (!skipRenaming) {\n        if (typeSystem.isInvalidatingType(type)) {\n          invalidate();\n          return false;\n        }\n        renameNodes.add(node);\n        rootTypes.put(node, type);\n      }\n      return true;\n    }", "forJSTypeSystem": "\n  static DisambiguateProperties<JSType> forJSTypeSystem(\n      AbstractCompiler compiler,\n      Map<String, CheckLevel> propertiesToErrorFor) {\n    return new DisambiguateProperties<JSType>(\n        compiler, new JSTypeSystem(compiler), propertiesToErrorFor);\n  }", "forConcreteTypeSystem": "\n  static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(\n      AbstractCompiler compiler, TightenTypes tt,\n      Map<String, CheckLevel> propertiesToErrorFor) {\n    return new DisambiguateProperties<ConcreteType>(\n        compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()),\n            propertiesToErrorFor);\n  }", "process": "\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(\n        compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);\n    for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n      addInvalidatingType(mis.typeA, mis.src);\n      addInvalidatingType(mis.typeB, mis.src);\n    }\n\n    NodeTraversal.traverse(compiler, externs, new FindExternProperties());\n    NodeTraversal.traverse(compiler, root, new FindRenameableProperties());\n    renameProperties();\n  }", "recordInvalidationError": "\n  private void recordInvalidationError(JSType t, JSError error) {\n    if (!t.isObject()) {\n      return;\n    }\n    if (invalidationMap != null) {\n      invalidationMap.put(t, error);\n    }\n  }", "addInvalidatingType": "\n  private void addInvalidatingType(JSType type, JSError error) {\n    type = type.restrictByNotNullOrUndefined();\n    if (type.isUnionType()) {\n      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n        addInvalidatingType(alt, error);\n      }\n    } else if (type.isEnumElementType()) {\n      addInvalidatingType(\n          type.toMaybeEnumElementType().getPrimitiveType(), error);\n    } else {\n      typeSystem.addInvalidatingType(type);\n      recordInvalidationError(type, error);\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null && objType.getImplicitPrototype() != null) {\n        typeSystem.addInvalidatingType(objType.getImplicitPrototype());\n        recordInvalidationError(objType.getImplicitPrototype(), error);\n      }\n    }\n  }", "getProperty": "\n  protected Property getProperty(String name) {\n    if (!properties.containsKey(name)) {\n      properties.put(name, new Property(name));\n    }\n    return properties.get(name);\n  }", "getTypeWithProperty": "\n  T getTypeWithProperty(String field, T type) {\n    return typeSystem.getTypeWithProperty(field, type);\n  }", "shouldTraverse": "\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }", "enterScope": "\n    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        scopes.push(typeSystem.getRootScope());\n      } else {\n        scopes.push(typeSystem.getFunctionScope(t.getScopeRoot()));\n      }\n    }", "exitScope": "\n    public void exitScope(NodeTraversal t) {\n      scopes.pop();\n    }", "getScope": "\n    protected StaticScope<T> getScope() {\n      return scopes.peek();\n    }", "visit": "\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // TODO(johnlenz): Support object-literal property definitions.\n      if (n.isGetProp()) {\n        String field = n.getLastChild().getString();\n        T type = typeSystem.getType(getScope(), n.getFirstChild(), field);\n        Property prop = getProperty(field);\n        if (typeSystem.isInvalidatingType(type)) {\n          prop.invalidate();\n        } else {\n          prop.addTypeToSkip(type);\n\n          // If this is a prototype property, then we want to skip assignments\n          // to the instance type as well.  These assignments are not usually\n          // seen in the extern code itself, so we must handle them here.\n          if ((type = typeSystem.getInstanceFromPrototype(type)) != null) {\n            prop.getTypes().add(type);\n            prop.typesToSkip.add(type);\n          }\n        }\n      }\n    }", "handleGetProp": "\n    private void handleGetProp(NodeTraversal t, Node n) {\n      String name = n.getLastChild().getString();\n      T type = typeSystem.getType(getScope(), n.getFirstChild(), name);\n\n      Property prop = getProperty(name);\n      if (!prop.scheduleRenaming(n.getLastChild(),\n                                 processProperty(t, prop, type, null))) {\n        if (propertiesToErrorFor.containsKey(name)) {\n          String suggestion = \"\";\n          if (type instanceof JSType) {\n            JSType jsType = (JSType) type;\n            if (jsType.isAllType() || jsType.isUnknownType()) {\n              if (n.getFirstChild().isThis()) {\n                suggestion = \"The \\\"this\\\" object is unknown in the function,\" +\n                    \"consider using @this\";\n              } else {\n                String qName = n.getFirstChild().getQualifiedName();\n                suggestion = \"Consider casting \" + qName +\n                    \" if you know it's type.\";\n              }\n            } else {\n              List<String> errors = Lists.newArrayList();\n              printErrorLocations(errors, jsType);\n              if (!errors.isEmpty()) {\n                suggestion = \"Consider fixing errors for the following types:\\n\";\n                suggestion += Joiner.on(\"\\n\").join(errors);\n              }\n            }\n          }\n          compiler.report(JSError.make(\n              t.getSourceName(), n, propertiesToErrorFor.get(name),\n              Warnings.INVALIDATION, name,\n              (type == null ? \"null\" : type.toString()),\n              n.toString(), suggestion));\n        }\n      }\n    }", "handleObjectLit": "\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING, GET, SET\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }", "printErrorLocations": "\n    private void printErrorLocations(List<String> errors, JSType t) {\n      if (!t.isObject() || t.isAllType()) {\n        return;\n      }\n\n      if (t.isUnionType()) {\n        for (JSType alt : t.toMaybeUnionType().getAlternates()) {\n          printErrorLocations(errors, alt);\n        }\n        return;\n      }\n\n      for (JSError error : invalidationMap.get(t)) {\n        if (errors.size() > MAX_INVALDIATION_WARNINGS_PER_PROPERTY) {\n          return;\n        }\n\n        errors.add(\n            t.toString() + \" at \" + error.sourceName + \":\" + error.lineNumber);\n      }\n    }", "processProperty": "\n    private T processProperty(\n        NodeTraversal t, Property prop, T type, T relatedType) {\n      type = typeSystem.restrictByNotNullOrUndefined(type);\n      if (prop.skipRenaming || typeSystem.isInvalidatingType(type)) {\n        return null;\n      }\n\n      Iterable<T> alternatives = typeSystem.getTypeAlternatives(type);\n      if (alternatives != null) {\n        T firstType = relatedType;\n        for (T subType : alternatives) {\n          T lastType = processProperty(t, prop, subType, firstType);\n          if (lastType != null) {\n            firstType = firstType == null ? lastType : firstType;\n          }\n        }\n        return firstType;\n      } else {\n        T topType = typeSystem.getTypeWithProperty(prop.name, type);\n        if (typeSystem.isInvalidatingType(topType)) {\n          return null;\n        }\n        prop.addType(type, topType, relatedType);\n        return topType;\n      }\n    }", "renameProperties": "\n  void renameProperties() {\n    int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0,\n        instancesSkipped = 0, singleTypeProps = 0;\n\n    Set<String> reported = Sets.newHashSet();\n    for (Property prop : properties.values()) {\n      if (prop.shouldRename()) {\n        Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);\n\n        ++propsRenamed;\n        prop.expandTypesToSkip();\n        for (Node node : prop.renameNodes) {\n          T rootType = prop.rootTypes.get(node);\n          if (prop.shouldRename(rootType)) {\n            String newName = propNames.get(rootType);\n            node.setString(newName);\n            compiler.reportCodeChange();\n            ++instancesRenamed;\n          } else {\n            ++instancesSkipped;\n\n            CheckLevel checkLevelForProp = propertiesToErrorFor.get(prop.name);\n            if (checkLevelForProp != null &&\n                checkLevelForProp != CheckLevel.OFF &&\n                !reported.contains(prop.name)) {\n              reported.add(prop.name);\n              compiler.report(JSError.make(\n                  NodeUtil.getSourceName(node), node,\n                  checkLevelForProp,\n                  Warnings.INVALIDATION_ON_TYPE, prop.name,\n                  rootType.toString(), \"\"));\n            }\n          }\n        }\n      } else {\n        if (prop.skipRenaming) {\n          ++propsSkipped;\n        } else {\n          ++singleTypeProps;\n        }\n      }\n    }\n    logger.fine(\"Renamed \" + instancesRenamed + \" instances of \"\n                + propsRenamed + \" properties.\");\n    logger.fine(\"Skipped renaming \" + instancesSkipped + \" invalidated \"\n                + \"properties, \" + propsSkipped + \" instances of properties \"\n                + \"that were skipped for specific types and \" + singleTypeProps\n                + \" properties that were referenced from only one type.\");\n  }", "buildPropNames": "\n  private Map<T, String> buildPropNames(UnionFind<T> types, String name) {\n    Map<T, String> names = Maps.newHashMap();\n    for (Set<T> set : types.allEquivalenceClasses()) {\n      checkState(!set.isEmpty());\n\n      String typeName = null;\n      for (T type : set) {\n        if (typeName == null || type.toString().compareTo(typeName) < 0) {\n          typeName = type.toString();\n        }\n      }\n\n      String newName;\n      if (\"{...}\".equals(typeName)) {\n        newName = name;\n      } else {\n        newName = typeName.replaceAll(\"[^\\\\w$]\", \"_\") + \"$\" + name;\n      }\n\n      for (T type : set) {\n        names.put(type, newName);\n      }\n    }\n    return names;\n  }", "getRenamedTypesForTesting": "\n  Multimap<String, Collection<T>> getRenamedTypesForTesting() {\n    Multimap<String, Collection<T>> ret = HashMultimap.create();\n    for (Map.Entry<String, Property> entry : properties.entrySet()) {\n      Property prop = entry.getValue();\n      if (!prop.skipRenaming) {\n        for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) {\n          if (!c.isEmpty() && !prop.typesToSkip.contains(c.iterator().next())) {\n            ret.put(entry.getKey(), c);\n          }\n        }\n      }\n    }\n    return ret;\n  }", "getRootScope": "\n    @Override public StaticScope<JSType> getRootScope() { return null; }", "getFunctionScope": "\n    @Override public StaticScope<JSType> getFunctionScope(Node node) {\n      return null;\n    }", "getType": "\n    @Override public JSType getType(\n        StaticScope<JSType> scope, Node node, String prop) {\n      if (node.getJSType() == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return node.getJSType();\n    }", "isInvalidatingType": "\n    @Override public boolean isInvalidatingType(JSType type) {\n      if (type == null || invalidatingTypes.contains(type) ||\n          type.isUnknownType() /* unresolved types */) {\n        return true;\n      }\n\n      ObjectType objType = ObjectType.cast(type);\n      return objType != null && !objType.hasReferenceName();\n    }", "getTypesToSkipForType": "\n    @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) {\n      type = type.restrictByNotNullOrUndefined();\n      if (type.isUnionType()) {\n        Set<JSType> types = Sets.newHashSet(type);\n        for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n          types.addAll(getTypesToSkipForTypeNonUnion(alt));\n        }\n        return ImmutableSet.copyOf(types);\n      } else if (type.isEnumElementType()) {\n        return getTypesToSkipForType(\n            type.toMaybeEnumElementType().getPrimitiveType());\n      }\n      return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type));\n    }", "getTypesToSkipForTypeNonUnion": "\n    private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {\n      Set<JSType> types = Sets.newHashSet();\n      JSType skipType = type;\n      while (skipType != null) {\n        types.add(skipType);\n\n        ObjectType objSkipType = skipType.toObjectType();\n        if (objSkipType != null) {\n          skipType = objSkipType.getImplicitPrototype();\n        } else {\n          break;\n        }\n      }\n      return types;\n    }", "isTypeToSkip": "\n    @Override public boolean isTypeToSkip(JSType type) {\n      return type.isEnumType() || (type.autoboxesTo() != null);\n    }", "restrictByNotNullOrUndefined": "\n    @Override public JSType restrictByNotNullOrUndefined(JSType type) {\n      return type.restrictByNotNullOrUndefined();\n    }", "getTypeAlternatives": "\n    @Override public Iterable<JSType> getTypeAlternatives(JSType type) {\n      if (type.isUnionType()) {\n        return type.toMaybeUnionType().getAlternates();\n      } else {\n        ObjectType objType = type.toObjectType();\n        if (objType != null &&\n            objType.getConstructor() != null &&\n            objType.getConstructor().isInterface()) {\n          List<JSType> list = Lists.newArrayList();\n          for (FunctionType impl\n                   : registry.getDirectImplementors(objType)) {\n            list.add(impl.getInstanceType());\n          }\n          return list;\n        } else {\n          return null;\n        }\n      }\n    }", "getInstanceFromPrototype": "\n    @Override public JSType getInstanceFromPrototype(JSType type) {\n      if (type.isFunctionPrototypeType()) {\n        ObjectType prototype = (ObjectType) type;\n        FunctionType owner = prototype.getOwnerFunction();\n        if (owner.isConstructor() || owner.isInterface()) {\n          return prototype.getOwnerFunction().getInstanceType();\n        }\n      }\n      return null;\n    }", "recordInterfaces": "\n    public void recordInterfaces(JSType type, JSType relatedType,\n                                 DisambiguateProperties<JSType>.Property p) {\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null) {\n        FunctionType constructor;\n        if (objType.isFunctionType()) {\n          constructor = objType.toMaybeFunctionType();\n        } else if (objType.isFunctionPrototypeType()) {\n          constructor = objType.getOwnerFunction();\n        } else {\n          constructor = objType.getConstructor();\n        }\n        while (constructor != null) {\n          for (ObjectType itype : constructor.getImplementedInterfaces()) {\n            JSType top = getTypeWithProperty(p.name, itype);\n            if (top != null) {\n              p.addType(itype, top, relatedType);\n            } else {\n              recordInterfaces(itype, relatedType, p);\n            }\n\n            // If this interface invalidated this property, return now.\n            if (p.skipRenaming) {\n              return;\n            }\n          }\n          if (constructor.isInterface() || constructor.isConstructor()) {\n            constructor = constructor.getSuperClassConstructor();\n          } else {\n            constructor = null;\n          }\n        }\n      }\n    }", "maybeAddAutoboxes": "\n    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, Node node, String prop) {\n      JSType jsType = node.getJSType();\n      if (jsType == null) {\n        return cType;\n      } else if (jsType.isUnknownType()) {\n        for (JSTypeNative nativeType : nativeTypes) {\n          ConcreteType concrete = tt.getConcreteInstance(\n              tt.getTypeRegistry().getNativeObjectType(nativeType));\n          if (concrete != null && !concrete.getPropertyType(prop).isNone()) {\n            cType = cType.unionWith(concrete);\n          }\n        }\n        return cType;\n      }\n\n      return maybeAddAutoboxes(cType, jsType, prop);\n    }"}