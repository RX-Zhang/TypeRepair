{"getDomainDescription": "\n    public String getDomainDescription() {\n        return this.domain;\n    }", "setDomainDescription": "\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }", "getRangeDescription": "\n    public String getRangeDescription() {\n        return this.range;\n    }", "setRangeDescription": "\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }", "getItemCount": "\n    public int getItemCount() {\n        return this.data.size();\n    }", "getItems": "\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }", "getMaximumItemCount": "\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }", "setMaximumItemCount": "\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }", "getMaximumItemAge": "\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }", "setMaximumItemAge": "\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }", "getTimePeriodClass": "\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }", "getDataItem": "\n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }", "getTimePeriod": "\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }", "getNextTimePeriod": "\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }", "getTimePeriods": "\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }", "getTimePeriodsUniqueToOtherSeries": "\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }", "getIndex": "\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }", "getValue": "\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }", "add": "\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }", "update": "\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }", "addAndOrUpdate": "\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }", "addOrUpdate": "\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }", "removeAgedItems": "\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history\n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }", "clear": "\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }", "delete": "\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }", "clone": "\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }", "createCopy": "\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }", "equals": "\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }", "hashCode": "\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }"}