{"process": "\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n  }", "hotSwapScript": "\n  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n    NodeTraversal.traverse(compiler, scriptRoot, this);\n  }", "getAllSymbols": "\n  public Iterable<Var> getAllSymbols() {\n    return referenceMap.keySet();\n  }", "getScope": "\n  public Scope getScope(Var var) {\n    return var.scope;\n  }", "getReferences": "\n  public ReferenceCollection getReferences(Var v) {\n    return referenceMap.get(v);\n  }", "visit": "\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n      Var v;\n      if (n.getString().equals(\"arguments\")) {\n        v = t.getScope().getArgumentsVar();\n      } else {\n        v = t.getScope().getVar(n.getString());\n      }\n      if (v != null && varFilter.apply(v)) {\n        addReference(v, new Reference(n, t, blockStack.peek()));\n      }\n    }\n\n    if (isBlockBoundary(n, parent)) {\n      blockStack.pop();\n    }\n  }", "enterScope": "\n  public void enterScope(NodeTraversal t) {\n    Node n = t.getScope().getRootNode();\n    BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek();\n    blockStack.push(new BasicBlock(parent, n));\n  }", "exitScope": "\n  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    if (t.getScope().isGlobal()) {\n      // Update global scope reference lists when we are done with it.\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n    } else {\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n    }\n  }", "shouldTraverse": "\n  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n      Node parent) {\n    // If node is a new basic block, put on basic block stack\n    if (isBlockBoundary(n, parent)) {\n      blockStack.push(new BasicBlock(blockStack.peek(), n));\n    }\n    return true;\n  }", "isBlockBoundary": "\n  private static boolean isBlockBoundary(Node n, Node parent) {\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DO:\n        case Token.FOR:\n        case Token.TRY:\n        case Token.WHILE:\n        case Token.WITH:\n          // NOTE: TRY has up to 3 child blocks:\n          // TRY\n          //   BLOCK\n          //   BLOCK\n          //     CATCH\n          //   BLOCK\n          // Note that there is an explicit CATCH token but no explicit\n          // FINALLY token. For simplicity, we consider each BLOCK\n          // a separate basic BLOCK.\n          return true;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.OR:\n          // The first child of a conditional is not a boundary,\n          // but all the rest of the children are.\n          return n != parent.getFirstChild();\n\n      }\n    }\n\n    return n.isCase();\n  }", "addReference": "\n  private void addReference(Var v, Reference reference) {\n    // Create collection if none already\n    ReferenceCollection referenceInfo = referenceMap.get(v);\n    if (referenceInfo == null) {\n      referenceInfo = new ReferenceCollection();\n      referenceMap.put(v, referenceInfo);\n    }\n\n    // Add this particular reference\n    referenceInfo.add(reference);\n  }", "iterator": "\n    public Iterator<Reference> iterator() {\n      return references.iterator();\n    }", "add": "\n    void add(Reference reference) {\n      references.add(reference);\n    }", "isWellDefined": "\n    protected boolean isWellDefined() {\n      int size = references.size();\n      if (size == 0) {\n        return false;\n      }\n\n      // If this is a declaration that does not instantiate the variable,\n      // it's not well-defined.\n      Reference init = getInitializingReference();\n      if (init == null) {\n        return false;\n      }\n\n      Preconditions.checkState(references.get(0).isDeclaration());\n      BasicBlock initBlock = init.getBasicBlock();\n      for (int i = 1; i < size; i++) {\n        if (!initBlock.provablyExecutesBefore(\n                references.get(i).getBasicBlock())) {\n          return false;\n        }\n      }\n\n      return true;\n    }", "isEscaped": "\n    boolean isEscaped() {\n      Scope scope = null;\n      for (Reference ref : references) {\n        if (scope == null) {\n          scope = ref.scope;\n        } else if (scope != ref.scope) {\n          return true;\n        }\n      }\n      return false;\n    }", "isInitializingDeclarationAt": "\n    private boolean isInitializingDeclarationAt(int index) {\n      Reference maybeInit = references.get(index);\n      if (maybeInit.isInitializingDeclaration()) {\n        // This is a declaration that represents the initial value.\n        // Specifically, var declarations without assignments such as \"var a;\"\n        // are not.\n        return true;\n      }\n      return false;\n    }", "isInitializingAssignmentAt": "\n    private boolean isInitializingAssignmentAt(int index) {\n      if (index < references.size() && index > 0) {\n        Reference maybeDecl = references.get(index - 1);\n        if (maybeDecl.isVarDeclaration()) {\n          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n          Reference maybeInit = references.get(index);\n          if (maybeInit.isSimpleAssignmentToName()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }", "getInitializingReference": "\n    Reference getInitializingReference() {\n      if (isInitializingDeclarationAt(0)) {\n        return references.get(0);\n      } else if (isInitializingAssignmentAt(1)) {\n        return references.get(1);\n      }\n      return null;\n    }", "getInitializingReferenceForConstants": "\n    Reference getInitializingReferenceForConstants() {\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n          return references.get(i);\n        }\n      }\n      return null;\n    }", "isAssignedOnceInLifetime": "\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }", "getOneAndOnlyAssignment": "\n    private Reference getOneAndOnlyAssignment() {\n      Reference assignment = null;\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        Reference ref = references.get(i);\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          if (assignment == null) {\n            assignment = ref;\n          } else {\n            return null;\n          }\n        }\n      }\n      return assignment;\n    }", "isNeverAssigned": "\n    boolean isNeverAssigned() {\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        Reference ref = references.get(i);\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          return false;\n        }\n      }\n      return true;\n    }", "firstReferenceIsAssigningDeclaration": "\n    boolean firstReferenceIsAssigningDeclaration() {\n      int size = references.size();\n      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n        return true;\n      }\n      return false;\n    }", "newBleedingFunction": "\n    static Reference newBleedingFunction(NodeTraversal t,\n        BasicBlock basicBlock, Node func) {\n      return new Reference(func.getFirstChild(),\n          basicBlock, t.getScope(), t.getInput().getInputId());\n    }", "createRefForTest": "\n    static Reference createRefForTest(CompilerInput input) {\n      return new Reference(new Node(Token.NAME), null, null,\n          input.getInputId());\n    }", "cloneWithNewScope": "\n    Reference cloneWithNewScope(Scope newScope) {\n      return new Reference(nameNode, basicBlock, newScope, inputId);\n    }", "getSymbol": "\n    public Var getSymbol() {\n      return scope.getVar(nameNode.getString());\n    }", "getNode": "\n    public Node getNode() {\n      return nameNode;\n    }", "getInputId": "\n    public InputId getInputId() {\n      return inputId;\n    }", "getSourceFile": "\n    public StaticSourceFile getSourceFile() {\n      return sourceFile;\n    }", "isDeclaration": "\n    boolean isDeclaration() {\n      Node parent = getParent();\n      Node grandparent = parent.getParent();\n      return DECLARATION_PARENTS.contains(parent.getType()) ||\n          parent.isParamList() &&\n          grandparent.isFunction();\n    }", "isVarDeclaration": "\n    boolean isVarDeclaration() {\n      return getParent().isVar();\n    }", "isHoistedFunction": "\n    boolean isHoistedFunction() {\n      return NodeUtil.isHoistedFunctionDeclaration(getParent());\n    }", "isInitializingDeclaration": "\n    boolean isInitializingDeclaration() {\n      // VAR is the only type of variable declaration that may not initialize\n      // its variable. Catch blocks, named functions, and parameters all do.\n      return isDeclaration() &&\n          !getParent().isVar() ||\n          nameNode.getFirstChild() != null;\n    }", "getAssignedValue": "\n    Node getAssignedValue() {\n      Node parent = getParent();\n      return (parent.isFunction())\n          ? parent : NodeUtil.getAssignedValue(nameNode);\n    }", "getBasicBlock": "\n    BasicBlock getBasicBlock() {\n      return basicBlock;\n    }", "getParent": "\n    Node getParent() {\n      return getNode().getParent();\n    }", "getGrandparent": "\n    Node getGrandparent() {\n      Node parent = getParent();\n      return parent == null ? null : parent.getParent();\n    }", "isLhsOfForInExpression": "\n    private static boolean isLhsOfForInExpression(Node n) {\n      Node parent = n.getParent();\n      if (parent.isVar()) {\n        return isLhsOfForInExpression(parent);\n      }\n      return NodeUtil.isForIn(parent) && parent.getFirstChild() == n;\n    }", "isSimpleAssignmentToName": "\n    boolean isSimpleAssignmentToName() {\n      Node parent = getParent();\n      return parent.isAssign()\n          && parent.getFirstChild() == nameNode;\n    }", "isLvalue": "\n    boolean isLvalue() {\n      Node parent = getParent();\n      int parentType = parent.getType();\n      return (parentType == Token.VAR && nameNode.getFirstChild() != null)\n          || parentType == Token.INC\n          || parentType == Token.DEC\n          || (NodeUtil.isAssignmentOp(parent)\n              && parent.getFirstChild() == nameNode)\n          || isLhsOfForInExpression(nameNode);\n    }", "isGlobalScopeBlock": "\n    boolean isGlobalScopeBlock() {\n      return getParent() == null;\n    }", "provablyExecutesBefore": "\n    boolean provablyExecutesBefore(BasicBlock thatBlock) {\n      // If thatBlock is a descendant of this block, and there are no hoisted\n      // blocks between them, then this block must start before thatBlock.\n      BasicBlock currentBlock;\n      for (currentBlock = thatBlock;\n           currentBlock != null && currentBlock != this;\n           currentBlock = currentBlock.getParent()) {\n        if (currentBlock.isHoisted) {\n          return false;\n        }\n      }\n\n      if (currentBlock == this) {\n        return true;\n      }\n      if (isGlobalScopeBlock() && thatBlock.isGlobalScopeBlock()) {\n        return true;\n      }\n      return false;\n    }"}