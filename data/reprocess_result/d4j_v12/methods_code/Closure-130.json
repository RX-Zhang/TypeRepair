{"process": "\n  public void process(Node externs, Node root) {\n    GlobalNamespace namespace;\n    if (collapsePropertiesOnExternTypes) {\n      namespace = new GlobalNamespace(compiler, externs, root);\n    } else {\n      namespace = new GlobalNamespace(compiler, root);\n    }\n\n    if (inlineAliases) {\n      inlineAliases(namespace);\n    }\n    nameMap = namespace.getNameIndex();\n    globalNames = namespace.getNameForest();\n    checkNamespaces();\n\n    for (Name n : globalNames) {\n      flattenReferencesToCollapsibleDescendantNames(n, n.getBaseName());\n    }\n\n    // We collapse property definitions after collapsing property references\n    // because this step can alter the parse tree above property references,\n    // invalidating the node ancestry stored with each reference.\n    for (Name n : globalNames) {\n      collapseDeclarationOfNameAndDescendants(n, n.getBaseName());\n    }\n  }", "inlineAliases": "\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }", "inlineAliasIfPossible": "\n  private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n    // Ensure that the alias is assigned to a local variable at that\n    // variable's declaration. If the alias's parent is a NAME,\n    // then the NAME must be the child of a VAR node, and we must\n    // be in a VAR assignment.\n    Node aliasParent = alias.node.getParent();\n    if (aliasParent.isName()) {\n      // Ensure that the local variable is well defined and never reassigned.\n      Scope scope = alias.scope;\n      Var aliasVar = scope.getVar(aliasParent.getString());\n      ReferenceCollectingCallback collector =\n          new ReferenceCollectingCallback(compiler,\n              ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n              Predicates.<Var>equalTo(aliasVar));\n      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n\n      ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n      if (aliasRefs.isWellDefined()\n          && aliasRefs.firstReferenceIsAssigningDeclaration()\n          && aliasRefs.isAssignedOnceInLifetime()) {\n        // The alias is well-formed, so do the inlining now.\n        int size = aliasRefs.references.size();\n        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n        for (int i = 1; i < size; i++) {\n          ReferenceCollectingCallback.Reference aliasRef =\n              aliasRefs.references.get(i);\n\n          Node newNode = alias.node.cloneTree();\n          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n          newNodes.add(newNode);\n        }\n\n        // just set the original alias to null.\n        aliasParent.replaceChild(alias.node, IR.nullNode());\n        compiler.reportCodeChange();\n\n        // Inlining the variable may have introduced new references\n        // to descendants of {@code name}. So those need to be collected now.\n        namespace.scanNewNodes(alias.scope, newNodes);\n        return true;\n      }\n    }\n\n    return false;\n  }", "checkNamespaces": "\n  private void checkNamespaces() {\n    for (Name name : nameMap.values()) {\n      if (name.isNamespace() &&\n          (name.aliasingGets > 0 || name.localSets + name.globalSets > 1 ||\n           name.deleteProps > 0)) {\n        boolean initialized = name.getDeclaration() != null;\n        for (Ref ref : name.getRefs()) {\n          if (ref == name.getDeclaration()) {\n            continue;\n          }\n\n          if (ref.type == Ref.Type.DELETE_PROP) {\n            if (initialized) {\n              warnAboutNamespaceRedefinition(name, ref);\n            }\n          } else if (\n              ref.type == Ref.Type.SET_FROM_GLOBAL ||\n              ref.type == Ref.Type.SET_FROM_LOCAL) {\n            if (initialized) {\n              warnAboutNamespaceRedefinition(name, ref);\n            }\n\n            initialized = true;\n          } else if (ref.type == Ref.Type.ALIASING_GET) {\n            warnAboutNamespaceAliasing(name, ref);\n          }\n        }\n      }\n    }\n  }", "warnAboutNamespaceAliasing": "\n  private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) {\n    compiler.report(\n        JSError.make(ref.getSourceName(), ref.node,\n                     UNSAFE_NAMESPACE_WARNING, nameObj.getFullName()));\n  }", "warnAboutNamespaceRedefinition": "\n  private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) {\n    compiler.report(\n        JSError.make(ref.getSourceName(), ref.node,\n                     NAMESPACE_REDEFINED_WARNING, nameObj.getFullName()));\n  }", "flattenReferencesToCollapsibleDescendantNames": "\n  private void flattenReferencesToCollapsibleDescendantNames(\n      Name n, String alias) {\n    if (n.props == null) return;\n\n    for (Name p : n.props) {\n      String propAlias = appendPropForAlias(alias, p.getBaseName());\n\n      if (p.canCollapse()) {\n        flattenReferencesTo(p, propAlias);\n      } else if (p.isSimpleStubDeclaration()) {\n        flattenSimpleStubDeclaration(p, propAlias);\n      }\n\n      flattenReferencesToCollapsibleDescendantNames(p, propAlias);\n    }\n  }", "flattenSimpleStubDeclaration": "\n  private void flattenSimpleStubDeclaration(Name name, String alias) {\n    Ref ref = Iterables.getOnlyElement(name.getRefs());\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, ref.node,\n        name.getFullName());\n    Node varNode = IR.var(nameNode).copyInformationFrom(nameNode);\n\n    Preconditions.checkState(\n        ref.node.getParent().isExprResult());\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    gramps.replaceChild(parent, varNode);\n    compiler.reportCodeChange();\n  }", "flattenReferencesTo": "\n  private void flattenReferencesTo(Name n, String alias) {\n    String originalName = n.getFullName();\n    for (Ref r : n.getRefs()) {\n      if (r == n.getDeclaration()) {\n        // Declarations are handled separately.\n        continue;\n      }\n\n      Node rParent = r.node.getParent();\n\n      // There are two cases when we shouldn't flatten a reference:\n      // 1) Object literal keys, because duplicate keys show up as refs.\n      // 2) References inside a complex assign. (a = x.y = 0). These are\n      //    called TWIN references, because they show up twice in the\n      //    reference list. Only collapse the set, not the alias.\n      if (!NodeUtil.isObjectLitKey(r.node) &&\n          (r.getTwin() == null || r.isSet())) {\n        flattenNameRef(alias, r.node, rParent, originalName);\n      }\n    }\n\n    // Flatten all occurrences of a name as a prefix of its subnames. For\n    // example, if {@code n} corresponds to the name \"a.b\", then \"a.b\" will be\n    // replaced with \"a$b\" in all occurrences of \"a.b.c\", \"a.b.c.d\", etc.\n    if (n.props != null) {\n      for (Name p : n.props) {\n        flattenPrefixes(alias, p, 1);\n      }\n    }\n  }", "flattenPrefixes": "\n  private void flattenPrefixes(String alias, Name n, int depth) {\n    // Only flatten the prefix of a name declaration if the name being\n    // initialized is fully qualified (i.e. not an object literal key).\n    String originalName = n.getFullName();\n    Ref decl = n.getDeclaration();\n    if (decl != null && decl.node != null &&\n        decl.node.isGetProp()) {\n      flattenNameRefAtDepth(alias, decl.node, depth, originalName);\n    }\n\n    for (Ref r : n.getRefs()) {\n      if (r == decl) {\n        // Declarations are handled separately.\n        continue;\n      }\n\n      // References inside a complex assign (a = x.y = 0)\n      // have twins. We should only flatten one of the twins.\n      if (r.getTwin() == null || r.isSet()) {\n        flattenNameRefAtDepth(alias, r.node, depth, originalName);\n      }\n    }\n\n    if (n.props != null) {\n      for (Name p : n.props) {\n        flattenPrefixes(alias, p, depth + 1);\n      }\n    }\n  }", "flattenNameRefAtDepth": "\n  private void flattenNameRefAtDepth(String alias, Node n, int depth,\n      String originalName) {\n    // This method has to work for both GETPROP chains and, in rare cases,\n    // OBJLIT keys, possibly nested. That's why we check for children before\n    // proceeding. In the OBJLIT case, we don't need to do anything.\n    int nType = n.getType();\n    boolean isQName = nType == Token.NAME || nType == Token.GETPROP;\n    boolean isObjKey = NodeUtil.isObjectLitKey(n);\n    Preconditions.checkState(isObjKey || isQName);\n    if (isQName) {\n      for (int i = 1; i < depth && n.hasChildren(); i++) {\n        n = n.getFirstChild();\n      }\n      if (n.hasChildren()) {\n        flattenNameRef(alias, n.getFirstChild(), n, originalName);\n      }\n    }\n  }", "flattenNameRef": "\n  private void flattenNameRef(String alias, Node n, Node parent,\n      String originalName) {\n    // BEFORE:\n    //   getprop\n    //     getprop\n    //       name a\n    //       string b\n    //     string c\n    // AFTER:\n    //   name a$b$c\n    Node ref = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, n, originalName);\n    NodeUtil.copyNameAnnotations(n.getLastChild(), ref);\n    if (parent.isCall() && n == parent.getFirstChild()) {\n      // The node was a call target, we are deliberately flatten these as\n      // we node the \"this\" isn't provided by the namespace. Mark it as such:\n      parent.putBooleanProp(Node.FREE_CALL, true);\n    }\n\n    JSType type = n.getJSType();\n    if (type != null) {\n      ref.setJSType(type);\n    }\n    parent.replaceChild(n, ref);\n    compiler.reportCodeChange();\n  }", "collapseDeclarationOfNameAndDescendants": "\n  private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {\n    boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\n\n    // Handle this name first so that nested object literals get unrolled.\n    if (n.canCollapse()) {\n      updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);\n    }\n\n    if (n.props != null) {\n      for (Name p : n.props) {\n        // Recurse first so that saved node ancestries are intact when needed.\n        collapseDeclarationOfNameAndDescendants(\n            p, appendPropForAlias(alias, p.getBaseName()));\n\n        if (!p.inExterns && canCollapseChildNames &&\n            p.getDeclaration() != null &&\n            p.canCollapse() &&\n            p.getDeclaration().node != null &&\n            p.getDeclaration().node.getParent() != null &&\n            p.getDeclaration().node.getParent().isAssign()) {\n          updateSimpleDeclaration(\n              appendPropForAlias(alias, p.getBaseName()), p, p.getDeclaration());\n        }\n      }\n    }\n  }", "updateSimpleDeclaration": "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n\n    if (rvalue != null && rvalue.isFunction()) {\n      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n    }\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.getFullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.isExprResult()) {\n      // BEFORE: a.b.c = ...;\n      //   exprstmt\n      //     assign\n      //       getprop\n      //         getprop\n      //           name a\n      //           string b\n      //         string c\n      //       NODE\n      // AFTER: var a$b$c = ...;\n      //   var\n      //     name a$b$c\n      //       NODE\n\n      // Remove the r-value (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = IR.var(nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE:\n      // ... (x.y = 3);\n      //\n      // AFTER:\n      // var x$y;\n      // ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      for (; !currentParent.isScript() &&\n             !currentParent.isBlock();\n           current = currentParent,\n           currentParent = currentParent.getParent()) {}\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = IR.var(nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }", "updateObjLitOrFunctionDeclaration": "\n  private void updateObjLitOrFunctionDeclaration(\n      Name n, String alias, boolean canCollapseChildNames) {\n    Ref decl = n.getDeclaration();\n    if (decl == null) {\n      // Some names do not have declarations, because they\n      // are only defined in local scopes.\n      return;\n    }\n\n    if (decl.getTwin() != null) {\n      // Twin declarations will get handled when normal references\n      // are handled.\n      return;\n    }\n\n    switch (decl.node.getParent().getType()) {\n      case Token.ASSIGN:\n        updateObjLitOrFunctionDeclarationAtAssignNode(\n            n, alias, canCollapseChildNames);\n        break;\n      case Token.VAR:\n        updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames);\n        break;\n      case Token.FUNCTION:\n        updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);\n        break;\n    }\n  }", "updateObjLitOrFunctionDeclarationAtAssignNode": "\n  private void updateObjLitOrFunctionDeclarationAtAssignNode(\n      Name n, String alias, boolean canCollapseChildNames) {\n    // NOTE: It's important that we don't add additional nodes\n    // (e.g. a var node before the exprstmt) because the exprstmt might be\n    // the child of an if statement that's not inside a block).\n\n    Ref ref = n.getDeclaration();\n    Node rvalue = ref.node.getNext();\n    Node varNode = new Node(Token.VAR);\n    Node varParent = ref.node.getAncestor(3);\n    Node gramps = ref.node.getAncestor(2);\n    boolean isObjLit = rvalue.isObjectLit();\n    boolean insertedVarNode = false;\n\n    if (isObjLit && n.canEliminate()) {\n      // Eliminate the object literal altogether.\n      varParent.replaceChild(gramps, varNode);\n      ref.node = null;\n      insertedVarNode = true;\n\n    } else if (!n.isSimpleName()) {\n      // Create a VAR node to declare the name.\n      if (rvalue.isFunction()) {\n        checkForHosedThisReferences(rvalue, n.docInfo, n);\n      }\n\n      ref.node.getParent().removeChild(rvalue);\n\n      Node nameNode = NodeUtil.newName(\n          compiler.getCodingConvention(),\n          alias, ref.node.getAncestor(2), n.getFullName());\n\n      JSDocInfo info = ref.node.getParent().getJSDocInfo();\n      if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME) ||\n          (info != null && info.isConstant())) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n\n      if (info != null) {\n        varNode.setJSDocInfo(info);\n      }\n      varNode.addChildToBack(nameNode);\n      nameNode.addChildToFront(rvalue);\n      varParent.replaceChild(gramps, varNode);\n\n      // Update the node ancestry stored in the reference.\n      ref.node = nameNode;\n      insertedVarNode = true;\n    }\n\n    if (canCollapseChildNames) {\n      if (isObjLit) {\n        declareVarsForObjLitValues(\n            n, alias, rvalue,\n            varNode, varParent.getChildBefore(varNode), varParent);\n      }\n\n      addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n    }\n\n    if (insertedVarNode) {\n      if (!varNode.hasChildren()) {\n        varParent.removeChild(varNode);\n      }\n      compiler.reportCodeChange();\n    }\n  }", "checkForHosedThisReferences": "\n  private void checkForHosedThisReferences(Node function, JSDocInfo docInfo,\n      final Name name) {\n    // A function is getting collapsed. Make sure that if it refers to\n    // \"this\", it must be a constructor or documented with @this.\n    if (docInfo == null ||\n        (!docInfo.isConstructor() && !docInfo.hasThisType())) {\n      NodeTraversal.traverse(compiler, function.getLastChild(),\n          new NodeTraversal.AbstractShallowCallback() {\n            @Override\n            public void visit(NodeTraversal t, Node n, Node parent) {\n              if (n.isThis()) {\n                compiler.report(\n                    JSError.make(name.getDeclaration().getSourceName(), n,\n                        UNSAFE_THIS, name.getFullName()));\n              }\n            }\n          });\n    }\n  }", "updateObjLitOrFunctionDeclarationAtVarNode": "\n  private void updateObjLitOrFunctionDeclarationAtVarNode(\n      Name n, boolean canCollapseChildNames) {\n    if (!canCollapseChildNames) {\n      return;\n    }\n\n    Ref ref = n.getDeclaration();\n    String name = ref.node.getString();\n    Node rvalue = ref.node.getFirstChild();\n    Node varNode = ref.node.getParent();\n    Node gramps = varNode.getParent();\n\n    boolean isObjLit = rvalue.isObjectLit();\n    int numChanges = 0;\n\n    if (isObjLit) {\n      numChanges += declareVarsForObjLitValues(\n          n, name, rvalue, varNode, gramps.getChildBefore(varNode),\n          gramps);\n    }\n\n    numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);\n\n    if (isObjLit && n.canEliminate()) {\n      varNode.removeChild(ref.node);\n      if (!varNode.hasChildren()) {\n        gramps.removeChild(varNode);\n      }\n      numChanges++;\n\n      // Clear out the object reference, since we've eliminated it from the\n      // parse tree.\n      ref.node = null;\n    }\n\n    if (numChanges > 0) {\n      compiler.reportCodeChange();\n    }\n  }", "updateFunctionDeclarationAtFunctionNode": "\n  private void updateFunctionDeclarationAtFunctionNode(\n      Name n, boolean canCollapseChildNames) {\n    if (!canCollapseChildNames) {\n      return;\n    }\n\n    Ref ref = n.getDeclaration();\n    String fnName = ref.node.getString();\n    addStubsForUndeclaredProperties(\n        n, fnName, ref.node.getAncestor(2), ref.node.getParent());\n  }", "declareVarsForObjLitValues": "\n  private int declareVarsForObjLitValues(\n      Name objlitName, String alias, Node objlit, Node varNode,\n      Node nameToAddAfter, Node varParent) {\n    int numVars = 0;\n    int arbitraryNameCounter = 0;\n    boolean discardKeys = !objlitName.shouldKeepKeys();\n\n    for (Node key = objlit.getFirstChild(), nextKey; key != null;\n         key = nextKey) {\n      Node value = key.getFirstChild();\n      nextKey = key.getNext();\n\n      // A get or a set can not be rewritten as a VAR.\n      if (key.isGetterDef() || key.isSetterDef()) {\n        continue;\n      }\n\n      // We generate arbitrary names for keys that aren't valid JavaScript\n      // identifiers, since those keys are never referenced. (If they were,\n      // this object literal's child names wouldn't be collapsible.) The only\n      // reason that we don't eliminate them entirely is the off chance that\n      // their values are expressions that have side effects.\n      boolean isJsIdentifier = !key.isNumber() &&\n                               TokenStream.isJSIdentifier(key.getString());\n      String propName = isJsIdentifier ?\n          key.getString() : String.valueOf(++arbitraryNameCounter);\n\n      // If the name cannot be collapsed, skip it.\n      String qName = objlitName.getFullName() + '.' + propName;\n      Name p = nameMap.get(qName);\n      if (p != null && !p.canCollapse()) {\n        continue;\n      }\n\n      String propAlias = appendPropForAlias(alias, propName);\n      Node refNode = null;\n      if (discardKeys) {\n        objlit.removeChild(key);\n        value.detachFromParent();\n      } else {\n        // Substitute a reference for the value.\n        refNode = IR.name(propAlias);\n        if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n\n        key.replaceChild(value, refNode);\n      }\n\n      // Declare the collapsed name as a variable with the original value.\n      Node nameNode = IR.name(propAlias);\n      nameNode.addChildToFront(value);\n      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n      Node newVar = IR.var(nameNode)\n          .copyInformationFromForTree(key);\n      if (nameToAddAfter != null) {\n        varParent.addChildAfter(newVar, nameToAddAfter);\n      } else {\n        varParent.addChildBefore(newVar, varNode);\n      }\n      compiler.reportCodeChange();\n      nameToAddAfter = newVar;\n\n      // Update the global name's node ancestry if it hasn't already been\n      // done. (Duplicate keys in an object literal can bring us here twice\n      // for the same global name.)\n      if (isJsIdentifier && p != null) {\n        if (!discardKeys) {\n          Ref newAlias =\n              p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);\n          newAlias.node = refNode;\n          p.addRef(newAlias);\n        }\n\n        p.getDeclaration().node = nameNode;\n\n        if (value.isFunction()) {\n          checkForHosedThisReferences(value, value.getJSDocInfo(), p);\n        }\n      }\n\n      numVars++;\n    }\n    return numVars;\n  }", "addStubsForUndeclaredProperties": "\n  private int addStubsForUndeclaredProperties(\n      Name n, String alias, Node parent, Node addAfter) {\n    Preconditions.checkState(n.canCollapseUnannotatedChildNames());\n    Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));\n    Preconditions.checkNotNull(addAfter);\n    int numStubs = 0;\n    if (n.props != null) {\n      for (Name p : n.props) {\n        if (p.needsToBeStubbed()) {\n          String propAlias = appendPropForAlias(alias, p.getBaseName());\n          Node nameNode = IR.name(propAlias);\n          Node newVar = IR.var(nameNode)\n              .copyInformationFromForTree(addAfter);\n          parent.addChildAfter(newVar, addAfter);\n          addAfter = newVar;\n          numStubs++;\n          compiler.reportCodeChange();\n\n          // Determine if this is a constant var by checking the first\n          // reference to it. Don't check the declaration, as it might be null.\n          if (p.getRefs().get(0).node.getLastChild().getBooleanProp(\n                  Node.IS_CONSTANT_NAME)) {\n            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n          }\n        }\n      }\n    }\n    return numStubs;\n  }", "appendPropForAlias": "\n  private static String appendPropForAlias(String root, String prop) {\n    if (prop.indexOf('$') != -1) {\n      // Encode '$' in a property as '$0'. Because '0' cannot be the\n      // start of an identifier, this will never conflict with our\n      // encoding from '.' -> '$'.\n      prop = prop.replace(\"$\", \"$0\");\n    }\n    return root + '$' + prop;\n  }"}