{"clone": "\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }", "equal": "\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }", "createTranslatedShape": "\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }", "rotateShape": "\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }", "drawRotatedShape": "\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }", "createDiagonalCross": "\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }", "createRegularCross": "\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }", "createDiamond": "\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }", "createUpTriangle": "\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }", "createDownTriangle": "\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }", "createLineRegion": "\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }", "getPointInRectangle": "\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }", "contains": "\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }", "intersects": "\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }"}