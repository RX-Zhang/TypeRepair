{"reportChange": "\n  private void reportChange() {\n    if (checkOnly) {\n      Preconditions.checkState(false, \"normalizeNodeType constraints violated\");\n    }\n  }", "process": "\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations());\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations());\n      }\n    }\n  }", "normalizeNodeTypes": "\n  private void normalizeNodeTypes(Node n) {\n    normalizeBlocks(n);\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n      // This pass is run during the CompilerTestCase validation, so this\n      // parent pointer check serves as a more general check.\n      Preconditions.checkState(child.getParent() == n);\n\n      normalizeNodeTypes(child);\n    }\n  }", "normalizeBlocks": "\n  private void normalizeBlocks(Node n) {\n    if (NodeUtil.isControlStructure(n)\n        && !n.isLabel()\n        && !n.isSwitch()) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n            !c.isBlock()) {\n          Node newBlock = IR.block().srcref(n);\n          n.replaceChild(c, newBlock);\n          if (!c.isEmpty()) {\n            newBlock.addChildrenToFront(c);\n          } else {\n            newBlock.setWasEmptyNode(true);\n          }\n          c = newBlock;\n          reportChange();\n        }\n      }\n    }\n  }", "shouldTraverse": "\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isObjectLit()) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }", "visit": "\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }", "normalizeObjectLiteralAnnotations": "\n    private void normalizeObjectLiteralAnnotations(Node objlit) {\n      Preconditions.checkState(objlit.isObjectLit());\n      for (Node key = objlit.getFirstChild();\n           key != null; key = key.getNext()) {\n        Node value = key.getFirstChild();\n        normalizeObjectLiteralKeyAnnotations(objlit, key, value);\n      }\n    }", "annotateCalls": "\n    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }", "annotateDispatchers": "\n    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.isFunction());\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.isAssign()) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }", "normalizeObjectLiteralKeyAnnotations": "\n    private void normalizeObjectLiteralKeyAnnotations(\n        Node objlit, Node key, Node value) {\n      Preconditions.checkState(objlit.isObjectLit());\n      if (key.getJSDocInfo() != null &&\n          value.isFunction()) {\n        value.setJSDocInfo(key.getJSDocInfo());\n      }\n    }"}