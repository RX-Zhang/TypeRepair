{"hasExternsRoot": "\n  boolean hasExternsRoot() {\n    return externsRoot != null;\n  }", "getRootNode": "\n  public Node getRootNode() {\n    return root.getParent();\n  }", "getParentScope": "\n  public StaticScope<JSType> getParentScope() {\n    return null;\n  }", "getSlot": "\n  public Name getSlot(String name) {\n    return getOwnSlot(name);\n  }", "getOwnSlot": "\n  public Name getOwnSlot(String name) {\n    ensureGenerated();\n    return nameMap.get(name);\n  }", "getTypeOfThis": "\n  public JSType getTypeOfThis() {\n    return compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n  }", "getReferences": "\n  public Iterable<Ref> getReferences(Name slot) {\n    ensureGenerated();\n    return Collections.unmodifiableList(slot.getRefs());\n  }", "getScope": "\n  public StaticScope<JSType> getScope(Name slot) {\n    return this;\n  }", "getAllSymbols": "\n  public Iterable<Name> getAllSymbols() {\n    ensureGenerated();\n    return Collections.unmodifiableCollection(getNameIndex().values());\n  }", "ensureGenerated": "\n  private void ensureGenerated() {\n    if (!generated) {\n      process();\n    }\n  }", "getNameForest": "\n  List<Name> getNameForest() {\n    ensureGenerated();\n    return globalNames;\n  }", "getNameIndex": "\n  Map<String, Name> getNameIndex() {\n    ensureGenerated();\n    return nameMap;\n  }", "scanNewNodes": "\n  void scanNewNodes(List<AstChange> newNodes) {\n    BuildGlobalNamespace builder = new BuildGlobalNamespace();\n\n    for (AstChange info : newNodes) {\n      if (!info.node.isQualifiedName() && !NodeUtil.isObjectLitKey(info.node)) {\n        continue;\n      }\n      scanFromNode(builder, info.module, info.scope, info.node);\n    }\n  }", "scanFromNode": "\n  private void scanFromNode(\n    BuildGlobalNamespace builder, JSModule module, Scope scope, Node n) {\n    // Check affected parent nodes first.\n    if (n.isName() || n.isGetProp()) {\n      scanFromNode(builder, module, scope, n.getParent());\n    }\n    builder.collect(module, scope, n);\n  }", "process": "\n  private void process() {\n    if (externsRoot != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externsRoot, new BuildGlobalNamespace());\n    }\n    inExterns = false;\n\n    NodeTraversal.traverse(compiler, root, new BuildGlobalNamespace());\n    generated = true;\n  }", "isGlobalNameReference": "\n  private boolean isGlobalNameReference(String name, Scope s) {\n    String topVarName = getTopVarName(name);\n    return isGlobalVarReference(topVarName, s);\n  }", "getTopVarName": "\n  private String getTopVarName(String name) {\n    int firstDotIndex = name.indexOf('.');\n    return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex);\n  }", "isGlobalVarReference": "\n  private boolean isGlobalVarReference(String name, Scope s) {\n    Scope.Var v = s.getVar(name);\n    if (v == null && externsScope != null) {\n      v = externsScope.getVar(name);\n    }\n    return v != null && !v.isLocal();\n  }", "isGlobalScope": "\n  private boolean isGlobalScope(Scope s) {\n    return s.getParent() == null;\n  }", "visit": "\n    public void visit(NodeTraversal t, Node n, Node parent) {}", "shouldTraverse": "\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      // If we are traversing the externs, then we save a pointer to the scope\n      // generated by them, so that we can do lookups in it later.\n      if (externsRoot != null && n == externsRoot) {\n        externsScope = t.getScope();\n      }\n\n      collect(t.getModule(), t.getScope(), n);\n\n      return true;\n    }", "collect": "\n    public void collect(JSModule module, Scope scope, Node n) {\n      Node parent = n.getParent();\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) {\n            return;\n          }\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n                  return;\n                }\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              case Token.GETPROP:\n                return;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) {\n            return;\n          }\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(module, scope, n, parent, name);\n        }\n      } else {\n        handleGet(module, scope, n, parent, name);\n      }\n    }", "getNameForObjLitKey": "\n    String getNameForObjLitKey(Node n) {\n      Node parent = n.getParent();\n      Preconditions.checkState(parent.isObjectLit());\n\n      Node gramps = parent.getParent();\n      if (gramps == null) {\n        return null;\n      }\n\n      Node greatGramps = gramps.getParent();\n      String name;\n      switch (gramps.getType()) {\n        case Token.NAME:\n          // VAR\n          //   NAME (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps == null || !greatGramps.isVar()) {\n            return null;\n          }\n          name = gramps.getString();\n          break;\n        case Token.ASSIGN:\n          // ASSIGN (gramps)\n          //   NAME|GETPROP\n          //   OBJLIT (parent)\n          //     STRING (n)\n          Node lvalue = gramps.getFirstChild();\n          name = lvalue.getQualifiedName();\n          break;\n        case Token.STRING_KEY:\n          // OBJLIT\n          //   STRING (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps != null &&\n              greatGramps.isObjectLit()) {\n            name = getNameForObjLitKey(gramps);\n          } else {\n            return null;\n          }\n          break;\n        default:\n          return null;\n      }\n      if (name != null) {\n        String key = n.getString();\n        if (TokenStream.isJSIdentifier(key)) {\n          return name + '.' + key;\n        }\n      }\n      return null;\n    }", "getValueType": "\n    Name.Type getValueType(Node n) {\n      switch (n.getType()) {\n        case Token.OBJECTLIT:\n          return Name.Type.OBJECTLIT;\n        case Token.FUNCTION:\n          return Name.Type.FUNCTION;\n        case Token.OR:\n          // Recurse on the second value. If the first value were an object\n          // literal or function, then the OR would be meaningless and the\n          // second value would be dead code. Assume that if the second value\n          // is an object literal or function, then the first value will also\n          // evaluate to one when it doesn't evaluate to false.\n          return getValueType(n.getLastChild());\n        case Token.HOOK:\n          // The same line of reasoning used for the OR case applies here.\n          Node second = n.getFirstChild().getNext();\n          Name.Type t = getValueType(second);\n          if (t != Name.Type.OTHER) {\n            return t;\n          }\n          Node third = second.getNext();\n          return getValueType(third);\n      }\n      return Name.Type.OTHER;\n    }", "handleSetFromGlobal": "\n    void handleSetFromGlobal(JSModule module, Scope scope,\n        Node n, Node parent, String name,\n        boolean isPropAssign, Name.Type type) {\n      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n        return;\n      }\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(module, scope, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(module, scope, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }", "isTypeDeclaration": "\n    private boolean isTypeDeclaration(Node n, Node parent) {\n      Node valueNode = NodeUtil.getRValueOfLValue(n);\n      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      // Heed the annotations only if they're sensibly used.\n      return info != null && valueNode != null &&\n             (info.isConstructor() && valueNode.isFunction() ||\n              info.isInterface() && valueNode.isFunction() ||\n              info.hasEnumParameterType() && valueNode.isObjectLit());\n    }", "handleSetFromLocal": "\n    void handleSetFromLocal(JSModule module, Scope scope, Node n, Node parent,\n                            String name) {\n      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n        return;\n      }\n\n      Name nameObj = getOrCreateName(name);\n      Ref set = new Ref(module, scope, n, nameObj,\n          Ref.Type.SET_FROM_LOCAL, currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(module, scope, n, nameObj,\n            Ref.Type.ALIASING_GET, currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      }\n    }", "handleGet": "\n    void handleGet(JSModule module, Scope scope,\n        Node n, Node parent, String name) {\n      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n        return;\n      }\n\n      Ref.Type type = Ref.Type.DIRECT_GET;\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.IF:\n          case Token.INSTANCEOF:\n          case Token.TYPEOF:\n          case Token.VOID:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.POS:\n          case Token.NEG:\n            break;\n          case Token.CALL:\n            if (n == parent.getFirstChild()) {\n              // It is a call target\n              type = Ref.Type.CALL_GET;\n            } else if (isClassDefiningCall(parent)) {\n              type = Ref.Type.DIRECT_GET;\n            } else {\n              type = Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.NEW:\n            type = n == parent.getFirstChild()\n                   ? Ref.Type.DIRECT_GET\n                   : Ref.Type.ALIASING_GET;\n            break;\n          case Token.OR:\n          case Token.AND:\n            // This node is x or y in (x||y) or (x&&y). We only know that an\n            // alias is not getting created for this name if the result is used\n            // in a boolean context or assigned to the same name\n            // (e.g. var a = a || {}).\n            type = determineGetTypeForHookOrBooleanExpr(module, scope, parent, name);\n            break;\n          case Token.HOOK:\n            if (n != parent.getFirstChild()) {\n              // This node is y or z in (x?y:z). We only know that an alias is\n              // not getting created for this name if the result is assigned to\n              // the same name (e.g. var a = a ? a : {}).\n              type = determineGetTypeForHookOrBooleanExpr(module, scope, parent, name);\n            }\n            break;\n          case Token.DELPROP:\n            type = Ref.Type.DELETE_PROP;\n            break;\n          default:\n            type = Ref.Type.ALIASING_GET;\n            break;\n        }\n      }\n\n      handleGet(module, scope, n, parent, name, type);\n    }", "isClassDefiningCall": "\n    private boolean isClassDefiningCall(Node callNode) {\n      SubclassRelationship classes =\n          compiler.getCodingConvention().getClassesDefinedByCall(callNode);\n      return classes != null;\n    }", "determineGetTypeForHookOrBooleanExpr": "\n    Ref.Type determineGetTypeForHookOrBooleanExpr(\n        JSModule module, Scope scope, Node parent, String name) {\n      Node prev = parent;\n      for (Node anc : parent.getAncestors()) {\n        switch (anc.getType()) {\n          case Token.INSTANCEOF:\n          case Token.EXPR_RESULT:\n          case Token.VAR:\n          case Token.IF:\n          case Token.WHILE:\n          case Token.FOR:\n          case Token.TYPEOF:\n          case Token.VOID:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.POS:\n          case Token.NEG:\n            return Ref.Type.DIRECT_GET;\n          case Token.HOOK:\n            if (anc.getFirstChild() == prev) {\n              return Ref.Type.DIRECT_GET;\n            }\n            break;\n          case Token.ASSIGN:\n            if (!name.equals(anc.getFirstChild().getQualifiedName())) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.NAME:  // a variable declaration\n            if (!name.equals(anc.getString())) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.CALL:\n            if (anc.getFirstChild() != prev) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.DELPROP:\n            return Ref.Type.DELETE_PROP;\n        }\n        prev = anc;\n      }\n      return Ref.Type.ALIASING_GET;\n    }", "maybeHandlePrototypePrefix": "\n    boolean maybeHandlePrototypePrefix(JSModule module, Scope scope,\n        Node n, Node parent, String name) {\n      // We use a string-based approach instead of inspecting the parse tree\n      // to avoid complexities with object literals, possibly nested, beneath\n      // assignments.\n\n      int numLevelsToRemove;\n      String prefix;\n      if (name.endsWith(\".prototype\")) {\n        numLevelsToRemove = 1;\n        prefix = name.substring(0, name.length() - 10);\n      } else {\n        int i = name.indexOf(\".prototype.\");\n        if (i == -1) {\n          return false;\n        }\n        prefix = name.substring(0, i);\n        numLevelsToRemove = 2;\n        i = name.indexOf('.', i + 11);\n        while (i >= 0) {\n          numLevelsToRemove++;\n          i = name.indexOf('.', i + 1);\n        }\n      }\n\n      if (parent != null && NodeUtil.isObjectLitKey(n)) {\n        // Object literal keys have no prefix that's referenced directly per\n        // key, so we're done.\n        return true;\n      }\n\n      for (int i = 0; i < numLevelsToRemove; i++) {\n        parent = n;\n        n = n.getFirstChild();\n      }\n\n      handleGet(module, scope, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n      return true;\n    }", "isNestedAssign": "\n    boolean isNestedAssign(Node parent) {\n      return parent.isAssign() &&\n             !parent.getParent().isExprResult();\n    }", "getOrCreateName": "\n    Name getOrCreateName(String name) {\n      Name node = nameMap.get(name);\n      if (node == null) {\n        int i = name.lastIndexOf('.');\n        if (i >= 0) {\n          String parentName = name.substring(0, i);\n          Name parent = getOrCreateName(parentName);\n          node = parent.addProperty(name.substring(i + 1), inExterns);\n        } else {\n          node = new Name(name, null, inExterns);\n          globalNames.add(node);\n        }\n        nameMap.put(name, node);\n      }\n      return node;\n    }", "addProperty": "\n    Name addProperty(String name, boolean inExterns) {\n      if (props == null) {\n        props = new ArrayList<Name>();\n      }\n      Name node = new Name(name, this, inExterns);\n      props.add(node);\n      return node;\n    }", "getBaseName": "\n    String getBaseName() {\n      return baseName;\n    }", "getName": "\n    public String getName() {\n      return getFullName();\n    }", "getFullName": "\n    String getFullName() {\n      return parent == null ? baseName : parent.getFullName() + '.' + baseName;\n    }", "getDeclaration": "\n    public Ref getDeclaration() {\n      return declaration;\n    }", "isTypeInferred": "\n    public boolean isTypeInferred() {\n      return false;\n    }", "getType": "\n    public JSType getType() {\n      return null;\n    }", "addRef": "\n    void addRef(Ref ref) {\n      addRefInternal(ref);\n      switch (ref.type) {\n        case SET_FROM_GLOBAL:\n          if (declaration == null) {\n            declaration = ref;\n            docInfo = getDocInfoForDeclaration(ref);\n          }\n          globalSets++;\n          break;\n        case SET_FROM_LOCAL:\n          localSets++;\n          break;\n        case PROTOTYPE_GET:\n        case DIRECT_GET:\n          totalGets++;\n          break;\n        case ALIASING_GET:\n          aliasingGets++;\n          totalGets++;\n          break;\n        case CALL_GET:\n          callGets++;\n          totalGets++;\n          break;\n        case DELETE_PROP:\n          deleteProps++;\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }", "removeRef": "\n    void removeRef(Ref ref) {\n      if (refs != null && refs.remove(ref)) {\n        if (ref == declaration) {\n          declaration = null;\n          if (refs != null) {\n            for (Ref maybeNewDecl : refs) {\n              if (maybeNewDecl.type == Ref.Type.SET_FROM_GLOBAL) {\n                declaration = maybeNewDecl;\n                break;\n              }\n            }\n          }\n        }\n\n        switch (ref.type) {\n          case SET_FROM_GLOBAL:\n            globalSets--;\n            break;\n          case SET_FROM_LOCAL:\n            localSets--;\n            break;\n          case PROTOTYPE_GET:\n          case DIRECT_GET:\n            totalGets--;\n            break;\n          case ALIASING_GET:\n            aliasingGets--;\n            totalGets--;\n            break;\n          case CALL_GET:\n            callGets--;\n            totalGets--;\n            break;\n          case DELETE_PROP:\n            deleteProps--;\n            break;\n          default:\n            throw new IllegalStateException();\n        }\n      }\n    }", "getRefs": "\n    List<Ref> getRefs() {\n      return refs == null ? ImmutableList.<Ref>of() : refs;\n    }", "addRefInternal": "\n    void addRefInternal(Ref ref) {\n      if (refs == null) {\n        refs = Lists.newArrayList();\n      }\n      refs.add(ref);\n    }", "canEliminate": "\n    boolean canEliminate() {\n      if (!canCollapseUnannotatedChildNames() || totalGets > 0) {\n        return false;\n      }\n\n      if (props != null) {\n        for (Name n : props) {\n          if (!n.canCollapse()) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }", "isSimpleStubDeclaration": "\n    boolean isSimpleStubDeclaration() {\n      if (getRefs().size() == 1) {\n        Ref ref = refs.get(0);\n        if (ref.node.getParent() != null &&\n            ref.node.getParent().isExprResult()) {\n          return true;\n        }\n      }\n      return false;\n    }", "canCollapse": "\n    boolean canCollapse() {\n      return !inExterns && !isGetOrSetDefinition() && (declaredType ||\n          (parent == null || parent.canCollapseUnannotatedChildNames()) &&\n          (globalSets > 0 || localSets > 0) &&\n          deleteProps == 0);\n    }", "isGetOrSetDefinition": "\n    boolean isGetOrSetDefinition() {\n      return this.type == Type.GET || this.type == Type.SET;\n    }", "canCollapseUnannotatedChildNames": "\n    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || isGetOrSetDefinition()\n          || globalSets != 1 || localSets != 0 || deleteProps != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (declaredType) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }", "shouldKeepKeys": "\n    boolean shouldKeepKeys() {\n      return type == Type.OBJECTLIT && aliasingGets > 0;\n    }", "needsToBeStubbed": "\n    boolean needsToBeStubbed() {\n      return globalSets == 0 && localSets > 0;\n    }", "setDeclaredType": "\n    void setDeclaredType() {\n      declaredType = true;\n      for (Name ancestor = parent; ancestor != null;\n           ancestor = ancestor.parent) {\n        ancestor.hasDeclaredTypeDescendant = true;\n      }\n    }", "isDeclaredType": "\n    boolean isDeclaredType() {\n      return declaredType;\n    }", "isNamespace": "\n    boolean isNamespace() {\n      return hasDeclaredTypeDescendant && type == Type.OBJECTLIT;\n    }", "isSimpleName": "\n    boolean isSimpleName() {\n      return parent == null;\n    }", "toString": "\n    @Override public String toString() {\n      return getFullName() + \" (\" + type + \"): globalSets=\" + globalSets +\n          \", localSets=\" + localSets + \", totalGets=\" + totalGets +\n          \", aliasingGets=\" + aliasingGets + \", callGets=\" + callGets;\n    }", "getJSDocInfo": "\n    public JSDocInfo getJSDocInfo() {\n      return docInfo;\n    }", "getDocInfoForDeclaration": "\n    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n      if (ref.node != null) {\n        Node refParent = ref.node.getParent();\n        switch (refParent.getType()) {\n          case Token.FUNCTION:\n          case Token.ASSIGN:\n            return refParent.getJSDocInfo();\n          case Token.VAR:\n            return ref.node == refParent.getFirstChild() ?\n                refParent.getJSDocInfo() : ref.node.getJSDocInfo();\n        }\n      }\n\n      return null;\n    }", "getNode": "\n    public Node getNode() {\n      return node;\n    }", "getSourceFile": "\n    public StaticSourceFile getSourceFile() {\n      return source;\n    }", "getSymbol": "\n    public StaticSlot<JSType> getSymbol() {\n      return name;\n    }", "getModule": "\n    JSModule getModule() {\n      return module;\n    }", "getSourceName": "\n    String getSourceName() {\n      return source == null ? \"\" : source.getName();\n    }", "getTwin": "\n    Ref getTwin() {\n      return twin;\n    }", "isSet": "\n    boolean isSet() {\n      return type == Type.SET_FROM_GLOBAL || type == Type.SET_FROM_LOCAL;\n    }", "markTwins": "\n    static void markTwins(Ref a, Ref b) {\n      Preconditions.checkArgument(\n          (a.type == Type.ALIASING_GET || b.type == Type.ALIASING_GET) &&\n          (a.type == Type.SET_FROM_GLOBAL || a.type == Type.SET_FROM_LOCAL ||\n           b.type == Type.SET_FROM_GLOBAL || b.type == Type.SET_FROM_LOCAL));\n      a.twin = b;\n      b.twin = a;\n    }", "cloneAndReclassify": "\n    Ref cloneAndReclassify(Type type) {\n      return new Ref(this, type, this.preOrderIndex);\n    }", "createRefForTesting": "\n    static Ref createRefForTesting(Type type) {\n      return new Ref(type, -1);\n    }"}