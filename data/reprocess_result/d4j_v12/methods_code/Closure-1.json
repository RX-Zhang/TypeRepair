{"process": "\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n    SimpleDefinitionFinder defFinder = null;\n\n    if (modifyCallSites) {\n      // For testing, allow the SimpleDefinitionFinder to be build now.\n      defFinder = new SimpleDefinitionFinder(compiler);\n      defFinder.process(externs, root);\n    }\n    process(externs, root, defFinder);\n  }", "traverseAndRemoveUnusedReferences": "\n  private void traverseAndRemoveUnusedReferences(Node root) {\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n    traverseNode(root, null, scope);\n\n    if (removeGlobals) {\n      collectMaybeUnreferencedVars(scope);\n    }\n\n    interpretAssigns();\n    removeUnreferencedVars();\n    for (Scope fnScope : allFunctionScopes) {\n      removeUnreferencedFunctionArgs(fnScope);\n    }\n  }", "traverseNode": "\n  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    Var var = null;\n    switch (type) {\n      case Token.FUNCTION:\n        // If this function is a removable var, then create a continuation\n        // for it instead of traversing immediately.\n        if (NodeUtil.isFunctionDeclaration(n)) {\n          var = scope.getVar(n.getFirstChild().getString());\n        }\n\n        if (var != null && isRemovableVar(var)) {\n          continuations.put(var, new Continuation(n, scope));\n        } else {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.ASSIGN:\n        Assign maybeAssign = Assign.maybeCreateAssign(n);\n        if (maybeAssign != null) {\n          // Put this in the assign map. It might count as a reference,\n          // but we won't know that until we have an index of all assigns.\n          var = scope.getVar(maybeAssign.nameNode.getString());\n          if (var != null) {\n            assignsByVar.put(var, maybeAssign);\n            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n\n            if (isRemovableVar(var) &&\n                !maybeAssign.mayHaveSecondarySideEffects) {\n              // If the var is unreferenced and performing this assign has\n              // no secondary side effects, then we can create a continuation\n              // for it instead of traversing immediately.\n              continuations.put(var, new Continuation(n, scope));\n              return;\n            }\n          }\n        }\n        break;\n\n      case Token.CALL:\n        Var modifiedVar = null;\n\n        // Look for calls to inheritance-defining calls (such as goog.inherits).\n        SubclassRelationship subclassRelationship =\n            codingConvention.getClassesDefinedByCall(n);\n        if (subclassRelationship != null) {\n          modifiedVar = scope.getVar(subclassRelationship.subclassName);\n        } else {\n          // Look for calls to addSingletonGetter calls.\n          String className = codingConvention.getSingletonGetterClassName(n);\n          if (className != null) {\n            modifiedVar = scope.getVar(className);\n          }\n        }\n\n        // Don't try to track the inheritance calls for non-globals. It would\n        // be more correct to only not track when the subclass does not\n        // reference a constructor, but checking that it is a global is\n        // easier and mostly the same.\n        if (modifiedVar != null && modifiedVar.isGlobal()\n            && !referenced.contains(modifiedVar)) {\n          // Save a reference to the EXPR node.\n          classDefiningCalls.put(modifiedVar, parent);\n          continuations.put(modifiedVar, new Continuation(n, scope));\n          return;\n        }\n        break;\n\n      case Token.NAME:\n        var = scope.getVar(n.getString());\n        if (parent.isVar()) {\n          Node value = n.getFirstChild();\n          if (value != null && var != null && isRemovableVar(var) &&\n              !NodeUtil.mayHaveSideEffects(value, compiler)) {\n            // If the var is unreferenced and creating its value has no side\n            // effects, then we can create a continuation for it instead\n            // of traversing immediately.\n            continuations.put(var, new Continuation(n, scope));\n            return;\n          }\n        } else {\n\n          // If arguments is escaped, we just assume the worst and continue\n          // on all the parameters.\n          if (\"arguments\".equals(n.getString()) && scope.isLocal()) {\n            Node lp = scope.getRootNode().getFirstChild().getNext();\n            for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {\n              markReferencedVar(scope.getVar(a.getString()));\n            }\n          }\n\n          // All name references that aren't declarations or assigns\n          // are references to other vars.\n          if (var != null) {\n            // If that var hasn't already been marked referenced, then\n            // start tracking it.  If this is an assign, do nothing\n            // for now.\n            if (isRemovableVar(var)) {\n              if (!assignsByNode.containsKey(n)) {\n                markReferencedVar(var);\n              }\n            } else {\n              markReferencedVar(var);\n            }\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }", "isRemovableVar": "\n  private boolean isRemovableVar(Var var) {\n    // Global variables are off-limits if the user might be using them.\n    if (!removeGlobals && var.isGlobal()) {\n      return false;\n    }\n\n    // Referenced variables are off-limits.\n    if (referenced.contains(var)) {\n      return false;\n    }\n\n    // Exported variables are off-limits.\n    if (codingConvention.isExported(var.getName())) {\n      return false;\n    }\n\n    return true;\n  }", "traverseFunction": "\n  private void traverseFunction(Node n, Scope parentScope) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node body = n.getLastChild();\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n\n    Scope fnScope =\n        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n    traverseNode(body, n, fnScope);\n\n    collectMaybeUnreferencedVars(fnScope);\n    allFunctionScopes.add(fnScope);\n  }", "collectMaybeUnreferencedVars": "\n  private void collectMaybeUnreferencedVars(Scope scope) {\n    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n      Var var = it.next();\n      if (isRemovableVar(var)) {\n        maybeUnreferenced.add(var);\n      }\n    }\n  }", "removeUnreferencedFunctionArgs": "\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }", "getFunctionArgList": "\n  private static Node getFunctionArgList(Node function) {\n    return function.getFirstChild().getNext();\n  }", "optimize": "\n    public void optimize(Scope fnScope, Set<Var> referenced) {\n      Node function = fnScope.getRootNode();\n      Preconditions.checkState(function.isFunction());\n      Node argList = getFunctionArgList(function);\n\n      // In this path we try to modify all the call sites to remove unused\n      // function parameters.\n      boolean changeCallSignature = canChangeSignature(function);\n      markUnreferencedFunctionArgs(\n          fnScope, function, referenced,\n          argList.getFirstChild(), 0, changeCallSignature);\n    }", "applyChanges": "\n    public void applyChanges() {\n      for (Node n : toRemove) {\n        n.getParent().removeChild(n);\n        compiler.reportCodeChange();\n      }\n      for (Node n : toReplaceWithZero) {\n        n.getParent().replaceChild(n, IR.number(0).srcref(n));\n        compiler.reportCodeChange();\n      }\n    }", "markUnreferencedFunctionArgs": "\n    private boolean markUnreferencedFunctionArgs(\n        Scope scope, Node function, Set<Var> referenced,\n        Node param, int paramIndex,\n        boolean canChangeSignature) {\n      if (param != null) {\n        // Take care of the following siblings first.\n        boolean hasFollowing = markUnreferencedFunctionArgs(\n            scope, function, referenced, param.getNext(), paramIndex+1,\n            canChangeSignature);\n\n        Var var = scope.getVar(param.getString());\n        if (!referenced.contains(var)) {\n          Preconditions.checkNotNull(var);\n\n          // Remove call parameter if we can generally change the signature\n          // or if it is the last parameter in the parameter list.\n          boolean modifyAllCallSites = canChangeSignature || !hasFollowing;\n          if (modifyAllCallSites) {\n            modifyAllCallSites = canRemoveArgFromCallSites(\n                function, paramIndex);\n          }\n\n          tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites);\n\n          // Remove an unused function parameter if all the call sites can\n          // be modified to remove it, or if it is the last parameter.\n          if (modifyAllCallSites || !hasFollowing) {\n            toRemove.add(param);\n            return hasFollowing;\n          }\n        }\n        return true;\n      } else {\n        // Anything past the last formal parameter can be removed from the call\n        // sites.\n        tryRemoveAllFollowingArgs(function, paramIndex-1);\n        return false;\n      }\n    }", "canRemoveArgFromCallSites": "\n    private boolean canRemoveArgFromCallSites(Node function, int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n\n      // Check all the call sites.\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          // TODO(johnlenz): try to remove parameters with side-effects by\n          // decomposing the call expression.\n          if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    }", "tryRemoveArgFromCallSites": "\n    private void tryRemoveArgFromCallSites(\n        Node function, int argIndex, boolean canModifyAllSites) {\n      Definition definition = getFunctionDefinition(function);\n\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          if (arg != null) {\n            Node argParent = arg.getParent();\n            // Even if we can't change the signature in general we can always\n            // remove an unused value off the end of the parameter list.\n            if (canModifyAllSites\n                || (arg.getNext() == null\n                    && !NodeUtil.mayHaveSideEffects(arg, compiler))) {\n              toRemove.add(arg);\n            } else {\n              // replace the node in the arg with 0\n              if (!NodeUtil.mayHaveSideEffects(arg, compiler)\n                  && (!arg.isNumber() || arg.getDouble() != 0)) {\n                toReplaceWithZero.add(arg);\n              }\n            }\n          }\n        }\n      }\n    }", "tryRemoveAllFollowingArgs": "\n    private void tryRemoveAllFollowingArgs(Node function, final int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (!isModifiableCallSite(site)) {\n          continue;\n        }\n        Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1);\n        while (arg != null) {\n          if (!NodeUtil.mayHaveSideEffects(arg)) {\n            toRemove.add(arg);\n          }\n          arg = arg.getNext();\n        }\n      }\n    }", "getArgumentForCallOrNewOrDotCall": "\n    private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex) {\n      int adjustedArgIndex = argIndex;\n      Node parent = site.node.getParent();\n      if (NodeUtil.isFunctionObjectCall(parent)) {\n        adjustedArgIndex++;\n      }\n      return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex);\n    }", "canModifyCallers": "\n    boolean canModifyCallers(Node function) {\n      if (NodeUtil.isVarArgsFunction(function)) {\n        return false;\n      }\n\n      DefinitionSite defSite = defFinder.getDefinitionForFunction(function);\n      if (defSite == null) {\n        return false;\n      }\n\n      Definition definition = defSite.definition;\n\n      // Be conservative, don't try to optimize any declaration that isn't as\n      // simple function declaration or assignment.\n      if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(function)) {\n        return false;\n      }\n\n      return defFinder.canModifyDefinition(definition);\n    }", "isModifiableCallSite": "\n    private static boolean isModifiableCallSite(UseSite site) {\n      return SimpleDefinitionFinder.isCallOrNewSite(site)\n          && !NodeUtil.isFunctionObjectApply(site.node.getParent());\n    }", "canChangeSignature": "\n    private boolean canChangeSignature(Node function) {\n      Definition definition = getFunctionDefinition(function);\n      CodingConvention convention = compiler.getCodingConvention();\n\n      Preconditions.checkState(!definition.isExtern());\n\n      Collection<UseSite> useSites = defFinder.getUseSites(definition);\n      for (UseSite site : useSites) {\n        Node parent = site.node.getParent();\n\n        // This was a use site removed by something else before we run.\n        // 1. By another pass before us which means the definition graph is\n        //    no updated properly.\n        // 2. By the continuations algorithm above.\n        if (parent == null) {\n          continue; // Ignore it.\n        }\n\n        // Ignore references within goog.inherits calls.\n        if (parent.isCall() &&\n            convention.getClassesDefinedByCall(parent) != null) {\n          continue;\n        }\n\n        // Accessing the property directly prevents rewrite.\n        if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n          if (!(parent.isGetProp() &&\n              NodeUtil.isFunctionObjectCall(parent.getParent()))) {\n            return false;\n          }\n        }\n\n        if (NodeUtil.isFunctionObjectApply(parent)) {\n          return false;\n        }\n\n        // TODO(johnlenz): support specialization\n\n        // Multiple definitions prevent rewrite.\n        // Attempt to validate the state of the simple definition finder.\n        Node nameNode = site.node;\n        Collection<Definition> singleSiteDefinitions =\n            defFinder.getDefinitionsReferencedAt(nameNode);\n        Preconditions.checkState(singleSiteDefinitions.size() == 1);\n        Preconditions.checkState(singleSiteDefinitions.contains(definition));\n      }\n\n      return true;\n    }", "getFunctionDefinition": "\n    private Definition getFunctionDefinition(Node function) {\n      DefinitionSite definitionSite = defFinder.getDefinitionForFunction(\n          function);\n      Preconditions.checkNotNull(definitionSite);\n      Definition definition = definitionSite.definition;\n      Preconditions.checkState(!definitionSite.inExterns);\n      Preconditions.checkState(definition.getRValue() == function);\n      return definition;\n    }", "interpretAssigns": "\n  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      // We can't use traditional iterators and iterables for this list,\n      // because our lazily-evaluated continuations will modify it while\n      // we traverse it.\n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().isVar() &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            // This was initialized to a function arg or a catch param\n            // or a for...in variable.\n            assignedToUnknownValue = true;\n          }\n\n          boolean maybeEscaped = false;\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n            } else if (!NodeUtil.isLiteralValue(\n                assign.assignNode.getLastChild(), true)) {\n              assignedToUnknownValue = true;\n            }\n            if (assign.maybeAliased) {\n              maybeEscaped = true;\n            }\n          }\n\n          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }", "removeAllAssigns": "\n  private void removeAllAssigns(Var var) {\n    for (Assign assign : assignsByVar.get(var)) {\n      assign.remove();\n      compiler.reportCodeChange();\n    }\n  }", "markReferencedVar": "\n  private boolean markReferencedVar(Var var) {\n    if (referenced.add(var)) {\n      for (Continuation c : continuations.get(var)) {\n        c.apply();\n      }\n      return true;\n    }\n    return false;\n  }", "removeUnreferencedVars": "\n  private void removeUnreferencedVars() {\n    CodingConvention convention = codingConvention;\n\n    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n      Var var = it.next();\n\n      // Remove calls to inheritance-defining functions where the unreferenced\n      // class is the subclass.\n      for (Node exprCallNode : classDefiningCalls.get(var)) {\n        NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n        compiler.reportCodeChange();\n      }\n\n      // Regardless of what happens to the original declaration,\n      // we need to remove all assigns, because they may contain references\n      // to other unreferenced variables.\n      removeAllAssigns(var);\n\n      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n      Node nameNode = var.nameNode;\n      Node toRemove = nameNode.getParent();\n      Node parent = toRemove.getParent();\n\n      Preconditions.checkState(\n          toRemove.isVar() ||\n          toRemove.isFunction() ||\n          toRemove.isParamList() &&\n          parent.isFunction(),\n          \"We should only declare vars and functions and function args\");\n\n      if (toRemove.isParamList() &&\n          parent.isFunction()) {\n        // Don't remove function arguments here. That's a special case\n        // that's taken care of in removeUnreferencedFunctionArgs.\n      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n        if (!preserveFunctionExpressionNames) {\n          toRemove.getFirstChild().setString(\"\");\n          compiler.reportCodeChange();\n        }\n        // Don't remove bleeding functions.\n      } else if (parent != null &&\n          parent.isFor() &&\n          parent.getChildCount() < 4) {\n        // foreach iterations have 3 children. Leave them alone.\n      } else if (toRemove.isVar() &&\n          nameNode.hasChildren() &&\n          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {\n        // If this is a single var declaration, we can at least remove the\n        // declaration itself and just leave the value, e.g.,\n        // var a = foo(); => foo();\n        if (toRemove.getChildCount() == 1) {\n          parent.replaceChild(toRemove,\n              IR.exprResult(nameNode.removeFirstChild()));\n          compiler.reportCodeChange();\n        }\n      } else if (toRemove.isVar() &&\n          toRemove.getChildCount() > 1) {\n        // For var declarations with multiple names (i.e. var a, b, c),\n        // only remove the unreferenced name\n        toRemove.removeChild(nameNode);\n        compiler.reportCodeChange();\n      } else if (parent != null) {\n        NodeUtil.removeChild(parent, toRemove);\n        compiler.reportCodeChange();\n      }\n    }\n  }", "apply": "\n    void apply() {\n      if (NodeUtil.isFunctionDeclaration(node)) {\n        traverseFunction(node, scope);\n      } else {\n        for (Node child = node.getFirstChild();\n             child != null; child = child.getNext()) {\n          traverseNode(child, node, scope);\n        }\n      }\n    }", "maybeCreateAssign": "\n    static Assign maybeCreateAssign(Node assignNode) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n\n      // Skip one level of GETPROPs or GETELEMs.\n      //\n      // Don't skip more than one level, because then we get into\n      // situations where assigns to properties of properties will always\n      // trigger side-effects, and the variable they're on cannot be removed.\n      boolean isPropAssign = false;\n      Node current = assignNode.getFirstChild();\n      if (NodeUtil.isGet(current)) {\n        current = current.getFirstChild();\n        isPropAssign = true;\n\n        if (current.isGetProp() &&\n            current.getLastChild().getString().equals(\"prototype\")) {\n          // Prototype properties sets should be considered like normal\n          // property sets.\n          current = current.getFirstChild();\n        }\n      }\n\n      if (current.isName()) {\n        return new Assign(assignNode, current, isPropAssign);\n      }\n      return null;\n    }", "remove": "\n    void remove() {\n      Node parent = assignNode.getParent();\n      if (mayHaveSecondarySideEffects) {\n        Node replacement = assignNode.getLastChild().detachFromParent();\n\n        // Aggregate any expressions in GETELEMs.\n        for (Node current = assignNode.getFirstChild();\n             !current.isName();\n             current = current.getFirstChild()) {\n          if (current.isGetElem()) {\n            replacement = IR.comma(\n                current.getLastChild().detachFromParent(), replacement);\n            replacement.copyInformationFrom(current);\n          }\n        }\n\n        parent.replaceChild(assignNode, replacement);\n      } else {\n        Node gramps = parent.getParent();\n        if (parent.isExprResult()) {\n          gramps.removeChild(parent);\n        } else {\n          parent.replaceChild(assignNode,\n              assignNode.getLastChild().detachFromParent());\n        }\n      }\n    }"}