{"process": "\n  public void process(Node externRoot, Node root) {\n    if (!canModifyExterns) {\n      NodeTraversal.traverse(compiler, externRoot,\n          new ProcessExternProperties());\n    }\n\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\n\n    FixedPointGraphTraversal<NameInfo, JSModule> t =\n        FixedPointGraphTraversal.newTraversal(new PropagateReferences());\n    t.computeFixedPoint(symbolGraph,\n        Sets.newHashSet(externNode, globalNode));\n  }", "getAllNameInfo": "\n  public Collection<NameInfo> getAllNameInfo() {\n    List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values());\n    result.addAll(varNameInfo.values());\n    return result;\n  }", "getNameInfoForName": "\n  private NameInfo getNameInfoForName(String name, SymbolType type) {\n    Map<String, NameInfo> map = type == PROPERTY ?\n        propertyNameInfo : varNameInfo;\n    if (map.containsKey(name)) {\n      return map.get(name);\n    } else {\n      NameInfo nameInfo = new NameInfo(name);\n      map.put(name, nameInfo);\n      symbolGraph.createNode(nameInfo);\n      return nameInfo;\n    }\n  }", "enterScope": "\n    public void enterScope(NodeTraversal t) {\n      symbolStack.peek().scope = t.getScope();\n    }", "exitScope": "\n    public void exitScope(NodeTraversal t) {\n\n    }", "shouldTraverse": "\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (isPrototypePropertyAssign(n)) {\n        symbolStack.push(new NameContext(getNameInfoForName(\n                n.getFirstChild().getLastChild().getString(), PROPERTY)));\n      } else if (isGlobalFunctionDeclaration(t, n)) {\n        String name = parent.getType() == Token.NAME ?\n            parent.getString() /* VAR */ :\n            n.getFirstChild().getString() /* named function */;\n        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n      } else if (NodeUtil.isFunction(n)) {\n        symbolStack.push(new NameContext(anonymousNode));\n      }\n      return true;\n    }", "visit": "\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.GETPROP) {\n        String propName = n.getFirstChild().getNext().getString();\n        if (propName.equals(\"prototype\")) {\n          processPrototypeParent(t, parent);\n        } else if (compiler.getCodingConvention().isExported(propName)) {\n          addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n        } else {\n          addSymbolUse(propName, t.getModule(), PROPERTY);\n        }\n      } else if (n.getType() == Token.OBJECTLIT &&\n          // Make sure that we're not handling object literals being\n          // assigned to a prototype, as in:\n          // Foo.prototype = {bar: 3, baz: 5};\n          !(parent.getType() == Token.ASSIGN &&\n            parent.getFirstChild().getType() == Token.GETPROP &&\n            parent.getFirstChild().getLastChild().getString().equals(\n                \"prototype\"))) {\n        // var x = {a: 1, b: 2}\n        // should count as a use of property a and b.\n        for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n             propNameNode = propNameNode.getNext()) {\n          // May be STRING, GET, or SET, but NUMBER isn't interesting.\n          if (!propNameNode.isQuotedString()) {\n            addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n          }\n        }\n      } else if (n.getType() == Token.NAME) {\n        String name = n.getString();\n\n        Var var = t.getScope().getVar(name);\n        if (var != null) {\n          // Only process global functions.\n          if (var.isGlobal()) {\n            if (var.getInitialValue() != null &&\n                var.getInitialValue().getType() == Token.FUNCTION) {\n              if (t.inGlobalScope()) {\n                if (!processGlobalFunctionDeclaration(t, n, parent,\n                        parent.getParent())) {\n                  addGlobalUseOfSymbol(name, t.getModule(), VAR);\n                }\n              } else {\n                addSymbolUse(name, t.getModule(), VAR);\n              }\n            }\n\n          // If it is not a global, it might be accessing a local of the outer\n          // scope. If that's the case the functions between the variable's\n          // declaring scope and the variable reference scope cannot be moved.\n          } else if (var.getScope() != t.getScope()){\n            for (int i = symbolStack.size() - 1; i >= 0; i--) {\n              NameContext context = symbolStack.get(i);\n              context.name.readClosureVariables = true;\n              if (context.scope == var.getScope()) {\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (isPrototypePropertyAssign(n) ||\n          isGlobalFunctionDeclaration(t, n) ||\n          NodeUtil.isFunction(n)) {\n        symbolStack.pop();\n      }\n    }", "addSymbolUse": "\n    private void addSymbolUse(String name, JSModule module, SymbolType type) {\n      NameInfo info = getNameInfoForName(name, type);\n      NameInfo def = null;\n      // Skip all anonymous nodes. We care only about symbols with names.\n      for (int i = symbolStack.size() - 1; i >= 0; i--) {\n        def = symbolStack.get(i).name;\n        if (def != anonymousNode) {\n          break;\n        }\n      }\n      if (!def.equals(info)) {\n        symbolGraph.connect(def, module, info);\n      }\n    }", "isGlobalFunctionDeclaration": "\n    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n      return t.inGlobalScope() &&\n          (NodeUtil.isFunctionDeclaration(n) ||\n           n.getType() == Token.FUNCTION &&\n           n.getParent().getType() == Token.NAME);\n    }", "isPrototypePropertyAssign": "\n    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n          ) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }", "processGlobalFunctionDeclaration": "\n    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n      Node firstChild = nameNode.getFirstChild();\n\n      if (// Check for a named FUNCTION.\n          isGlobalFunctionDeclaration(t, parent) ||\n          // Check for a VAR declaration.\n          firstChild != null &&\n          isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(\n            new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) ||\n            anchorUnusedVars) {\n          addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n\n        return true;\n      }\n      return false;\n    }", "processPrototypeParent": "\n    private void processPrototypeParent(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n          Node dest = n.getFirstChild().getNext();\n          Node parent = n.getParent();\n          Node grandParent = parent.getParent();\n\n          if (dest.getType() == Token.STRING &&\n              NodeUtil.isExprAssign(grandParent) &&\n              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n            String name = dest.getString();\n            Property prop = new AssignmentProperty(grandParent, t.getModule());\n            getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n          }\n          break;\n\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n          Node map = n.getFirstChild().getNext();\n          if (map.getType() == Token.OBJECTLIT) {\n            for (Node key = map.getFirstChild();\n                 key != null; key = key.getNext()) {\n              // May be STRING, GET, or SET,\n              String name = key.getString();\n              Property prop = new LiteralProperty(\n                  key, key.getFirstChild(), map, n, t.getModule());\n              getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n            }\n          }\n          break;\n      }\n    }", "addGlobalUseOfSymbol": "\n    private void addGlobalUseOfSymbol(String name, JSModule module,\n        SymbolType type) {\n      symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));\n    }", "traverseEdge": "\n    public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n      if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null &&\n            moduleGraph.dependsOn(startModule, edge)) {\n          return dest.markReference(startModule);\n        } else {\n          return dest.markReference(edge);\n        }\n      }\n      return false;\n    }", "remove": "\n    public void remove() {\n      Node parent = nameNode.getParent();\n      if (parent.getType() == Token.FUNCTION || parent.hasOneChild()) {\n        NodeUtil.removeChild(parent.getParent(), parent);\n      } else {\n        Preconditions.checkState(parent.getType() == Token.VAR);\n        parent.removeChild(nameNode);\n      }\n    }", "getModule": "\n    public JSModule getModule() {\n      return module;\n    }", "getFunctionNode": "\n    public Node getFunctionNode() {\n      Node parent = nameNode.getParent();\n\n      if (NodeUtil.isFunction(parent)) {\n        return parent;\n      } else {\n        // we are the name of a var node, so the function is name's second child\n        return nameNode.getChildAtIndex(1);\n      }\n    }", "getPrototype": "\n    public Node getPrototype() {\n      return getAssignNode().getFirstChild().getFirstChild();\n    }", "getValue": "\n    public Node getValue() {\n      return getAssignNode().getLastChild();\n    }", "getAssignNode": "\n    private Node getAssignNode() {\n      return exprNode.getFirstChild();\n    }", "toString": "\n    @Override public String toString() { return name; }", "isReferenced": "\n    boolean isReferenced() {\n      return referenced;\n    }", "readsClosureVariables": "\n    boolean readsClosureVariables() {\n      return readClosureVariables;\n    }", "markReference": "\n    boolean markReference(JSModule module) {\n      boolean hasChanged = false;\n      if (!referenced) {\n        referenced = true;\n        hasChanged = true;\n      }\n\n      if (moduleGraph != null) {\n        JSModule originalDeepestCommon = deepestCommonModuleRef;\n\n        if (deepestCommonModuleRef == null) {\n          deepestCommonModuleRef = module;\n        } else {\n          deepestCommonModuleRef =\n              moduleGraph.getDeepestCommonDependencyInclusive(\n                  deepestCommonModuleRef, module);\n        }\n\n        if (originalDeepestCommon != deepestCommonModuleRef) {\n          hasChanged = true;\n        }\n      }\n\n      return hasChanged;\n    }", "getDeepestCommonModuleRef": "\n    JSModule getDeepestCommonModuleRef() {\n      return deepestCommonModuleRef;\n    }", "getDeclarations": "\n    Deque<Symbol> getDeclarations() {\n      return declarations;\n    }"}