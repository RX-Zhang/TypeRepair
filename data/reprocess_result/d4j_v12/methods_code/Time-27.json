{"toFormatter": "\n    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }", "toPrinter": "\n    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }", "toParser": "\n    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }", "clear": "\n    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }", "append": "\n    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }", "appendLiteral": "\n    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }", "minimumPrintedDigits": "\n    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }", "maximumParsedDigits": "\n    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }", "rejectSignedValues": "\n    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }", "printZeroRarelyLast": "\n    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }", "printZeroRarelyFirst": "\n    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }", "printZeroIfSupported": "\n    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }", "printZeroAlways": "\n    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }", "printZeroNever": "\n    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }", "appendPrefix": "\n    public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }", "appendYears": "\n    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }", "appendMonths": "\n    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }", "appendWeeks": "\n    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }", "appendDays": "\n    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }", "appendHours": "\n    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }", "appendMinutes": "\n    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }", "appendSeconds": "\n    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }", "appendSecondsWithMillis": "\n    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }", "appendSecondsWithOptionalMillis": "\n    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }", "appendMillis": "\n    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }", "appendMillis3Digit": "\n    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }", "appendField": "\n    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }", "appendSuffix": "\n    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }", "appendSeparator": "\n    public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }", "appendSeparatorIfFieldsAfter": "\n    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }", "appendSeparatorIfFieldsBefore": "\n    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }", "clearPrefix": "\n    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }", "append0": "\n    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }", "createComposite": "\n    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }", "calculatePrintedLength": "\n        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }", "printTo": "\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }", "parse": "\n        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }", "scan": "\n        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }", "countFieldsToPrint": "\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }", "parseInto": "\n        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }", "parseInt": "\n        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }", "getFieldValue": "\n        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }", "isZero": "\n        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }", "isSupported": "\n        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }", "setFieldValue": "\n        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }", "getFieldType": "\n        int getFieldType() {\n            return iFieldType;\n        }", "finish": "\n        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }", "decompose": "\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }", "addArrayToList": "\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }"}