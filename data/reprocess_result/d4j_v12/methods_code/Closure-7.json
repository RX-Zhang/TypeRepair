{"append": "\n  public ChainableReverseAbstractInterpreter append(\n      ChainableReverseAbstractInterpreter lastLink) {\n    Preconditions.checkArgument(lastLink.nextLink == null);\n    this.nextLink = lastLink;\n    lastLink.firstLink = this.firstLink;\n    return lastLink;\n  }", "getFirst": "\n  public ChainableReverseAbstractInterpreter getFirst() {\n    return firstLink;\n  }", "firstPreciserScopeKnowingConditionOutcome": "\n  protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    return firstLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }", "nextPreciserScopeKnowingConditionOutcome": "\n  protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome) : blindScope;\n  }", "getTypeIfRefinable": "\n  protected JSType getTypeIfRefinable(Node node, FlowScope scope) {\n    switch (node.getType()) {\n      case Token.NAME:\n        StaticSlot<JSType> nameVar = scope.getSlot(node.getString());\n        if (nameVar != null) {\n          JSType nameVarType = nameVar.getType();\n          if (nameVarType == null) {\n            nameVarType = node.getJSType();\n          }\n          return nameVarType;\n        }\n        return null;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        if (qualifiedName == null) {\n          return null;\n        }\n        StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);\n        JSType propVarType = null;\n        if (propVar != null) {\n          propVarType = propVar.getType();\n        }\n        if (propVarType == null) {\n          propVarType = node.getJSType();\n        }\n        if (propVarType == null) {\n          propVarType = getNativeType(UNKNOWN_TYPE);\n        }\n        return propVarType;\n    }\n    return null;\n  }", "declareNameInScope": "\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        // \"this\" references aren't currently modeled in the CFG.\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }", "caseTopType": "\n    protected abstract JSType caseTopType(JSType topType);\n\n    @Override\n    public JSType caseAllType() {\n      return caseTopType(getNativeType(ALL_TYPE));\n    }", "caseAllType": "\n    public JSType caseAllType() {\n      return caseTopType(getNativeType(ALL_TYPE));\n    }", "caseUnknownType": "\n    public JSType caseUnknownType() {\n      return caseTopType(getNativeType(CHECKED_UNKNOWN_TYPE));\n    }", "caseUnionType": "\n    public JSType caseUnionType(UnionType type) {\n      JSType restricted = null;\n      for (JSType alternate : type.getAlternates()) {\n        JSType restrictedAlternate = alternate.visit(this);\n        if (restrictedAlternate != null) {\n          if (restricted == null) {\n            restricted = restrictedAlternate;\n          } else {\n            restricted = restrictedAlternate.getLeastSupertype(restricted);\n          }\n        }\n      }\n      return restricted;\n    }", "caseNoType": "\n    public JSType caseNoType() {\n      return getNativeType(NO_TYPE);\n    }", "caseEnumElementType": "\n    public JSType caseEnumElementType(EnumElementType enumElementType) {\n      // NOTE(nicksantos): This is a white lie. Suppose we have:\n      // /** @enum {string|number} */ var MyEnum = ...;\n      // if (goog.isNumber(myEnumInstance)) {\n      //   /* what is myEnumInstance here? */\n      // }\n      // There is no type that represents {MyEnum - string}. What we really\n      // need is a notion of \"enum subtyping\", so that we could dynamically\n      // create a subtype of MyEnum restricted by string. In any case,\n      // this should catch the common case.\n      JSType type = enumElementType.getPrimitiveType().visit(this);\n      if (type != null &&\n          enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n        return enumElementType;\n      } else {\n        return type;\n      }\n    }", "caseParameterizedType": "\n    public JSType caseParameterizedType(ParameterizedType type) {\n      return caseObjectType(type);\n    }", "caseTemplateType": "\n    public JSType caseTemplateType(TemplateType templateType) {\n      return caseObjectType(templateType);\n    }", "caseNoObjectType": "\n    public JSType caseNoObjectType() {\n      return null;\n    }", "caseBooleanType": "\n    public JSType caseBooleanType() {\n      return null;\n    }", "caseFunctionType": "\n    public JSType caseFunctionType(FunctionType type) {\n      return null;\n    }", "caseNullType": "\n    public JSType caseNullType() {\n      return null;\n    }", "caseNumberType": "\n    public JSType caseNumberType() {\n      return null;\n    }", "caseObjectType": "\n    public JSType caseObjectType(ObjectType type) {\n      return null;\n    }", "caseStringType": "\n    public JSType caseStringType() {\n      return null;\n    }", "caseVoidType": "\n    public JSType caseVoidType() {\n      return null;\n    }", "matchesExpectation": "\n    private boolean matchesExpectation(String result) {\n      return result.equals(value) == resultEqualsValue;\n    }", "getRestrictedWithoutUndefined": "\n  protected final JSType getRestrictedWithoutUndefined(JSType type) {\n    return type == null ? null : type.visit(restrictUndefinedVisitor);\n  }", "getRestrictedWithoutNull": "\n  protected final JSType getRestrictedWithoutNull(JSType type) {\n    return type == null ? null : type.visit(restrictNullVisitor);\n  }", "getRestrictedByTypeOfResult": "\n  JSType getRestrictedByTypeOfResult(JSType type, String value,\n                                     boolean resultEqualsValue) {\n    if (type == null) {\n      if (resultEqualsValue) {\n        JSType result = getNativeTypeForTypeOf(value);\n        return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result;\n      } else {\n        return null;\n      }\n    }\n    return type.visit(\n        new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));\n  }", "getNativeType": "\n  JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }", "getNativeTypeForTypeOf": "\n  private JSType getNativeTypeForTypeOf(String value) {\n    if (value.equals(\"number\")) {\n      return getNativeType(NUMBER_TYPE);\n    } else if (value.equals(\"boolean\")) {\n      return getNativeType(BOOLEAN_TYPE);\n    } else if (value.equals(\"string\")) {\n      return getNativeType(STRING_TYPE);\n    } else if (value.equals(\"undefined\")) {\n      return getNativeType(VOID_TYPE);\n    } else if (value.equals(\"function\")) {\n      return getNativeType(U2U_CONSTRUCTOR_TYPE);\n    } else {\n      return null;\n    }\n  }"}