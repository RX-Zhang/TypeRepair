{"getCfg": "\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }", "process": "\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }", "prioritizeFromEntryNode": "\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }", "shouldTraverse": "\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }", "visit": "\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }", "handleIf": "\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node, this)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }", "handleWhile": "\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }", "handleDo": "\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }", "handleFor": "\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The collection behaves like init.\n      createEdge(collection, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }", "handleSwitch": "\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }", "handleCase": "\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.isCase());\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT_CASE);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }", "handleDefault": "\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }", "handleWith": "\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }", "handleStmtList": "\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }", "handleFunction": "\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }", "handleExpr": "\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }", "handleThrow": "\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }", "handleTry": "\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }", "handleCatch": "\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }", "handleBreak": "\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      if (parent == null) {\n        if (compiler.isIdeMode()) {\n          // In IDE mode, we expect that the data flow graph may\n          // not be well-formed.\n          return;\n        } else {\n          throw new IllegalStateException(\"Cannot find break target.\");\n        }\n      }\n      previous = cur;\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur, this));\n    }\n  }", "handleContinue": "\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n      previous = cur;\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }", "handleReturn": "\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }", "handleStmt": "\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }", "computeFollowNode": "\n  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }", "computeFallThrough": "\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }", "createEdge": "\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }", "connectToPossibleExceptionHandler": "\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }", "getNextSiblingOfType": "\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }", "isBreakTarget": "\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }", "isContinueTarget": "\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }", "matchLabel": "\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.isLabel()) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }", "mayThrowException": "\n  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }", "isBreakStructure": "\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }", "isContinueStructure": "\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }", "getExceptionHandler": "\n  static Node getExceptionHandler(Node n) {\n    for (Node cur = n;\n        !cur.isScript() && !cur.isFunction();\n        cur = cur.getParent()) {\n      Node catchNode = getCatchHandlerForBlock(cur);\n      if (catchNode != null) {\n        return catchNode;\n      }\n    }\n    return null;\n  }", "getCatchHandlerForBlock": "\n  static Node getCatchHandlerForBlock(Node block) {\n    if (block.isBlock() &&\n        block.getParent().isTry() &&\n        block.getParent().getFirstChild() == block) {\n      for (Node s = block.getNext(); s != null; s = s.getNext()) {\n        if (NodeUtil.hasCatchHandler(s)) {\n          return s.getFirstChild();\n        }\n      }\n    }\n    return null;\n  }", "getOptionalNodeComparator": "\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }", "getPosition": "\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }"}