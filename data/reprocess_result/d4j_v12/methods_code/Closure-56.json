{"getLineOffset": "\n  public int getLineOffset(int lineno) {\n    if (lineOffsets == null) {\n      findLineOffsets();\n    }\n    if (lineno < 1 || lineno > lineOffsets.length) {\n      throw new IllegalArgumentException(\n          \"Expected line number between 1 and \" + lineOffsets.length +\n          \"\\nActual: \" + lineno);\n    }\n    return lineOffsets[lineno - 1];\n  }", "getNumLines": "\n  int getNumLines() {\n    if (lineOffsets == null) {\n      findLineOffsets();\n    }\n    return lineOffsets.length;\n  }", "findLineOffsets": "\n  private void findLineOffsets() {\n    try {\n      String[] sourceLines = getCode().split(\"\\n\");\n      lineOffsets = new int[sourceLines.length];\n      for (int ii = 1; ii < sourceLines.length; ++ii) {\n        lineOffsets[ii] =\n            lineOffsets[ii - 1] + sourceLines[ii - 1].length() + 1;\n      }\n    } catch (IOException e) {\n      lineOffsets = new int[1];\n      lineOffsets[0] = 0;\n    }\n  }", "getCode": "\n  public String getCode() throws IOException {\n    return code;\n  }", "getCodeReader": "\n  public Reader getCodeReader() throws IOException {\n    return new StringReader(getCode());\n  }", "getCodeNoCache": "\n  String getCodeNoCache() {\n    return code;\n  }", "setCode": "\n  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }", "getOriginalPath": "\n  public String getOriginalPath() {\n    return originalPath != null ? originalPath : fileName;\n  }", "setOriginalPath": "\n  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }", "clearCachedSource": "\n  public void clearCachedSource() {\n    // By default, do nothing.  Not all kinds of SourceFiles can regenerate\n    // code.\n  }", "hasSourceInMemory": "\n  boolean hasSourceInMemory() {\n    return code != null;\n  }", "getName": "\n  public String getName() {\n    return fileName;\n  }", "isExtern": "\n  public boolean isExtern() {\n    return isExternFile;\n  }", "setIsExtern": "\n  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }", "getLine": "\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "getRegion": "\n  public Region getRegion(int lineNumber) {\n    String js = \"\";\n    try {\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n    int pos = 0;\n    int startLine = Math.max(1,\n        lineNumber - (SOURCE_EXCERPT_REGION_LENGTH + 1) / 2 + 1);\n    for (int n = 1; n < startLine; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        break;\n      }\n      pos = nextpos + 1;\n    }\n    int end = pos;\n    int endLine = startLine;\n    for (int n = 0; n < SOURCE_EXCERPT_REGION_LENGTH; n++, endLine++) {\n      end = js.indexOf('\\n', end);\n      if (end == -1) {\n        break;\n      }\n      end++;\n    }\n    if (lineNumber >= endLine) {\n      return null;\n    }\n    if (end == -1) {\n      int last = js.length() - 1;\n      if (js.charAt(last) == '\\n') {\n        return\n            new SimpleRegion(startLine, endLine, js.substring(pos, last));\n      } else {\n        return new SimpleRegion(startLine, endLine, js.substring(pos));\n      }\n    } else {\n      return new SimpleRegion(startLine, endLine, js.substring(pos, end));\n    }\n  }", "toString": "\n  public String toString() {\n    return fileName;\n  }", "fromFile": "\n  public static SourceFile fromFile(String fileName, Charset c) {\n    return fromFile(new File(fileName), c);\n  }", "fromCode": "\n  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }", "fromInputStream": "\n  public static SourceFile fromInputStream(String fileName, InputStream s)\n      throws IOException {\n    return fromCode(fileName,\n        CharStreams.toString(new InputStreamReader(s, Charsets.UTF_8)));\n  }", "fromReader": "\n  public static SourceFile fromReader(String fileName, Reader r)\n      throws IOException {\n    return fromCode(fileName, CharStreams.toString(r));\n  }", "fromGenerator": "\n  public static SourceFile fromGenerator(String fileName,\n      Generator generator) {\n    return new Generated(fileName, generator);\n  }", "setCharset": "\n    public void setCharset(Charset c) {\n      inputCharset = c.name();\n    }", "getCharset": "\n    public Charset getCharset() {\n      return Charset.forName(inputCharset);\n    }"}