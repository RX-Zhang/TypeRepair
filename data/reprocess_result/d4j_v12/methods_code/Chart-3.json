{"getDomainDescription": "\n    public String getDomainDescription() {\n        return this.domain;\n    }", "setDomainDescription": "\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }", "getRangeDescription": "\n    public String getRangeDescription() {\n        return this.range;\n    }", "setRangeDescription": "\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }", "getItemCount": "\n    public int getItemCount() {\n        return this.data.size();\n    }", "getItems": "\n    public List getItems() {\n        // FIXME: perhaps we should clone the data list\n        return Collections.unmodifiableList(this.data);\n    }", "getMaximumItemCount": "\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }", "setMaximumItemCount": "\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }", "getMaximumItemAge": "\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }", "setMaximumItemAge": "\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }", "getMinY": "\n    public double getMinY() {\n        return this.minY;\n    }", "getMaxY": "\n    public double getMaxY() {\n        return this.maxY;\n    }", "getTimePeriodClass": "\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }", "getDataItem": "\n    public TimeSeriesDataItem getDataItem(int index) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        return (TimeSeriesDataItem) item.clone();\n    }", "getRawDataItem": "\n    TimeSeriesDataItem getRawDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }", "getTimePeriod": "\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getRawDataItem(index).getPeriod();\n    }", "getNextTimePeriod": "\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }", "getTimePeriods": "\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }", "getTimePeriodsUniqueToOtherSeries": "\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n    }", "getIndex": "\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }", "getValue": "\n    public Number getValue(int index) {\n        return getRawDataItem(index).getValue();\n    }", "add": "\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }", "update": "\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index < 0) {\n            throw new SeriesException(\"There is no existing value for the \"\n                    + \"specified 'period'.\");\n        }\n        update(index, value);\n    }", "addAndOrUpdate": "\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getRawDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }", "addOrUpdate": "\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }", "removeAgedItems": "\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history\n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed) {\n                findBoundsByIteration();\n                if (notify) {\n                    fireSeriesChanged();\n                }\n            }\n        }\n    }", "clear": "\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            this.timePeriodClass = null;\n            this.minY = Double.NaN;\n            this.maxY = Double.NaN;\n            fireSeriesChanged();\n        }\n    }", "delete": "\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.remove(\n                    index);\n            updateBoundsForRemovedItem(item);\n            if (this.data.isEmpty()) {\n                this.timePeriodClass = null;\n            }\n            fireSeriesChanged();\n        }\n    }", "clone": "\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }", "createCopy": "\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }", "equals": "\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                that.getRangeDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.timePeriodClass,\n                that.timePeriodClass)) {\n            return false;\n        }\n        if (getMaximumItemAge() != that.getMaximumItemAge()) {\n            return false;\n        }\n        if (getMaximumItemCount() != that.getMaximumItemCount()) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return super.equals(obj);\n    }", "hashCode": "\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getRawDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getRawDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getRawDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }", "updateBoundsForAddedItem": "\n    private void updateBoundsForAddedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (item.getValue() != null) {\n            double y = yN.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, y);\n            this.maxY = maxIgnoreNaN(this.maxY, y);\n        }\n    }", "updateBoundsForRemovedItem": "\n    private void updateBoundsForRemovedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (yN != null) {\n            double y = yN.doubleValue();\n            if (!Double.isNaN(y)) {\n                if (y <= this.minY || y >= this.maxY) {\n                    findBoundsByIteration();\n                }\n            }\n        }\n    }", "findBoundsByIteration": "\n    private void findBoundsByIteration() {\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) iterator.next();\n            updateBoundsForAddedItem(item);\n        }\n    }", "minIgnoreNaN": "\n    private double minIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.min(a, b);\n            }\n        }\n    }", "maxIgnoreNaN": "\n    private double maxIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.max(a, b);\n            }\n        }\n    }"}