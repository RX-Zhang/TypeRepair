{"getDefault": "\n    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }", "setDefault": "\n    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }", "forID": "\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }", "forOffsetHours": "\n    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }", "forOffsetHoursMinutes": "\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }", "forOffsetMillis": "\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }", "forTimeZone": "\n    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }", "fixedOffsetZone": "\n    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }", "getAvailableIDs": "\n    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }", "getProvider": "\n    public static Provider getProvider() {\n        return cProvider;\n    }", "setProvider": "\n    public static void setProvider(Provider provider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n        }\n        setProvider0(provider);\n    }", "setProvider0": "\n    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }", "getDefaultProvider": "\n    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }", "getNameProvider": "\n    public static NameProvider getNameProvider() {\n        return cNameProvider;\n    }", "setNameProvider": "\n    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n        }\n        setNameProvider0(nameProvider);\n    }", "setNameProvider0": "\n    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }", "getDefaultNameProvider": "\n    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }", "getConvertedId": "\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }", "parseOffset": "\n    private static int parseOffset(String str) {\n        // Can't use a real chronology if called during class\n        // initialization. Offset parser doesn't need it anyhow.\n        Chronology chrono = new BaseChronology() {\n            public DateTimeZone getZone() {\n                return null;\n            }\n            public Chronology withUTC() {\n                return this;\n            }\n            public Chronology withZone(DateTimeZone zone) {\n                return this;\n            }\n            public String toString() {\n                return getClass().getName();\n            }\n        };\n        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n    }", "printOffset": "\n    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }", "offsetFormatter": "\n    private static synchronized DateTimeFormatter offsetFormatter() {\n        if (cOffsetFormatter == null) {\n            cOffsetFormatter = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(null, true, 2, 4)\n                .toFormatter();\n        }\n        return cOffsetFormatter;\n    }", "getID": "\n    public final String getID() {\n        return iID;\n    }", "getNameKey": "\n    public abstract String getNameKey(long instant);\n\n    /**\n     * Gets the short name of this datetime zone suitable for display using\n     * the default locale.\n     * <p>\n     * If the name is not available for the locale, then this method returns a\n     * string in the format <code>[+-]hh:mm</code>.\n     * \n     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n     * @return the human-readable short name in the default locale\n     */\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }", "getShortName": "\n    public final String getShortName(long instant) {\n        return getShortName(instant, null);\n    }", "getName": "\n    public final String getName(long instant) {\n        return getName(instant, null);\n    }", "getOffset": "\n    public abstract int getOffset(long instant);\n\n    /**\n     * Gets the millisecond offset to add to UTC to get local time.\n     * \n     * @param instant  instant to get the offset for, null means now\n     * @return the millisecond offset to add to UTC to get local time\n     */\n    public final int getOffset(ReadableInstant instant) {\n        if (instant == null) {\n            return getOffset(DateTimeUtils.currentTimeMillis());\n        }\n        return getOffset(instant.getMillis());\n    }", "getStandardOffset": "\n    public abstract int getStandardOffset(long instant);\n\n    /**\n     * Checks whether, at a particular instant, the offset is standard or not.\n     * <p>\n     * This method can be used to determine whether Summer Time (DST) applies.\n     * As a general rule, if the offset at the specified instant is standard,\n     * then either Winter time applies, or there is no Summer Time. If the\n     * instant is not standard, then Summer Time applies.\n     * <p>\n     * The implementation of the method is simply whether {@link #getOffset(long)}", "isStandardOffset": "\n    public boolean isStandardOffset(long instant) {\n        return getOffset(instant) == getStandardOffset(instant);\n    }", "getOffsetFromLocal": "\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "convertUTCToLocal": "\n    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }", "convertLocalToUTC": "\n    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }", "getMillisKeepLocal": "\n    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }", "isLocalDateTimeGap": "\n    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n        if (isFixed()) {\n            return false;\n        }\n        try {\n            localDateTime.toDateTime(this);\n            return false;\n        } catch (IllegalArgumentException ex) {\n            return true;\n        }\n    }", "adjustOffset": "\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (before == after) {\n            return instant;\n        }\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? after : before);\n    }", "isFixed": "\n    public abstract boolean isFixed();\n\n    /**\n     * Advances the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur after the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.", "nextTransition": "\n    public abstract long nextTransition(long instant);\n\n    /**\n     * Retreats the given instant to where the time zone offset or name changes.\n     * If the instant returned is exactly the same as passed in, then\n     * no changes occur before the given instant.\n     *\n     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n     * @return milliseconds from 1970-01-01T00:00:00Z\n     */\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.", "previousTransition": "\n    public abstract long previousTransition(long instant);\n\n    // Basic methods\n    //--------------------------------------------------------------------\n\n    /**\n     * Get the datetime zone as a {@link java.util.TimeZone}.", "toTimeZone": "\n    public java.util.TimeZone toTimeZone() {\n        return java.util.TimeZone.getTimeZone(iID);\n    }", "equals": "\n    public abstract boolean equals(Object object);\n\n    /**\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     */\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }", "hashCode": "\n    public int hashCode() {\n        return 57 + getID().hashCode();\n    }", "toString": "\n    public String toString() {\n        return getID();\n    }", "writeReplace": "\n    protected Object writeReplace() throws ObjectStreamException {\n        return new Stub(iID);\n    }", "writeObject": "\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeUTF(iID);\n        }", "readObject": "\n        private void readObject(ObjectInputStream in) throws IOException {\n            iID = in.readUTF();\n        }", "readResolve": "\n        private Object readResolve() throws ObjectStreamException {\n            return forID(iID);\n        }"}