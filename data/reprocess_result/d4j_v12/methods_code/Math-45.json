{"copy": "\n    public OpenMapRealMatrix copy() {\n        return new OpenMapRealMatrix(this);\n    }", "createMatrix": "\n    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension) {\n        return new OpenMapRealMatrix(rowDimension, columnDimension);\n    }", "getColumnDimension": "\n    public int getColumnDimension() {\n        return columns;\n    }", "add": "\n    public OpenMapRealMatrix add(OpenMapRealMatrix m) {\n\n        // safety check\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n        for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n            iterator.advance();\n            final int row = iterator.key() / columns;\n            final int col = iterator.key() - row * columns;\n            out.setEntry(row, col, getEntry(row, col) + iterator.value());\n        }\n\n        return out;\n\n    }", "subtract": "\n    public OpenMapRealMatrix subtract(final RealMatrix m) {\n        try {\n            return subtract((OpenMapRealMatrix) m);\n        } catch (ClassCastException cce) {\n            return (OpenMapRealMatrix) super.subtract(m);\n        }\n    }", "multiply": "\n    public RealMatrix multiply(final RealMatrix m) {\n        try {\n            return multiply((OpenMapRealMatrix) m);\n        } catch (ClassCastException cce) {\n\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final int outCols = m.getColumnDimension();\n            final BlockRealMatrix out = new BlockRealMatrix(rows, outCols);\n            for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n                iterator.advance();\n                final double value = iterator.value();\n                final int key      = iterator.key();\n                final int i        = key / columns;\n                final int k        = key % columns;\n                for (int j = 0; j < outCols; ++j) {\n                    out.addToEntry(i, j, value * m.getEntry(k, j));\n                }\n            }\n\n            return out;\n        }\n    }", "getEntry": "\n    public double getEntry(int row, int column) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        return entries.get(computeKey(row, column));\n    }", "getRowDimension": "\n    public int getRowDimension() {\n        return rows;\n    }", "setEntry": "\n    public void setEntry(int row, int column, double value) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        if (value == 0.0) {\n            entries.remove(computeKey(row, column));\n        } else {\n            entries.put(computeKey(row, column), value);\n        }\n    }", "addToEntry": "\n    public void addToEntry(int row, int column, double increment) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        final int key = computeKey(row, column);\n        final double value = entries.get(key) + increment;\n        if (value == 0.0) {\n            entries.remove(key);\n        } else {\n            entries.put(key, value);\n        }\n    }", "multiplyEntry": "\n    public void multiplyEntry(int row, int column, double factor) {\n        MatrixUtils.checkRowIndex(this, row);\n        MatrixUtils.checkColumnIndex(this, column);\n        final int key = computeKey(row, column);\n        final double value = entries.get(key) * factor;\n        if (value == 0.0) {\n            entries.remove(key);\n        } else {\n            entries.put(key, value);\n        }\n    }", "computeKey": "\n    private int computeKey(int row, int column) {\n        return row * columns + column;\n    }"}