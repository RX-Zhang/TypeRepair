{"size": "\n    public int size() {\n        return iTypes.length;\n    }", "getChronology": "\n    public Chronology getChronology() {\n        return iChronology;\n    }", "getField": "\n    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }", "getFieldType": "\n    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }", "getFieldTypes": "\n    public DateTimeFieldType[] getFieldTypes() {\n        return (DateTimeFieldType[]) iTypes.clone();\n    }", "getValue": "\n    public int getValue(int index) {\n        return iValues[index];\n    }", "getValues": "\n    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }", "withChronologyRetainFields": "\n    public Partial withChronologyRetainFields(Chronology newChronology) {\n        newChronology = DateTimeUtils.getChronology(newChronology);\n        newChronology = newChronology.withUTC();\n        if (newChronology == getChronology()) {\n            return this;\n        } else {\n            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n            newChronology.validate(newPartial, iValues);\n            return newPartial;\n        }\n    }", "with": "\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }", "without": "\n    public Partial without(DateTimeFieldType fieldType) {\n        int index = indexOf(fieldType);\n        if (index != -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n            int[] newValues = new int[size() - 1];\n            System.arraycopy(iTypes, 0, newTypes, 0, index);\n            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n            System.arraycopy(iValues, 0, newValues, 0, index);\n            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        return this;\n    }", "withField": "\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        int index = indexOfSupported(fieldType);\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }", "withFieldAdded": "\n    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }", "withFieldAddWrapped": "\n    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n        return new Partial(this, newValues);\n    }", "withPeriodAdded": "\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        if (period == null || scalar == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        for (int i = 0; i < period.size(); i++) {\n            DurationFieldType fieldType = period.getFieldType(i);\n            int index = indexOf(fieldType);\n            if (index >= 0) {\n                newValues = getField(index).add(this, index, newValues,\n                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n            }\n        }\n        return new Partial(this, newValues);\n    }", "plus": "\n    public Partial plus(ReadablePeriod period) {\n        return withPeriodAdded(period, 1);\n    }", "minus": "\n    public Partial minus(ReadablePeriod period) {\n        return withPeriodAdded(period, -1);\n    }", "property": "\n    public Property property(DateTimeFieldType type) {\n        return new Property(this, indexOfSupported(type));\n    }", "isMatch": "\n    public boolean isMatch(ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        for (int i = 0; i < iTypes.length; i++) {\n            int value = iTypes[i].getField(chrono).get(millis);\n            if (value != iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "getFormatter": "\n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            if (size() == 0) {\n                return null;\n            }\n            f = new DateTimeFormatter[2];\n            try {\n                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n                f[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    f[1] = f[0];\n                }\n            } catch (IllegalArgumentException ex) {\n                // ignore\n            }\n            iFormatter = f;\n        }\n        return f[0];\n    }", "toString": "\n    public String toString() {\n        DateTimeFormatter[] f = iFormatter;\n        if (f == null) {\n            getFormatter();\n            f = iFormatter;\n            if (f == null) {\n                return toStringList();\n            }\n        }\n        DateTimeFormatter f1 = f[1];\n        if (f1 == null) {\n            return toStringList();\n        }\n        return f1.print(this);\n    }", "toStringList": "\n    public String toStringList() {\n        int size = size();\n        StringBuilder buf = new StringBuilder(20 * size);\n        buf.append('[');\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                buf.append(',').append(' ');\n            }\n            buf.append(iTypes[i].getName());\n            buf.append('=');\n            buf.append(iValues[i]);\n        }\n        buf.append(']');\n        return buf.toString();\n    }", "getReadablePartial": "\n        protected ReadablePartial getReadablePartial() {\n            return iPartial;\n        }", "getPartial": "\n        public Partial getPartial() {\n            return iPartial;\n        }", "get": "\n        public int get() {\n            return iPartial.getValue(iFieldIndex);\n        }", "addToCopy": "\n        public Partial addToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }", "addWrapFieldToCopy": "\n        public Partial addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n            return new Partial(iPartial, newValues);\n        }", "setCopy": "\n        public Partial setCopy(int value) {\n            int[] newValues = iPartial.getValues();\n            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n            return new Partial(iPartial, newValues);\n        }", "withMaximumValue": "\n        public Partial withMaximumValue() {\n            return setCopy(getMaximumValue());\n        }", "withMinimumValue": "\n        public Partial withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }"}