{"reset": "\n    public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }", "revert": "\n    public Line revert() {\n        final Line reverted = new Line(zero, zero.subtract(direction));\n        return reverted;\n    }", "getDirection": "\n    public Vector3D getDirection() {\n        return direction;\n    }", "getOrigin": "\n    public Vector3D getOrigin() {\n        return zero;\n    }", "getAbscissa": "\n    public double getAbscissa(final Vector3D point) {\n        return point.subtract(zero).dotProduct(direction);\n    }", "pointAt": "\n    public Vector3D pointAt(final double abscissa) {\n        return new Vector3D(1.0, zero, abscissa, direction);\n    }", "toSubSpace": "\n    public Vector1D toSubSpace(final Vector<Euclidean3D> point) {\n        return new Vector1D(getAbscissa((Vector3D) point));\n    }", "toSpace": "\n    public Vector3D toSpace(final Vector<Euclidean1D> point) {\n        return pointAt(((Vector1D) point).getX());\n    }", "isSimilarTo": "\n    public boolean isSimilarTo(final Line line) {\n        final double angle = Vector3D.angle(direction, line.direction);\n        return ((angle < 1.0e-10) || (angle > (FastMath.PI - 1.0e-10))) && contains(line.zero);\n    }", "contains": "\n    public boolean contains(final Vector3D p) {\n        return distance(p) < 1.0e-10;\n    }", "distance": "\n    public double distance(final Vector3D p) {\n        final Vector3D d = p.subtract(zero);\n        final Vector3D n = new Vector3D(1.0, d, -d.dotProduct(direction), direction);\n        return n.getNorm();\n    }", "closestPoint": "\n    public Vector3D closestPoint(final Line line) {\n\n        final double cos = direction.dotProduct(line.direction);\n        final double n = 1 - cos * cos;\n        if (n < Precision.EPSILON) {\n            // the lines are parallel\n            return zero;\n        }\n\n        final Vector3D delta0 = line.zero.subtract(zero);\n        final double a        = delta0.dotProduct(direction);\n        final double b        = delta0.dotProduct(line.direction);\n\n        return new Vector3D(1, zero, (a - b * cos) / n, direction);\n\n    }", "intersection": "\n    public Vector3D intersection(final Line line) {\n        final Vector3D closest = closestPoint(line);\n        return line.contains(closest) ? closest : null;\n    }", "wholeLine": "\n    public SubLine wholeLine() {\n        return new SubLine(this, new IntervalsSet());\n    }"}