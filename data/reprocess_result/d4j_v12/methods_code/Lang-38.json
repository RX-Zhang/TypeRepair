{"getInstance": "\n    public static FastDateFormat getInstance() {\n        return getInstance(getDefaultPattern(), null, null);\n    }", "getDateInstance": "\n    public static FastDateFormat getDateInstance(int style) {\n        return getDateInstance(style, null, null);\n    }", "getTimeInstance": "\n    public static FastDateFormat getTimeInstance(int style) {\n        return getTimeInstance(style, null, null);\n    }", "getDateTimeInstance": "\n    public static FastDateFormat getDateTimeInstance(\n            int dateStyle, int timeStyle) {\n        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n    }", "getTimeZoneDisplay": "\n    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            // This is a very slow call, so cache the results.\n            value = tz.getDisplayName(daylight, style, locale);\n            cTimeZoneDisplayCache.put(key, value);\n        }\n        return value;\n    }", "getDefaultPattern": "\n    private static synchronized String getDefaultPattern() {\n        if (cDefaultPattern == null) {\n            cDefaultPattern = new SimpleDateFormat().toPattern();\n        }\n        return cDefaultPattern;\n    }", "init": "\n    protected void init() {\n        List<Rule> rulesList = parsePattern();\n        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }", "parsePattern": "\n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': // year (number)\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case 'M': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }", "parseToken": "\n    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        // '' is treated as escaped '\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }", "selectNumberRule": "\n    protected NumberRule selectNumberRule(int field, int padding) {\n        switch (padding) {\n        case 1:\n            return new UnpaddedNumberField(field);\n        case 2:\n            return new TwoDigitNumberField(field);\n        default:\n            return new PaddedNumberField(field, padding);\n        }\n    }", "format": "\n    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            return format((Date) obj, toAppendTo);\n        } else if (obj instanceof Calendar) {\n            return format((Calendar) obj, toAppendTo);\n        } else if (obj instanceof Long) {\n            return format(((Long) obj).longValue(), toAppendTo);\n        } else {\n            throw new IllegalArgumentException(\"Unknown class: \" +\n                (obj == null ? \"<null>\" : obj.getClass().getName()));\n        }\n    }", "applyRules": "\n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n        Rule[] rules = mRules;\n        int len = mRules.length;\n        for (int i = 0; i < len; i++) {\n            rules[i].appendTo(buf, calendar);\n        }\n        return buf;\n    }", "parseObject": "\n    public Object parseObject(String source, ParsePosition pos) {\n        pos.setIndex(0);\n        pos.setErrorIndex(0);\n        return null;\n    }", "getPattern": "\n    public String getPattern() {\n        return mPattern;\n    }", "getTimeZone": "\n    public TimeZone getTimeZone() {\n        return mTimeZone;\n    }", "getTimeZoneOverridesCalendar": "\n    public boolean getTimeZoneOverridesCalendar() {\n        return mTimeZoneForced;\n    }", "getLocale": "\n    public Locale getLocale() {\n        return mLocale;\n    }", "getMaxLengthEstimate": "\n    public int getMaxLengthEstimate() {\n        return mMaxLengthEstimate;\n    }", "equals": "\n    public boolean equals(Object obj) {\n        if (obj instanceof FastDateFormat == false) {\n            return false;\n        }\n        FastDateFormat other = (FastDateFormat) obj;\n        if (\n            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n            (mTimeZoneForced == other.mTimeZoneForced) &&\n            (mLocaleForced == other.mLocaleForced)\n            ) {\n            return true;\n        }\n        return false;\n    }", "hashCode": "\n    public int hashCode() {\n        int total = 0;\n        total += mPattern.hashCode();\n        total += mTimeZone.hashCode();\n        total += (mTimeZoneForced ? 1 : 0);\n        total += mLocale.hashCode();\n        total += (mLocaleForced ? 1 : 0);\n        return total;\n    }", "toString": "\n    public String toString() {\n        return \"FastDateFormat[\" + mPattern + \"]\";\n    }", "readObject": "\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }", "estimateLength": "\n        public int estimateLength() {\n            return 1;\n        }", "appendTo": "\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\n            buffer.append(mValue);\n        }"}