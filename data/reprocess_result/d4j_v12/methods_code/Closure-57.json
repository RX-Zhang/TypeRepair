{"applySubclassRelationship": "\n  public void applySubclassRelationship(FunctionType parentCtor,\n      FunctionType childCtor, SubclassType type) {\n    if (type == SubclassType.INHERITS) {\n      childCtor.defineDeclaredProperty(\"superClass_\",\n          parentCtor.getPrototype(), parentCtor.getSource());\n      childCtor.getPrototype().defineDeclaredProperty(\"constructor\",\n          childCtor, parentCtor.getSource());\n    }\n  }", "getClassesDefinedByCall": "\n  public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n    Node callName = callNode.getFirstChild();\n    SubclassType type = typeofClassDefiningName(callName);\n    if (type != null) {\n      Node subclass = null;\n      Node superclass = callNode.getLastChild();\n\n      // There are six possible syntaxes for a class-defining method:\n      // SubClass.inherits(SuperClass)\n      // goog.inherits(SubClass, SuperClass)\n      // goog$inherits(SubClass, SuperClass)\n      // SubClass.mixin(SuperClass.prototype)\n      // goog.mixin(SubClass.prototype, SuperClass.prototype)\n      // goog$mixin(SubClass.prototype, SuperClass.prototype)\n      boolean isDeprecatedCall = callNode.getChildCount() == 2 &&\n          callName.getType() == Token.GETPROP;\n      if (isDeprecatedCall) {\n        // SubClass.inherits(SuperClass)\n        subclass = callName.getFirstChild();\n      } else if (callNode.getChildCount() == 3) {\n        // goog.inherits(SubClass, SuperClass)\n        subclass = callName.getNext();\n      } else {\n        return null;\n      }\n\n      if (type == SubclassType.MIXIN) {\n        // Only consider mixins that mix two prototypes as related to\n        // inheritance.\n        if (!endsWithPrototype(superclass)) {\n          return null;\n        }\n        if (!isDeprecatedCall) {\n          if (!endsWithPrototype(subclass)) {\n            return null;\n          }\n          // Strip off the prototype from the name.\n          subclass = subclass.getFirstChild();\n        }\n        superclass = superclass.getFirstChild();\n      }\n\n      // bail out if either of the side of the \"inherits\"\n      // isn't a real class name. This prevents us from\n      // doing something weird in cases like:\n      // goog.inherits(MySubClass, cond ? SuperClass1 : BaseClass2)\n      if (subclass != null &&\n          subclass.isUnscopedQualifiedName() &&\n          superclass.isUnscopedQualifiedName()) {\n        return new SubclassRelationship(type, subclass, superclass);\n      }\n    }\n\n    return null;\n  }", "typeofClassDefiningName": "\n  private SubclassType typeofClassDefiningName(Node callName) {\n    // Check if the method name matches one of the class-defining methods.\n    String methodName = null;\n    if (callName.getType() == Token.GETPROP) {\n      methodName = callName.getLastChild().getString();\n    } else if (callName.getType() == Token.NAME) {\n      String name = callName.getString();\n      int dollarIndex = name.lastIndexOf('$');\n      if (dollarIndex != -1) {\n        methodName = name.substring(dollarIndex + 1);\n      }\n    }\n\n    if (methodName != null) {\n      if (methodName.equals(\"inherits\")) {\n        return SubclassType.INHERITS;\n      } else if (methodName.equals(\"mixin\")) {\n        return SubclassType.MIXIN;\n      }\n    }\n    return null;\n  }", "isSuperClassReference": "\n  public boolean isSuperClassReference(String propertyName) {\n    return \"superClass_\".equals(propertyName);\n  }", "endsWithPrototype": "\n  private boolean endsWithPrototype(Node qualifiedName) {\n    return qualifiedName.getType() == Token.GETPROP &&\n        qualifiedName.getLastChild().getString().equals(\"prototype\");\n  }", "extractClassNameIfProvide": "\n  public String extractClassNameIfProvide(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.provide\");\n  }", "extractClassNameIfRequire": "\n  public String extractClassNameIfRequire(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.require\");\n  }", "extractClassNameIfGoog": "\n  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }", "getExportPropertyFunction": "\n  public String getExportPropertyFunction() {\n    return \"goog.exportProperty\";\n  }", "getExportSymbolFunction": "\n  public String getExportSymbolFunction() {\n    return \"goog.exportSymbol\";\n  }", "identifyTypeDeclarationCall": "\n  public List<String> identifyTypeDeclarationCall(Node n) {\n    Node callName = n.getFirstChild();\n    if (\"goog.addDependency\".equals(callName.getQualifiedName()) &&\n        n.getChildCount() >= 3) {\n      Node typeArray = callName.getNext().getNext();\n      if (typeArray.getType() == Token.ARRAYLIT) {\n        List<String> typeNames = Lists.newArrayList();\n        for (Node name = typeArray.getFirstChild(); name != null;\n             name = name.getNext()) {\n          if (name.getType() == Token.STRING) {\n            typeNames.add(name.getString());\n          }\n        }\n        return typeNames;\n      }\n    }\n    return null;\n  }", "getAbstractMethodName": "\n  public String getAbstractMethodName() {\n    return \"goog.abstractMethod\";\n  }", "getSingletonGetterClassName": "\n  public String getSingletonGetterClassName(Node callNode) {\n    Node callArg = callNode.getFirstChild();\n    String callName = callArg.getQualifiedName();\n\n    // Use both the original name and the post-CollapseProperties name.\n    if (!(\"goog.addSingletonGetter\".equals(callName) ||\n          \"goog$addSingletonGetter\".equals(callName)) ||\n        callNode.getChildCount() != 2) {\n      return null;\n    }\n\n    return callArg.getNext().getQualifiedName();\n  }", "applySingletonGetter": "\n  public void applySingletonGetter(FunctionType functionType,\n      FunctionType getterType, ObjectType objectType) {\n    functionType.defineDeclaredProperty(\"getInstance\", getterType,\n        functionType.getSource());\n    functionType.defineDeclaredProperty(\"instance_\", objectType,\n        functionType.getSource());\n  }", "getGlobalObject": "\n  public String getGlobalObject() {\n    return \"goog.global\";\n  }", "isPropertyTestFunction": "\n  public boolean isPropertyTestFunction(Node call) {\n    Preconditions.checkArgument(call.getType() == Token.CALL);\n    return propertyTestFunctions.contains(\n        call.getFirstChild().getQualifiedName());\n  }", "getObjectLiteralCast": "\n  public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n      Node callNode) {\n    Preconditions.checkArgument(callNode.getType() == Token.CALL);\n    Node callName = callNode.getFirstChild();\n    if (!\"goog.reflect.object\".equals(callName.getQualifiedName()) ||\n        callNode.getChildCount() != 3) {\n      return null;\n    }\n\n    Node typeNode = callName.getNext();\n    if (!typeNode.isQualifiedName()) {\n      return null;\n    }\n\n    Node objectNode = typeNode.getNext();\n    if (objectNode.getType() != Token.OBJECTLIT) {\n      // TODO(johnlenz): The coding convention should not be performing checks.\n      t.getCompiler().report(JSError.make(t.getSourceName(), callNode,\n                                          OBJECTLIT_EXPECTED));\n      return null;\n    }\n\n    return new ObjectLiteralCast(typeNode.getQualifiedName(),\n                                 typeNode.getNext());\n  }", "isOptionalParameter": "\n  public boolean isOptionalParameter(Node parameter) {\n    return false;\n  }", "isVarArgsParameter": "\n  public boolean isVarArgsParameter(Node parameter) {\n    return false;\n  }", "isPrivate": "\n  public boolean isPrivate(String name) {\n    return false;\n  }", "getAssertionFunctions": "\n  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n    return ImmutableList.<AssertionFunctionSpec>of(\n        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n            JSTypeNative.NUMBER_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n            JSTypeNative.STRING_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n            JSTypeNative.OBJECT_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n            JSTypeNative.ARRAY_TYPE),\n        // TODO(agrieve): It would be better if this could make the first\n        // parameter the type of the second parameter.\n        new AssertionFunctionSpec(\"goog.asserts.assertInstanceof\",\n            JSTypeNative.OBJECT_TYPE)\n    );\n  }", "describeFunctionBind": "\n  public Bind describeFunctionBind(Node n) {\n    Bind result = super.describeFunctionBind(n);\n    if (result != null) {\n      return result;\n    }\n\n    // It would be nice to be able to identify a fn.bind call\n    // but that requires knowing the type of \"fn\".\n\n    if (n.getType() != Token.CALL) {\n      return null;\n    }\n\n    Node callTarget = n.getFirstChild();\n    String name = callTarget.getQualifiedName();\n    if (name != null) {\n      if (name.equals(\"goog.bind\")\n          || name.equals(\"goog$bind\")) {\n        // goog.bind(fn, self, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = safeNext(fn);\n        Node parameters = safeNext(thisValue);\n        return new Bind(fn, thisValue, parameters);\n      }\n\n      if (name.equals(\"goog.partial\") || name.equals(\"goog$partial\")) {\n        // goog.partial(fn, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = null;\n        Node parameters = safeNext(fn);\n        return new Bind(fn, thisValue, parameters);\n      }\n    }\n\n    return null;\n  }", "safeNext": "\n  private Node safeNext(Node n) {\n    if (n != null) {\n      return n.getNext();\n    }\n    return null;\n  }"}