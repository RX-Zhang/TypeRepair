{"getL": "\n    public RealMatrix getL() {\n        if (cachedL == null) {\n            cachedL = getLT().transpose();\n        }\n        return cachedL;\n    }", "getLT": "\n    public RealMatrix getLT() {\n\n        if (cachedLT == null) {\n            cachedLT = MatrixUtils.createRealMatrix(lTData);\n        }\n\n        // return the cached matrix\n        return cachedLT;\n\n    }", "getDeterminant": "\n    public double getDeterminant() {\n        double determinant = 1.0;\n        for (int i = 0; i < lTData.length; ++i) {\n            double lTii = lTData[i][i];\n            determinant *= lTii * lTii;\n        }\n        return determinant;\n    }", "getSolver": "\n    public DecompositionSolver getSolver() {\n        return new Solver(lTData);\n    }", "isNonSingular": "\n        public boolean isNonSingular() {\n            // if we get this far, the matrix was positive definite, hence non-singular\n            return true;\n        }", "solve": "\n        public double[] solve(double[] b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.length != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.length, m);\n            }\n\n            final double[] x = b.clone();\n\n            // Solve LY = b\n            for (int j = 0; j < m; j++) {\n                final double[] lJ = lTData[j];\n                x[j] /= lJ[j];\n                final double xJ = x[j];\n                for (int i = j + 1; i < m; i++) {\n                    x[i] -= xJ * lJ[i];\n                }\n            }\n\n            // Solve LTX = Y\n            for (int j = m - 1; j >= 0; j--) {\n                x[j] /= lTData[j][j];\n                final double xJ = x[j];\n                for (int i = 0; i < j; i++) {\n                    x[i] -= xJ * lTData[i][j];\n                }\n            }\n\n            return x;\n\n        }", "getInverse": "\n        public RealMatrix getInverse() throws InvalidMatrixException {\n            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n        }"}