{"forCostEstimation": "\n  static CodeGenerator forCostEstimation(CodeConsumer consumer) {\n    return new CodeGenerator(consumer);\n  }", "tagAsStrict": "\n  public void tagAsStrict() {\n    add(\"'use strict';\");\n  }", "add": "\n  void add(String str) {\n    cc.add(str);\n  }", "addIdentifier": "\n  private void addIdentifier(String identifier) {\n    cc.addIdentifier(identifierEscape(identifier));\n  }", "unrollBinaryOperator": "\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.addOp(opStr, true);\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }", "isSimpleNumber": "\n  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    if (len == 0) {\n      return false;\n    }\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len == 1 || s.charAt(0) != '0';\n  }", "getSimpleNumber": "\n  static double getSimpleNumber(String s) {\n    if (isSimpleNumber(s)) {\n      try {\n        long l = Long.parseLong(s);\n        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n          return l;\n        }\n      } catch (NumberFormatException e) {\n        // The number was too long to parse. Fall through to NaN.\n      }\n    }\n    return Double.NaN;\n  }", "isIndirectEval": "\n  private boolean isIndirectEval(Node n) {\n    return n.isName() && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);\n  }", "addNonEmptyStatement": "\n  private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess = n;\n\n    if (!allowNonBlockChild && !n.isBlock()) {\n      throw new Error(\"Missing BLOCK child.\");\n    }\n\n    // Strip unneeded blocks, that is blocks with <2 children unless\n    // the CodePrinter specifically wants to keep them.\n    if (n.isBlock()) {\n      int count = getNonEmptyChildCount(n, 2);\n      if (count == 0) {\n        if (cc.shouldPreserveExtraBlocks()) {\n          cc.beginBlock();\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        } else {\n          cc.endStatement(true);\n        }\n        return;\n      }\n\n      if (count == 1) {\n        // Hack around a couple of browser bugs:\n        //   Safari needs a block around function declarations.\n        //   IE6/7 needs a block around DOs.\n        Node firstAndOnlyChild = getFirstNonEmptyChild(n);\n        boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();\n        if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n          cc.beginBlock();\n          add(firstAndOnlyChild, Context.STATEMENT);\n          cc.maybeLineBreak();\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n          return;\n        } else {\n          // Continue with the only child.\n          nodeToProcess = firstAndOnlyChild;\n        }\n      }\n\n      if (count > 1) {\n        context = Context.PRESERVE_BLOCK;\n      }\n    }\n\n    if (nodeToProcess.isEmpty()) {\n      cc.endStatement(true);\n    } else {\n      add(nodeToProcess, context);\n\n      // VAR doesn't include ';' since it gets used in expressions - so any\n      // VAR in a statement context needs a call to endStatement() here.\n      if (nodeToProcess.isVar()) {\n        cc.endStatement();\n      }\n    }\n  }", "isOneExactlyFunctionOrDo": "\n  private boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.isLabel()) {\n      Node labeledStatement = n.getLastChild();\n      if (!labeledStatement.isBlock()) {\n        return isOneExactlyFunctionOrDo(labeledStatement);\n      } else {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs\n        // are skipped.\n        if (getNonEmptyChildCount(n, 2) == 1) {\n          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n        } else {\n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n          return false;\n        }\n      }\n    } else {\n      return (n.isFunction() || n.isDo());\n    }\n  }", "addExpr": "\n  private void addExpr(Node n, int minPrecedence, Context context) {\n    if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) && n.isIn())){\n      add(\"(\");\n      add(n, Context.OTHER);\n      add(\")\");\n    } else {\n      add(n, context);\n    }\n  }", "addList": "\n  void addList(Node firstInList) {\n    addList(firstInList, true, Context.OTHER);\n  }", "addArrayList": "\n  void addArrayList(Node firstInList) {\n    boolean lastWasEmpty = false;\n    for (Node n = firstInList; n != null; n = n.getNext()) {\n      if (n != firstInList) {\n        cc.listSeparator();\n      }\n      addExpr(n, 1, Context.OTHER);\n      lastWasEmpty = n.isEmpty();\n    }\n\n    if (lastWasEmpty) {\n      cc.listSeparator();\n    }\n  }", "addCaseBody": "\n  void addCaseBody(Node caseBody) {\n    cc.beginCaseBody();\n    add(caseBody);\n    cc.endCaseBody();\n  }", "addAllSiblings": "\n  void addAllSiblings(Node n) {\n    for (Node c = n; c != null; c = c.getNext()) {\n      add(c);\n    }\n  }", "addJsString": "\n  private void addJsString(Node n) {\n    String s = n.getString();\n    boolean useSlashV = n.getBooleanProp(Node.SLASH_V);\n    if (useSlashV) {\n      add(jsString(n.getString(), useSlashV));\n    } else {\n      String cached = escapedJsStrings.get(s);\n      if (cached == null) {\n        cached = jsString(n.getString(), useSlashV);\n        escapedJsStrings.put(s, cached);\n      }\n      add(cached);\n    }\n  }", "jsString": "\n  private String jsString(String s, boolean useSlashV) {\n    int singleq = 0, doubleq = 0;\n\n    // could count the quotes and pick the optimal quote character\n    for (int i = 0; i < s.length(); i++) {\n      switch (s.charAt(i)) {\n        case '\"': doubleq++; break;\n        case '\\'': singleq++; break;\n      }\n    }\n\n    String doublequote, singlequote;\n    char quote;\n    if (preferSingleQuotes ?\n        (singleq <= doubleq) : (singleq < doubleq)) {\n      // more double quotes so enclose in single quotes.\n      quote = '\\'';\n      doublequote = \"\\\"\";\n      singlequote = \"\\\\\\'\";\n    } else {\n      // more single quotes so escape the doubles\n      quote = '\\\"';\n      doublequote = \"\\\\\\\"\";\n      singlequote = \"\\'\";\n    }\n\n    return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n        outputCharsetEncoder, useSlashV, false);\n  }", "regexpEscape": "\n  String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder, false, true);\n  }", "escapeToDoubleQuotedJsString": "\n  String escapeToDoubleQuotedJsString(String s) {\n    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null, false, false);\n  }", "strEscape": "\n  private String strEscape(\n      String s,\n      char quote,\n      String doublequoteEscape,\n      String singlequoteEscape,\n      String backslashEscape,\n      CharsetEncoder outputCharsetEncoder,\n      boolean useSlashV,\n      boolean isRegexp) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\x00\"); break;\n        case '\\u000B':\n          if (useSlashV) {\n            sb.append(\"\\\\v\");\n          } else {\n            sb.append(\"\\\\x0B\");\n          }\n          break;\n        // From the SingleEscapeCharacter grammar production.\n        case '\\b': sb.append(\"\\\\b\"); break;\n        case '\\f': sb.append(\"\\\\f\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n\n        // From LineTerminators (ES5 Section 7.3, Table 3)\n        case '\\u2028': sb.append(\"\\\\u2028\"); break;\n        case '\\u2029': sb.append(\"\\\\u2029\"); break;\n\n        case '=':\n          // '=' is a syntactically signficant regexp character.\n          if (trustedStrings || isRegexp) {\n            sb.append(c);\n          } else {\n            sb.append(\"\\\\x3d\");\n          }\n          break;\n\n        case '&':\n          if (trustedStrings || isRegexp) {\n            sb.append(c);\n          } else {\n            sb.append(\"\\\\x26\");\n          }\n          break;\n\n        case '>':\n          if (!trustedStrings && !isRegexp) {\n            sb.append(GT_ESCAPED);\n            break;\n          }\n\n          // Break --> into --\\> or ]]> into ]]\\>\n          //\n          // This is just to prevent developers from shooting themselves in the\n          // foot, and does not provide the level of security that you get\n          // with trustedString == false.\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(GT_ESCAPED);\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          if (!trustedStrings && !isRegexp) {\n            sb.append(LT_ESCAPED);\n            break;\n          }\n\n          // Break </script into <\\/script\n          // As above, this is just to prevent developers from doing this\n          // accidentally.\n          final String endScript = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String startComment = \"!--\";\n\n          if (s.regionMatches(true, i + 1, endScript, 0,\n                              endScript.length())) {\n            sb.append(LT_ESCAPED);\n          } else if (s.regionMatches(false, i + 1, startComment, 0,\n                                     startComment.length())) {\n            sb.append(LT_ESCAPED);\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight Latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some JS parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and Unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }", "identifierEscape": "\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-Latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }", "getNonEmptyChildCount": "\n  private static int getNonEmptyChildCount(Node n, int maxCount) {\n    int i = 0;\n    Node c = n.getFirstChild();\n    for (; c != null && i < maxCount; c = c.getNext()) {\n      if (c.isBlock()) {\n        i += getNonEmptyChildCount(c, maxCount - i);\n      } else if (!c.isEmpty()) {\n        i++;\n      }\n    }\n    return i;\n  }", "getFirstNonEmptyChild": "\n  private static Node getFirstNonEmptyChild(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.isBlock()) {\n        Node result = getFirstNonEmptyChild(c);\n        if (result != null) {\n          return result;\n        }\n      } else if (!c.isEmpty()) {\n        return c;\n      }\n    }\n    return null;\n  }", "getContextForNonEmptyExpression": "\n  private Context getContextForNonEmptyExpression(Context currentContext) {\n    return currentContext == Context.BEFORE_DANGLING_ELSE ?\n        Context.BEFORE_DANGLING_ELSE : Context.OTHER;\n  }", "getContextForNoInOperator": "\n  private  Context getContextForNoInOperator(Context context) {\n    return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);\n  }", "appendHexJavaScriptRepresentation": "\n  private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c) {\n    try {\n      appendHexJavaScriptRepresentation(c, sb);\n    } catch (IOException ex) {\n      // StringBuilder does not throw IOException.\n      throw new RuntimeException(ex);\n    }\n  }"}