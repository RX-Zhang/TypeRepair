{"addAndCheck": "\n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }", "binomialCoefficient": "\n    public static long binomialCoefficient(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        // Use symmetry for large k\n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n\n        // We use the formula\n        // (n choose k) = n! / (n-k)! / k!\n        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n        // which could be written\n        // (n choose k) == (n-1 choose k-1) * n / k\n        long result = 1;\n        if (n <= 61) {\n            // For n <= 61, the naive implementation cannot overflow.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                result = result * i / j;\n                i++;\n            }\n        } else if (n <= 66) {\n            // For n > 61 but n <= 66, the result cannot overflow,\n            // but we must take care not to overflow intermediate values.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                // We know that (result * i) is divisible by j,\n                // but (result * i) may overflow, so we split j:\n                // Filter out the gcd, d, so j/d and i/d are integer.\n                // result is divisible by (j/d) because (j/d)\n                // is relative prime to (i/d) and is a divisor of\n                // result * (i/d).\n                final long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n                i++;\n            }\n        } else {\n            // For n > 66, a result overflow might occur, so we check\n            // the multiplication, taking care to not overflow\n            // unnecessary.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                final long d = gcd(i, j);\n                result = mulAndCheck(result / (j / d), i / d);\n                i++;\n            }\n        }\n        return result;\n    }", "binomialCoefficientDouble": "\n    public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n\n        return Math.floor(result + 0.5);\n    }", "binomialCoefficientLog": "\n    public static double binomialCoefficientLog(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log(n);\n        }\n\n        /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n        if (n < 67) {\n            return Math.log(binomialCoefficient(n,k));\n        }\n\n        /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n        if (n < 1030) {\n            return Math.log(binomialCoefficientDouble(n, k));\n        }\n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        /*\n         * Sum logs for values that could overflow\n         */\n        double logSum = 0;\n\n        // n!/(n-k)!\n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += Math.log(i);\n        }\n\n        // divide by k!\n        for (int i = 2; i <= k; i++) {\n            logSum -= Math.log(i);\n        }\n\n        return logSum;\n    }", "checkBinomial": "\n    private static void checkBinomial(final int n, final int k)\n        throws IllegalArgumentException {\n        if (n < k) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n                n, k);\n        }\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n                  n);\n        }\n    }", "compareTo": "\n    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n          return -1;\n        }\n        return 1;\n    }", "cosh": "\n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }", "equals": "\n    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }", "factorial": "\n    public static long factorial(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return FACTORIALS[n];\n    }", "factorialDouble": "\n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }", "factorialLog": "\n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"must have n >= 0 for n!, got n = {0}\",\n                  n);\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log(i);\n        }\n        return logSum;\n    }", "gcd": "\n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        p, q);\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }", "hash": "\n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }", "indicator": "\n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }", "lcm": "\n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE){\n            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n        }\n        return lcm;\n    }", "log": "\n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }", "mulAndCheck": "\n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }", "nextAfter": "\n    public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        // split the double in raw components\n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                // we should increase the mantissa\n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                // we should decrease the mantissa\n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }", "scalb": "\n    public static double scalb(final double d, final int scaleFactor) {\n\n        // handling of some important special cases\n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        // split the double in raw components\n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        // shift the exponent\n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }", "normalizeAngle": "\n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }", "normalizeArray": "\n     public static double[] normalizeArray(double[] values, double normalizedSum)\n       throws ArithmeticException, IllegalArgumentException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to an infinite value\");\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"Cannot normalize to NaN\");\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw MathRuntimeException.createArithmeticException(\n                         \"Array contains an infinite element, {0} at index {1}\", values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw MathRuntimeException.createArithmeticException(\n                     \"Array sums to zero\");\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }", "round": "\n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }", "roundUnscaled": "\n    private static double roundUnscaled(double unscaled, double sign,\n        int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                // The following equality test is intentional and needed for rounding purposes\n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { // even\n                    unscaled = Math.floor(unscaled);\n                } else { // odd\n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n                  \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n                  roundingMethod,\n                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }", "sign": "\n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }", "sinh": "\n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }", "subAndCheck": "\n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }", "pow": "\n    public static int pow(final int k, int e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                \"cannot raise an integral value to a negative power ({0}^{1})\",\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }", "distance1": "\n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }", "distance": "\n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return Math.sqrt(sum);\n    }", "distanceInf": "\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }"}