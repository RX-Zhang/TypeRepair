{"abs": "\n    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;        \n    }", "compareTo": "\n    public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }", "doubleValue": "\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }", "equals": "\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else {\n            try {\n                // since fractions are always in lowest terms, numerators and\n                // denominators can be compared directly for equality.\n                Fraction rhs = (Fraction)other;\n                ret = (numerator == rhs.numerator) &&\n                    (denominator == rhs.denominator);\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n        \n        return ret;\n    }", "floatValue": "\n    public float floatValue() {\n        return (float)doubleValue();\n    }", "getDenominator": "\n    public int getDenominator() {\n        return denominator;\n    }", "getNumerator": "\n    public int getNumerator() {\n        return numerator;\n    }", "hashCode": "\n    public int hashCode() {\n        return 37 * (37 * 17 + getNumerator()) + getDenominator();\n    }", "intValue": "\n    public int intValue() {\n        return (int)doubleValue();\n    }", "longValue": "\n    public long longValue() {\n        return (long)doubleValue();\n    }", "negate": "\n    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n                                                                 numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }", "reciprocal": "\n    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }", "add": "\n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true /* add */);\n    }", "subtract": "\n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false /* subtract */);\n    }", "addSub": "\n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n                 MathUtils.subAndCheck(uvp, upv),\n                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        BigInteger uvp = BigInteger.valueOf(numerator)\n        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n        .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n                                                                 w);\n        }\n        return new Fraction (w.intValue(), \n                MathUtils.mulAndCheck(denominator/d1, \n                        fraction.denominator/d2));\n    }", "multiply": "\n    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        // knuth 4.5.1\n        // make sure we don't overflow unless the result *must* overflow.\n        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }", "divide": "\n    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"the fraction to divide by must not be zero: {0}/{1}\",\n                    fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }", "getReducedFraction": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"zero denominator in fraction {0}/{1}\",\n                    numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow in fraction {0}/{1}, cannot negate\",\n                        numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = MathUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }"}