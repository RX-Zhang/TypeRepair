{"addAndCheck": "\n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n        }\n        return (int)s;\n    }", "binomialCoefficient": "\n    public static long binomialCoefficient(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        // Use symmetry for large k\n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n\n        // We use the formula\n        // (n choose k) = n! / (n-k)! / k!\n        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n        // which could be written\n        // (n choose k) == (n-1 choose k-1) * n / k\n        long result = 1;\n        if (n <= 61) {\n            // For n <= 61, the naive implementation cannot overflow.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                result = result * i / j;\n                i++;\n            }\n        } else if (n <= 66) {\n            // For n > 61 but n <= 66, the result cannot overflow,\n            // but we must take care not to overflow intermediate values.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                // We know that (result * i) is divisible by j,\n                // but (result * i) may overflow, so we split j:\n                // Filter out the gcd, d, so j/d and i/d are integer.\n                // result is divisible by (j/d) because (j/d)\n                // is relative prime to (i/d) and is a divisor of\n                // result * (i/d).\n                final long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n                i++;\n            }\n        } else {\n            // For n > 66, a result overflow might occur, so we check\n            // the multiplication, taking care to not overflow\n            // unnecessary.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                final long d = gcd(i, j);\n                result = mulAndCheck(result / (j / d), i / d);\n                i++;\n            }\n        }\n        return result;\n    }", "binomialCoefficientDouble": "\n    public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n\n        return FastMath.floor(result + 0.5);\n    }", "binomialCoefficientLog": "\n    public static double binomialCoefficientLog(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return FastMath.log(n);\n        }\n\n        /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n        if (n < 67) {\n            return FastMath.log(binomialCoefficient(n,k));\n        }\n\n        /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n        if (n < 1030) {\n            return FastMath.log(binomialCoefficientDouble(n, k));\n        }\n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        /*\n         * Sum logs for values that could overflow\n         */\n        double logSum = 0;\n\n        // n!/(n-k)!\n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += FastMath.log(i);\n        }\n\n        // divide by k!\n        for (int i = 2; i <= k; i++) {\n            logSum -= FastMath.log(i);\n        }\n\n        return logSum;\n    }", "checkBinomial": "\n    private static void checkBinomial(final int n, final int k)\n        throws IllegalArgumentException {\n        if (n < k) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n                n, k);\n        }\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n    }", "compareTo": "\n    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n          return -1;\n        }\n        return 1;\n    }", "cosh": "\n    public static double cosh(double x) {\n        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n    }", "equals": "\n    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }", "equalsIncludingNaN": "\n    public static boolean equalsIncludingNaN(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n    }", "factorial": "\n    public static long factorial(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return FACTORIALS[n];\n    }", "factorialDouble": "\n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);\n    }", "factorialLog": "\n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n < 21) {\n            return FastMath.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += FastMath.log(i);\n        }\n        return logSum;\n    }", "gcd": "\n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                        p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                    p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }", "hash": "\n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }", "indicator": "\n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }", "lcm": "\n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE) {\n            throw MathRuntimeException.createArithmeticException(\n                LocalizedFormats.LCM_OVERFLOW_32_BITS,\n                a, b);\n        }\n        return lcm;\n    }", "log": "\n    public static double log(double base, double x) {\n        return FastMath.log(x)/FastMath.log(base);\n    }", "mulAndCheck": "\n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }", "scalb": "\n    public static double scalb(final double d, final int scaleFactor) {\n\n        // handling of some important special cases\n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        // split the double in raw components\n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        // shift the exponent\n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }", "normalizeAngle": "\n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n     }", "normalizeArray": "\n     public static double[] normalizeArray(double[] values, double normalizedSum)\n       throws ArithmeticException, IllegalArgumentException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw MathRuntimeException.createArithmeticException(\n                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }", "round": "\n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }", "roundUnscaled": "\n    private static double roundUnscaled(double unscaled, double sign,\n        int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - FastMath.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = FastMath.ceil(unscaled);\n            } else {\n                unscaled = FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - FastMath.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = FastMath.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = FastMath.floor(unscaled);\n            } else {\n                // The following equality test is intentional and needed for rounding purposes\n                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math\n                    .floor(unscaled) / 2.0)) { // even\n                    unscaled = FastMath.floor(unscaled);\n                } else { // odd\n                    unscaled = FastMath.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - FastMath.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = FastMath.ceil(unscaled);\n            } else {\n                unscaled = FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != FastMath.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.INVALID_ROUNDING_METHOD,\n                  roundingMethod,\n                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }", "sign": "\n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }", "sinh": "\n    public static double sinh(double x) {\n        return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;\n    }", "subAndCheck": "\n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n        }\n        return (int)s;\n    }", "pow": "\n    public static int pow(final int k, int e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }", "distance1": "\n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }", "distance": "\n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }", "distanceInf": "\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }", "checkOrder": "\n    public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {\n        double previous = val[0];\n        boolean ok = true;\n\n        int max = val.length;\n        for (int i = 1; i < max; i++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[i] <= previous) {\n                        ok = false;\n                    }\n                } else {\n                    if (val[i] < previous) {\n                        ok = false;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[i] >= previous) {\n                        ok = false;\n                    }\n                } else {\n                    if (val[i] > previous) {\n                        ok = false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new IllegalArgumentException();\n            }\n\n            if (!ok) {\n                throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);\n            }\n            previous = val[i];\n        }\n    }", "safeNorm": "\n    public static double safeNorm(double[] v) {\n    double rdwarf = 3.834e-20;\n    double rgiant = 1.304e+19;\n    double s1=0.0;\n    double s2=0.0;\n    double s3=0.0;\n    double x1max = 0.0;\n    double x3max = 0.0;\n    double floatn = (double)v.length;\n    double agiant = rgiant/floatn;\n    for (int i=0;i<v.length;i++) {\n        double xabs = Math.abs(v[i]);\n        if (xabs<rdwarf || xabs>agiant) {\n            if (xabs>rdwarf) {\n                if (xabs>x1max) {\n                    double r=x1max/xabs;\n                    s1=1.0+s1*r*r;\n                    x1max=xabs;\n                } else {\n                    double r=xabs/x1max;\n                    s1+=r*r;\n                }\n            } else {\n                if (xabs>x3max) {\n                 double r=x3max/xabs;\n                 s3=1.0+s3*r*r;\n                 x3max=xabs;\n                } else {\n                    if (xabs!=0.0) {\n                        double r=xabs/x3max;\n                        s3+=r*r;\n                    }\n                }\n            }\n        } else {\n         s2+=xabs*xabs;\n        }\n    }\n    double norm;\n    if (s1!=0.0) {\n        norm = x1max*Math.sqrt(s1+(s2/x1max)/x1max);\n    } else {\n        if (s2==0.0) {\n            norm = x3max*Math.sqrt(s3);\n        } else {\n            if (s2>=x3max) {\n                norm = Math.sqrt(s2*(1.0+(x3max/s2)*(x3max*s3)));\n            } else {\n                norm = Math.sqrt(x3max*((s2/x3max)+(x3max*s3)));\n            }\n        }\n    }\n    return norm;\n}"}