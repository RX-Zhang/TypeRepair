{"toFormatter": "\n    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }", "toPrinter": "\n    public DateTimePrinter toPrinter() {\n        Object f = getFormatter();\n        if (isPrinter(f)) {\n            return (DateTimePrinter) f;\n        }\n        throw new UnsupportedOperationException(\"Printing is not supported\");\n    }", "toParser": "\n    public DateTimeParser toParser() {\n        Object f = getFormatter();\n        if (isParser(f)) {\n            return (DateTimeParser) f;\n        }\n        throw new UnsupportedOperationException(\"Parsing is not supported\");\n    }", "canBuildFormatter": "\n    public boolean canBuildFormatter() {\n        return isFormatter(getFormatter());\n    }", "canBuildPrinter": "\n    public boolean canBuildPrinter() {\n        return isPrinter(getFormatter());\n    }", "canBuildParser": "\n    public boolean canBuildParser() {\n        return isParser(getFormatter());\n    }", "clear": "\n    public void clear() {\n        iFormatter = null;\n        iElementPairs.clear();\n    }", "append": "\n    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }", "appendOptional": "\n    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }", "checkParser": "\n    private void checkParser(DateTimeParser parser) {\n        if (parser == null) {\n            throw new IllegalArgumentException(\"No parser supplied\");\n        }\n    }", "checkPrinter": "\n    private void checkPrinter(DateTimePrinter printer) {\n        if (printer == null) {\n            throw new IllegalArgumentException(\"No printer supplied\");\n        }\n    }", "append0": "\n    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        // Add the element as both a printer and parser.\n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }", "appendLiteral": "\n    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }", "appendDecimal": "\n    public DateTimeFormatterBuilder appendDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }", "appendFixedDecimal": "\n    public DateTimeFormatterBuilder appendFixedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, false));\n    }", "appendSignedDecimal": "\n    public DateTimeFormatterBuilder appendSignedDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }", "appendFixedSignedDecimal": "\n    public DateTimeFormatterBuilder appendFixedSignedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, true));\n    }", "appendText": "\n    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, false));\n    }", "appendShortText": "\n    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, true));\n    }", "appendFraction": "\n    public DateTimeFormatterBuilder appendFraction(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }", "appendFractionOfSecond": "\n    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }", "appendFractionOfMinute": "\n    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }", "appendFractionOfHour": "\n    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }", "appendFractionOfDay": "\n    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }", "appendMillisOfSecond": "\n    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }", "appendMillisOfDay": "\n    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }", "appendSecondOfMinute": "\n    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }", "appendSecondOfDay": "\n    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }", "appendMinuteOfHour": "\n    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }", "appendMinuteOfDay": "\n    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }", "appendHourOfDay": "\n    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }", "appendClockhourOfDay": "\n    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }", "appendHourOfHalfday": "\n    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }", "appendClockhourOfHalfday": "\n    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }", "appendDayOfWeek": "\n    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }", "appendDayOfMonth": "\n    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }", "appendDayOfYear": "\n    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }", "appendWeekOfWeekyear": "\n    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }", "appendWeekyear": "\n    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }", "appendMonthOfYear": "\n    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }", "appendYear": "\n    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }", "appendTwoDigitYear": "\n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n        return appendTwoDigitYear(pivot, false);\n    }", "appendTwoDigitWeekyear": "\n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n        return appendTwoDigitWeekyear(pivot, false);\n    }", "appendYearOfEra": "\n    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }", "appendYearOfCentury": "\n    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }", "appendCenturyOfEra": "\n    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }", "appendHalfdayOfDayText": "\n    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }", "appendDayOfWeekText": "\n    public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }", "appendDayOfWeekShortText": "\n    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }", "appendMonthOfYearText": "\n    public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }", "appendMonthOfYearShortText": "\n    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }", "appendEraText": "\n    public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }", "appendTimeZoneName": "\n    public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n    }", "appendTimeZoneShortName": "\n    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n    }", "appendTimeZoneId": "\n    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }", "appendTimeZoneOffset": "\n    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n    }", "appendPattern": "\n    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }", "getFormatter": "\n    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }", "isPrinter": "\n    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }", "isParser": "\n    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }", "isFormatter": "\n    private boolean isFormatter(Object f) {\n        return (isPrinter(f) || isParser(f));\n    }", "appendUnknownString": "\n    static void appendUnknownString(StringBuffer buf, int len) {\n        for (int i = len; --i >= 0;) {\n            buf.append('\\ufffd');\n        }\n    }", "printUnknownString": "\n    static void printUnknownString(Writer out, int len) throws IOException {\n        for (int i = len; --i >= 0;) {\n            out.write('\\ufffd');\n        }\n    }", "estimatePrintedLength": "\n        public int estimatePrintedLength() {\n            return 1;\n        }", "printTo": "\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }", "estimateParsedLength": "\n        public int estimateParsedLength() {\n            return 1;\n        }", "parseInto": "\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }", "getTwoDigitYear": "\n        private int getTwoDigitYear(long instant, Chronology chrono) {\n            try {\n                int year = iType.getField(chrono).get(instant);\n                if (year < 0) {\n                    year = -year;\n                }\n                return year % 100;\n            } catch (RuntimeException e) {\n                return -1;\n            }\n        }", "print": "\n        private String print(long instant, Chronology chrono, Locale locale) {\n            DateTimeField field = iFieldType.getField(chrono);\n            if (iShort) {\n                return field.getAsShortText(instant, locale);\n            } else {\n                return field.getAsText(instant, locale);\n            }\n        }", "getFractionData": "\n        private long[] getFractionData(long fraction, DateTimeField field) {\n            long rangeMillis = field.getDurationField().getUnitMillis();\n            long scalar;\n            int maxDigits = iMaxDigits;\n            while (true) {\n                switch (maxDigits) {\n                default: scalar = 1L; break;\n                case 1:  scalar = 10L; break;\n                case 2:  scalar = 100L; break;\n                case 3:  scalar = 1000L; break;\n                case 4:  scalar = 10000L; break;\n                case 5:  scalar = 100000L; break;\n                case 6:  scalar = 1000000L; break;\n                case 7:  scalar = 10000000L; break;\n                case 8:  scalar = 100000000L; break;\n                case 9:  scalar = 1000000000L; break;\n                case 10: scalar = 10000000000L; break;\n                case 11: scalar = 100000000000L; break;\n                case 12: scalar = 1000000000000L; break;\n                case 13: scalar = 10000000000000L; break;\n                case 14: scalar = 100000000000000L; break;\n                case 15: scalar = 1000000000000000L; break;\n                case 16: scalar = 10000000000000000L; break;\n                case 17: scalar = 100000000000000000L; break;\n                case 18: scalar = 1000000000000000000L; break;\n                }\n                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n                    break;\n                }\n                // Overflowed: scale down.\n                maxDigits--;\n            }\n            \n            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n        }", "digitCount": "\n        private int digitCount(String text, int position, int amount) {\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        }", "decompose": "\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }", "addArrayToList": "\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }"}