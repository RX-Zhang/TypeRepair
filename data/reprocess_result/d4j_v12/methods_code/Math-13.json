{"getJacobianEvaluations": "\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }", "updateJacobian": "\n    protected void updateJacobian() {\n        final RealMatrix weightedJacobian = computeWeightedJacobian(point);\n        weightedResidualJacobian = weightedJacobian.scalarMultiply(-1).getData();\n    }", "computeWeightedJacobian": "\n    protected RealMatrix computeWeightedJacobian(double[] params) {\n        ++jacobianEvaluations;\n\n        final DerivativeStructure[] dsPoint = new DerivativeStructure[params.length];\n        final int nC = params.length;\n        for (int i = 0; i < nC; ++i) {\n            dsPoint[i] = new DerivativeStructure(nC, 1, i, params[i]);\n        }\n        final DerivativeStructure[] dsValue = jF.value(dsPoint);\n        final int nR = getTarget().length;\n        if (dsValue.length != nR) {\n            throw new DimensionMismatchException(dsValue.length, nR);\n        }\n        final double[][] jacobianData = new double[nR][nC];\n        for (int i = 0; i < nR; ++i) {\n            int[] orders = new int[nC];\n            for (int j = 0; j < nC; ++j) {\n                orders[j] = 1;\n                jacobianData[i][j] = dsValue[i].getPartialDerivative(orders);\n                orders[j] = 0;\n            }\n        }\n\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobianData));\n    }", "updateResidualsAndCost": "\n    protected void updateResidualsAndCost() {\n        objective = computeObjectiveValue(point);\n        final double[] res = computeResiduals(objective);\n\n        // Compute cost.\n        cost = computeCost(res);\n\n        // Compute weighted residuals.\n        final ArrayRealVector residuals = new ArrayRealVector(res);\n        weightedResiduals = weightMatrixSqrt.operate(residuals).toArray();\n    }", "computeCost": "\n    protected double computeCost(double[] residuals) {\n        final ArrayRealVector r = new ArrayRealVector(residuals);\n        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n    }", "getRMS": "\n    public double getRMS() {\n        return FastMath.sqrt(getChiSquare() / rows);\n    }", "getChiSquare": "\n    public double getChiSquare() {\n        return cost * cost;\n    }", "getWeightSquareRoot": "\n    public RealMatrix getWeightSquareRoot() {\n        return weightMatrixSqrt.copy();\n    }", "setCost": "\n    protected void setCost(double cost) {\n        this.cost = cost;\n    }", "getCovariances": "\n    public double[][] getCovariances() {\n        return getCovariances(DEFAULT_SINGULARITY_THRESHOLD);\n    }", "computeCovariances": "\n    public double[][] computeCovariances(double[] params,\n                                         double threshold) {\n        // Set up the Jacobian.\n        final RealMatrix j = computeWeightedJacobian(params);\n\n        // Compute transpose(J)J.\n        final RealMatrix jTj = j.transpose().multiply(j);\n\n        // Compute the covariances matrix.\n        final DecompositionSolver solver\n            = new QRDecomposition(jTj, threshold).getSolver();\n        return solver.getInverse().getData();\n    }", "guessParametersErrors": "\n    public double[] guessParametersErrors() {\n        if (rows <= cols) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                                                rows, cols, false);\n        }\n        double[] errors = new double[cols];\n        final double c = FastMath.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = computeCovariances(point, 1e-14);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = FastMath.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }", "computeSigma": "\n    public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold) {\n        final int nC = params.length;\n        final double[] sig = new double[nC];\n        final double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < nC; ++i) {\n            sig[i] = FastMath.sqrt(cov[i][i]);\n        }\n        return sig;\n    }", "optimize": "\n    public PointVectorValuePair optimize(int maxEval,\n                                         final DifferentiableMultivariateVectorFunction f,\n                                         final double[] target, final double[] weights,\n                                         final double[] startPoint) {\n        return optimizeInternal(maxEval,\n                                FunctionUtils.toMultivariateDifferentiableVectorFunction(f),\n                                new Target(target),\n                                new Weight(weights),\n                                new InitialGuess(startPoint));\n    }", "optimizeInternal": "\n    protected PointVectorValuePair optimizeInternal(final int maxEval,\n                                                    final MultivariateDifferentiableVectorFunction f,\n                                                    OptimizationData... optData) {\n        // XXX Conversion will be removed when the generic argument of the\n        // base class becomes \"MultivariateDifferentiableVectorFunction\".\n        return super.optimizeInternal(maxEval, FunctionUtils.toDifferentiableMultivariateVectorFunction(f), optData);\n    }", "setUp": "\n    protected void setUp() {\n        super.setUp();\n\n        // Reset counter.\n        jacobianEvaluations = 0;\n\n        // Square-root of the weight matrix.\n        weightMatrixSqrt = squareRoot(getWeight());\n\n        // Store least squares problem characteristics.\n        // XXX The conversion won't be necessary when the generic argument of\n        // the base class becomes \"MultivariateDifferentiableVectorFunction\".\n        // XXX \"jF\" is not strictly necessary anymore but is currently more\n        // efficient than converting the value returned from \"getObjectiveFunction()\"\n        // every time it is used.\n        jF = FunctionUtils.toMultivariateDifferentiableVectorFunction((DifferentiableMultivariateVectorFunction) getObjectiveFunction());\n\n        // Arrays shared with \"private\" and \"protected\" methods.\n        point = getStartPoint();\n        rows = getTarget().length;\n        cols = point.length;\n    }", "computeResiduals": "\n    protected double[] computeResiduals(double[] objectiveValue) {\n        final double[] target = getTarget();\n        if (objectiveValue.length != target.length) {\n            throw new DimensionMismatchException(target.length,\n                                                 objectiveValue.length);\n        }\n\n        final double[] residuals = new double[target.length];\n        for (int i = 0; i < target.length; i++) {\n            residuals[i] = target[i] - objectiveValue[i];\n        }\n\n        return residuals;\n    }", "squareRoot": "\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }"}