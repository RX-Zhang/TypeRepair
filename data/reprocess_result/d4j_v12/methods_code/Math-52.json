{"revert": "\n  public Rotation revert() {\n    return new Rotation(-q0, q1, q2, q3, false);\n  }", "getQ0": "\n  public double getQ0() {\n    return q0;\n  }", "getQ1": "\n  public double getQ1() {\n    return q1;\n  }", "getQ2": "\n  public double getQ2() {\n    return q2;\n  }", "getQ3": "\n  public double getQ3() {\n    return q3;\n  }", "getAxis": "\n  public Vector3D getAxis() {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n      double inverse = 1 / FastMath.sqrt(squaredSine);\n      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = -1 / FastMath.sqrt(squaredSine);\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n  }", "getAngle": "\n  public double getAngle() {\n    if ((q0 < -0.1) || (q0 > 0.1)) {\n      return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n    } else if (q0 < 0) {\n      return 2 * FastMath.acos(-q0);\n    }\n    return 2 * FastMath.acos(q0);\n  }", "getAngles": "\n  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       -FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }", "getMatrix": "\n  public double[][] getMatrix() {\n\n    // products\n    double q0q0  = q0 * q0;\n    double q0q1  = q0 * q1;\n    double q0q2  = q0 * q2;\n    double q0q3  = q0 * q3;\n    double q1q1  = q1 * q1;\n    double q1q2  = q1 * q2;\n    double q1q3  = q1 * q3;\n    double q2q2  = q2 * q2;\n    double q2q3  = q2 * q3;\n    double q3q3  = q3 * q3;\n\n    // create the matrix\n    double[][] m = new double[3][];\n    m[0] = new double[3];\n    m[1] = new double[3];\n    m[2] = new double[3];\n\n    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n    m [1][0] = 2.0 * (q1q2 - q0q3);\n    m [2][0] = 2.0 * (q1q3 + q0q2);\n\n    m [0][1] = 2.0 * (q1q2 + q0q3);\n    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n    m [2][1] = 2.0 * (q2q3 - q0q1);\n\n    m [0][2] = 2.0 * (q1q3 - q0q2);\n    m [1][2] = 2.0 * (q2q3 + q0q1);\n    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n\n    return m;\n\n  }", "applyTo": "\n  public Vector3D applyTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n\n    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }", "applyInverseTo": "\n  public Vector3D applyInverseTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n    double m0 = -q0;\n\n    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }", "orthogonalizeMatrix": "\n  private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n    throws NotARotationMatrixException {\n    double[] m0 = m[0];\n    double[] m1 = m[1];\n    double[] m2 = m[2];\n    double x00 = m0[0];\n    double x01 = m0[1];\n    double x02 = m0[2];\n    double x10 = m1[0];\n    double x11 = m1[1];\n    double x12 = m1[2];\n    double x20 = m2[0];\n    double x21 = m2[1];\n    double x22 = m2[2];\n    double fn = 0;\n    double fn1;\n\n    double[][] o = new double[3][3];\n    double[] o0 = o[0];\n    double[] o1 = o[1];\n    double[] o2 = o[2];\n\n    // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n    int i = 0;\n    while (++i < 11) {\n\n      // Mt.Xn\n      double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n      double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n      double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n      double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n      double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n      double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n      double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n      double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n      double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n\n      // Xn+1\n      o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n      o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n      o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n      o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n      o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n      o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n      o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n      o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n      o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n\n      // correction on each elements\n      double corr00 = o0[0] - m0[0];\n      double corr01 = o0[1] - m0[1];\n      double corr02 = o0[2] - m0[2];\n      double corr10 = o1[0] - m1[0];\n      double corr11 = o1[1] - m1[1];\n      double corr12 = o1[2] - m1[2];\n      double corr20 = o2[0] - m2[0];\n      double corr21 = o2[1] - m2[1];\n      double corr22 = o2[2] - m2[2];\n\n      // Frobenius norm of the correction\n      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n            corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n            corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n      // convergence test\n      if (FastMath.abs(fn1 - fn) <= threshold) {\n          return o;\n      }\n\n      // prepare next iteration\n      x00 = o0[0];\n      x01 = o0[1];\n      x02 = o0[2];\n      x10 = o1[0];\n      x11 = o1[1];\n      x12 = o1[2];\n      x20 = o2[0];\n      x21 = o2[1];\n      x22 = o2[2];\n      fn  = fn1;\n\n    }\n\n    // the algorithm did not converge after 10 iterations\n    throw new NotARotationMatrixException(\n            LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n            i - 1);\n  }", "distance": "\n  public static double distance(Rotation r1, Rotation r2) {\n      return r1.applyInverseTo(r2).getAngle();\n  }"}