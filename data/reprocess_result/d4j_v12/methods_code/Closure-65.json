{"tagAsStrict": "\n  public void tagAsStrict() {\n    add(\"'use strict';\");\n  }", "add": "\n  void add(String str) {\n    cc.add(str);\n  }", "addIdentifier": "\n  private void addIdentifier(String identifier) {\n    cc.addIdentifier(identifierEscape(identifier));\n  }", "isSimpleNumber": "\n  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0;\n  }", "getSimpleNumber": "\n  static double getSimpleNumber(String s) {\n    if (isSimpleNumber(s)) {\n      try {\n        long l = Long.parseLong(s);\n        if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n          return l;\n        }\n      } catch (NumberFormatException e) {\n        // The number was too long to parse. Fall through to NaN.\n      }\n    }\n    return Double.NaN;\n  }", "isIndirectEval": "\n  private boolean isIndirectEval(Node n) {\n    return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);\n  }", "addNonEmptyStatement": "\n  private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess = n;\n\n    if (!allowNonBlockChild && n.getType() != Token.BLOCK) {\n      throw new Error(\"Missing BLOCK child.\");\n    }\n\n    // Strip unneeded blocks, that is blocks with <2 children unless\n    // the CodePrinter specifically wants to keep them.\n    if (n.getType() == Token.BLOCK) {\n      int count = getNonEmptyChildCount(n, 2);\n      if (count == 0) {\n        if (cc.shouldPreserveExtraBlocks()) {\n          cc.beginBlock();\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        } else {\n          cc.endStatement(true);\n        }\n        return;\n      }\n\n      if (count == 1) {\n        // Hack around a couple of browser bugs:\n        //   Safari needs a block around function declarations.\n        //   IE6/7 needs a block around DOs.\n        Node firstAndOnlyChild = getFirstNonEmptyChild(n);\n        boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();\n        if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n          cc.beginBlock();\n          add(firstAndOnlyChild, Context.STATEMENT);\n          cc.maybeLineBreak();\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n          return;\n        } else {\n          // Continue with the only child.\n          nodeToProcess = firstAndOnlyChild;\n        }\n      }\n\n      if (count > 1) {\n        context = Context.PRESERVE_BLOCK;\n      }\n    }\n\n    if (nodeToProcess.getType() == Token.EMPTY) {\n      cc.endStatement(true);\n    } else {\n      add(nodeToProcess, context);\n\n      // VAR doesn't include ';' since it gets used in expressions - so any\n      // VAR in a statement context needs a call to endStatement() here.\n      if (nodeToProcess.getType() == Token.VAR) {\n        cc.endStatement();\n      }\n    }\n  }", "isOneExactlyFunctionOrDo": "\n  private boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n      Node labeledStatement = n.getLastChild();\n      if (labeledStatement.getType() != Token.BLOCK) {\n        return isOneExactlyFunctionOrDo(labeledStatement);\n      } else {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs\n        // are skipped.\n        if (getNonEmptyChildCount(n, 2) == 1) {\n          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n        } else {\n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n          return false;\n        }\n      }\n    } else {\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n    }\n  }", "addLeftExpr": "\n  void addLeftExpr(Node n, int minPrecedence, Context context) {\n    addExpr(n, minPrecedence, context);\n  }", "addExpr": "\n  void addExpr(Node n, int minPrecedence) {\n    addExpr(n, minPrecedence, Context.OTHER);\n  }", "addList": "\n  void addList(Node firstInList) {\n    addList(firstInList, true, Context.OTHER);\n  }", "addArrayList": "\n  void addArrayList(Node firstInList) {\n    boolean lastWasEmpty = false;\n    for (Node n = firstInList; n != null; n = n.getNext()) {\n      if (n != firstInList) {\n        cc.listSeparator();\n      }\n      addExpr(n, 1);\n      lastWasEmpty = n.getType() == Token.EMPTY;\n    }\n\n    if (lastWasEmpty) {\n      cc.listSeparator();\n    }\n  }", "addCaseBody": "\n  void addCaseBody(Node caseBody) {\n    cc.beginCaseBody();\n    add(caseBody);\n    cc.endCaseBody();\n  }", "addAllSiblings": "\n  void addAllSiblings(Node n) {\n    for (Node c = n; c != null; c = c.getNext()) {\n      add(c);\n    }\n  }", "addJsString": "\n  void addJsString(String s) {\n    String cached = ESCAPED_JS_STRINGS.get(s);\n    if (cached == null) {\n      cached = jsString(s);\n      ESCAPED_JS_STRINGS.put(s, cached);\n    }\n    add(cached);\n  }", "jsString": "\n  String jsString(String s) {\n    int singleq = 0, doubleq = 0;\n\n    // could count the quotes and pick the optimal quote character\n    for (int i = 0; i < s.length(); i++) {\n      switch (s.charAt(i)) {\n        case '\"': doubleq++; break;\n        case '\\'': singleq++; break;\n      }\n    }\n\n    String doublequote, singlequote;\n    char quote;\n    if (singleq < doubleq) {\n      // more double quotes so escape the single quotes\n      quote = '\\'';\n      doublequote = \"\\\"\";\n      singlequote = \"\\\\\\'\";\n    } else {\n      // more single quotes so escape the doubles\n      quote = '\\\"';\n      doublequote = \"\\\\\\\"\";\n      singlequote = \"\\'\";\n    }\n\n    return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n        outputCharsetEncoder);\n  }", "regexpEscape": "\n  static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);\n  }", "escapeToDoubleQuotedJsString": "\n  static String escapeToDoubleQuotedJsString(String s) {\n    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n  }", "strEscape": "\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }", "identifierEscape": "\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }", "getNonEmptyChildCount": "\n  private static int getNonEmptyChildCount(Node n, int maxCount) {\n    int i = 0;\n    Node c = n.getFirstChild();\n    for (; c != null && i < maxCount; c = c.getNext()) {\n      if (c.getType() == Token.BLOCK) {\n        i += getNonEmptyChildCount(c, maxCount-i);\n      } else if (c.getType() != Token.EMPTY) {\n        i++;\n      }\n    }\n    return i;\n  }", "getFirstNonEmptyChild": "\n  private static Node getFirstNonEmptyChild(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.BLOCK) {\n        Node result = getFirstNonEmptyChild(c);\n        if (result != null) {\n          return result;\n        }\n      } else if (c.getType() != Token.EMPTY) {\n        return c;\n      }\n    }\n    return null;\n  }", "getContextForNonEmptyExpression": "\n  private Context getContextForNonEmptyExpression(Context currentContext) {\n    return currentContext == Context.BEFORE_DANGLING_ELSE ?\n        Context.BEFORE_DANGLING_ELSE : Context.OTHER;\n  }", "getContextForNoInOperator": "\n  private  Context getContextForNoInOperator(Context context) {\n    return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);\n  }", "clearContextForNoInOperator": "\n  private  Context clearContextForNoInOperator(Context context) {\n    return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.OTHER : context);\n  }", "appendHexJavaScriptRepresentation": "\n  private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c) {\n    try {\n      appendHexJavaScriptRepresentation(c, sb);\n    } catch (IOException ex) {\n      // StringBuilder does not throw IOException.\n      throw new RuntimeException(ex);\n    }\n  }"}