{"ClassName": "PeepholeSubstituteAlternateSyntax", "Fields": ["private static final int AND_PRECEDENCE;", "private static final int OR_PRECEDENCE;", "private static final int NOT_PRECEDENCE;", "private static final CodeGenerator REGEXP_ESCAPER;", "private final boolean late;", "private final int STRING_SPLIT_OVERHEAD;", "static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS;", "static final Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE;", "private static final ImmutableSet STANDARD_OBJECT_CONSTRUCTORS;", "private static final Pattern REGEXP_FLAGS_RE;"], "Methods": ["public Node optimizeSubtree(Node node) { ... }", "private void tryJoinForCondition(Node n) { ... }", "private Node tryFoldSimpleFunctionCall(Node n) { ... }", "private Node tryFoldImmediateCallToBoundFunction(Node n) { ... }", "private void addParameterAfter(Node parameterList, Node after) { ... }", "private Node trySplitComma(Node n) { ... }", "private Node tryReplaceIf(Node n) { ... }", "private boolean statementMustExitParent(Node n) { ... }", "private Node tryReplaceUndefined(Node n) { ... }", "private Node tryReduceReturn(Node n) { ... }", "private Node tryReplaceExitWithBreak(Node n) { ... }", "private Node tryRemoveRedundantExit(Node n) { ... }", " boolean isPure(Node n) { ... }", " Node skipFinallyNodes(Node n) { ... }", " boolean areMatchingExits(Node nodeThis, Node nodeThat) { ... }", " boolean isExceptionPossible(Node n) { ... }", " Node getExceptionHandler(Node n) { ... }", "private Node tryMinimizeNot(Node n) { ... }", "private Node tryMinimizeIf(Node n) { ... }", "private void tryRemoveRepeatedStatements(Node n) { ... }", "private boolean isFoldableExpressBlock(Node n) { ... }", "private Node getBlockExpression(Node n) { ... }", "private boolean isReturnBlock(Node n) { ... }", "private boolean isReturnExpressBlock(Node n) { ... }", "private boolean isReturnExpression(Node n) { ... }", "private Node getBlockReturnExpression(Node n) { ... }", "private boolean isVarBlock(Node n) { ... }", "private Node getBlockVar(Node n) { ... }", "private boolean consumesDanglingElse(Node n) { ... }", "private boolean isLowerPrecedenceInExpression(Node n, int precedence) { ... }", "private boolean isLowerPrecedence(Node n, int precedence) { ... }", "private boolean isHigherPrecedence(Node n, int precedence) { ... }", "private boolean isPropertyAssignmentInExpression(Node n) { ... }", "private Node tryMinimizeCondition(Node n) { ... }", "private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { ... }", "private Node tryFoldStandardConstructors(Node n) { ... }", "private Node tryFoldLiteralConstructor(Node n) { ... }", "private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) { ... }", "private Node tryFoldRegularExpressionConstructor(Node n) { ... }", "private Node reduceTrueFalse(Node n) { ... }", "private Node tryMinimizeArrayLiteral(Node n) { ... }", "private Node tryMinimizeStringArrayLiteral(Node n) { ... }", "private String pickDelimiter(String[] strings) { ... }", "private static boolean areValidRegexpFlags(String flags) { ... }", "private boolean areSafeFlagsToFold(String flags) { ... }", "private static Node makeForwardSlashBracketSafe(Node n) { ... }", "static boolean containsUnicodeEscape(String s) { ... }"]}