{"checkCapacity": "\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }", "copyOf": "\n    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }", "indexOfKey": "\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }", "indexOfKeyIgnoreCase": "\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }", "checkNotNull": "\n    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }", "get": "\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }", "getIgnoreCase": "\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }", "add": "\n    private void add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }", "put": "\n    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }", "putIgnoreCase": "\n    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }", "remove": "\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }", "removeIgnoreCase": "\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }", "hasKey": "\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }", "hasKeyIgnoreCase": "\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }", "size": "\n    public int size() {\n        return size;\n    }", "addAll": "\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }", "iterator": "\n    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }", "asList": "\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }", "dataset": "\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }", "html": "\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        try {\n            html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return accum.toString();\n    }", "toString": "\n    public String toString() {\n        return html();\n    }", "equals": "\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }", "hashCode": "\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }", "clone": "\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }", "normalize": "\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }", "entrySet": "\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }", "hasNext": "\n            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }", "next": "\n            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }", "dataKey": "\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }"}