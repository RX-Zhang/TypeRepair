{"equals": "\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }", "getBytes": "\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }", "getByteBuffer": "\n    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return ByteBuffer.wrap(string.getBytes(charset));\n    }", "getByteBufferUtf8": "\n    public static ByteBuffer getByteBufferUtf8(final String string) {\n        return getByteBuffer(string, Charsets.UTF_8);\n    }", "getBytesIso8859_1": "\n    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }", "getBytesUnchecked": "\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }", "getBytesUsAscii": "\n    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }", "getBytesUtf16": "\n    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }", "getBytesUtf16Be": "\n    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }", "getBytesUtf16Le": "\n    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }", "getBytesUtf8": "\n    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }", "newIllegalStateException": "\n    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }", "newString": "\n    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }", "newStringIso8859_1": "\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }", "newStringUsAscii": "\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }", "newStringUtf16": "\n    public static String newStringUtf16(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16);\n    }", "newStringUtf16Be": "\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16BE);\n    }", "newStringUtf16Le": "\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_16LE);\n    }", "newStringUtf8": "\n    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }"}