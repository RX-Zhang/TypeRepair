{"isLineBreak": "\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }", "newFormat": "\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false);\n    }", "valueOf": "\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }", "equals": "\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }", "format": "\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }", "getAllowMissingColumnNames": "\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }", "getCommentMarker": "\n    public Character getCommentMarker() {\n        return commentMarker;\n    }", "getDelimiter": "\n    public char getDelimiter() {\n        return delimiter;\n    }", "getEscapeCharacter": "\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }", "getHeader": "\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }", "getHeaderComments": "\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }", "getIgnoreEmptyLines": "\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }", "getIgnoreHeaderCase": "\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }", "getIgnoreSurroundingSpaces": "\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }", "getNullString": "\n    public String getNullString() {\n        return nullString;\n    }", "getQuoteCharacter": "\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }", "getQuoteMode": "\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }", "getRecordSeparator": "\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }", "getSkipHeaderRecord": "\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }", "getTrailingDelimiter": "\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }", "getTrim": "\n    public boolean getTrim() {\n        return trim;\n    }", "hashCode": "\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }", "isCommentMarkerSet": "\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }", "isEscapeCharacterSet": "\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }", "isNullStringSet": "\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }", "isQuoteCharacterSet": "\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }", "parse": "\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }", "print": "\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }", "printAndEscape": "\n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n            throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }", "printAndQuote": "\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }", "println": "\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }", "printRecord": "\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }", "toString": "\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }", "toStringArray": "\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }", "trim": "\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }", "validate": "\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }", "withAllowMissingColumnNames": "\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }", "withCommentMarker": "\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }", "withDelimiter": "\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }", "withEscape": "\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }", "withFirstRecordAsHeader": "\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }", "withHeader": "\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }", "withHeaderComments": "\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }", "withIgnoreEmptyLines": "\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }", "withIgnoreHeaderCase": "\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }", "withIgnoreSurroundingSpaces": "\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }", "withNullString": "\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }", "withQuote": "\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }", "withQuoteMode": "\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }", "withRecordSeparator": "\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }", "withSkipHeaderRecord": "\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }", "withTrailingDelimiter": "\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }", "withTrim": "\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }"}