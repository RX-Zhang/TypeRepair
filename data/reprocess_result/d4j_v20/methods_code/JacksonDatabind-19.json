{"withModifier": "\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n        if (mod == null) { // mostly for unit tests\n            return new TypeFactory(_parser, _modifiers);\n        }\n        if (_modifiers == null) {\n            return new TypeFactory(_parser, new TypeModifier[] { mod });\n        }\n        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n    }", "defaultInstance": "\n    public static TypeFactory defaultInstance() { return instance; }", "clearCache": "\n    public void clearCache() {\n        _typeCache.clear();\n    }", "unknownType": "\n    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }", "rawClass": "\n    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Shouldbe able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }", "constructSpecializedType": "\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        // Currently only SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n    }", "constructFromCanonical": "\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }", "findTypeParameters": "\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n        /* Tricky part here is that some JavaType instances have been constructed\n         * from generic type (usually via TypeReference); and in those case\n         * types have been resolved. Alternative is that the leaf type is type-erased\n         * class, in which case this has not been done.\n         * For now simplest way to handle this is to split processing in two: latter\n         * case actually fully works; and former mostly works. In future may need to\n         * rewrite former part, which requires changes to JavaType as well.\n         */\n        if (expType == type.getParameterSource()) {\n            // Direct type info; good since we can return it as is\n            int count = type.containedTypeCount();\n            if (count == 0) return null;\n            JavaType[] result = new JavaType[count];\n            for (int i = 0; i < count; ++i) {\n                result[i] = type.containedType(i);\n            }\n            return result;\n        }\n        /* Otherwise need to go through type-erased class. This may miss cases where\n         * we get generic type; ideally JavaType/SimpleType would retain information\n         * about generic declaration at main level... but let's worry about that\n         * if/when there are problems; current handling is an improvement over earlier\n         * code.\n         */\n        Class<?> raw = type.getRawClass();\n        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n    }", "moreSpecificType": "\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }", "constructType": "\n    public JavaType constructType(Type type) {\n        return _constructType(type, null);\n    }", "_constructType": "\n    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { // [Issue#116]\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }", "constructArrayType": "\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null, null);\n    }", "constructCollectionType": "\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n        return CollectionType.construct(collectionClass, constructType(elementClass));\n    }", "constructCollectionLikeType": "\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n    }", "constructMapType": "\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n        return MapType.construct(mapClass, keyType, valueType);\n    }", "constructMapLikeType": "\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n        return MapLikeType.construct(mapClass, keyType, valueType);\n    }", "constructSimpleType": "\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return constructSimpleType(rawType, rawType, parameterTypes);\n    }", "constructReferenceType": "\n    public JavaType constructReferenceType(Class<?> rawType, JavaType refType)\n    {\n        return new ReferenceType(rawType, refType, null, null, false);\n    }", "uncheckedSimpleType": "\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }", "constructParametrizedType": "\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(parameterClasses[i], null);\n        }\n        return constructParametrizedType(parametrized, parametersFor, pt);\n    }", "constructParametricType": "\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n    }", "constructRawCollectionType": "\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }", "constructRawCollectionLikeType": "\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }", "constructRawMapType": "\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }", "constructRawMapLikeType": "\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }", "_fromClass": "\n    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n    {\n        // Very first thing: small set of core types we know well:\n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        // Barring that, we may have recently constructed an instance:\n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); // ok, cache object is synced\n        if (result != null) {\n            return result;\n        }\n\n        // If context was needed, weed do:\n        /*\n        if (context == null) {\n            context = new TypeBindings(this, cls);\n        }\n        */\n\n        // First: do we have an array type?\n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            /* Also: although enums can also be fully resolved, there's little\n             * point in doing so (T extends Enum<T>) etc.\n             */\n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            /* Maps and Collections aren't quite as hot; problem is, due\n             * to type erasure we often do not know typing and can only assume\n             * base Object.\n             */\n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            // 28-Apr-2015, tatu: New class of types, referential...\n            if (AtomicReference.class.isAssignableFrom(clz)) {\n                \n                JavaType[] pts = findTypeParameters(clz, AtomicReference.class);\n                JavaType rt = (pts == null || pts.length != 1) ? unknownType() : pts[0];\n                result = constructReferenceType(clz, rt);\n            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n            } else if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); // cache object syncs\n        return result;\n    }", "_fromParameterizedClass": "\n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n    {\n        if (clz.isArray()) { // ignore generics (should never have any)\n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { // ditto for enums\n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            // First: if we do have param types, use them\n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        // Hmmh. Does this actually occur?\n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }", "_fromParamType": "\n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n    {\n        /* First: what is the actual base type? One odd thing\n         * is that 'getRawType' returns Type, not Class<?> as\n         * one might expect. But let's assume it is always of\n         * type Class: if not, need to add more code to resolve\n         * it to Class.\n         */\n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        // Ok: Map or Collection?\n        if (Map.class.isAssignableFrom(rawType)) {\n            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        // 28-Apr-2015, tatu: New class of types, referential...\n        if (AtomicReference.class.isAssignableFrom(rawType)) {\n            JavaType rt = null;\n\n            if (rawType == AtomicReference.class) {\n                if (paramCount == 1) {\n                    rt = pt[0];\n                }\n            } else {\n                JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n                if (pts != null && pts.length != 1) {\n                    rt = pts[0];\n                }\n            }\n            return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n        }\n        if (Map.Entry.class.isAssignableFrom(rawType)) {\n            JavaType kt = null, vt = null;\n\n            if (rawType == Map.Entry.class) {\n                if (paramCount == 2) {\n                    kt = pt[0];\n                    vt = pt[1];\n                }\n            } else {\n                JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n                if (pts != null && pts.length != 2) {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n            }\n            return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n        }\n        \n        if (paramCount == 0) { // no generics\n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }", "_fromArrayType": "\n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n    {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }", "_fromVariable": "\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            context = new TypeBindings(this, (Class<?>) null);\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name, false);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }", "_fromWildcard": "\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n    {\n        /* Similar to challenges with TypeVariable, we may have\n         * multiple upper bounds. But it is also possible that if\n         * upper bound defaults to Object, we might want to consider\n         * lower bounds instead.\n         *\n         * For now, we won't try anything more advanced; above is\n         * just for future reference.\n         */\n        return _constructType(type.getUpperBounds()[0], context);\n    }", "_mapType": "\n    private JavaType _mapType(Class<?> rawClass)\n    {\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }", "_collectionType": "\n    private JavaType _collectionType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    ", "_resolveVariableViaSubTypes": "\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n    {\n        // can't resolve raw types; possible to have as-of-yet-unbound types too:\n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    // further resolution needed?\n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    // no we're good for the variable (but it may have parameterization of its own)\n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }", "_unknownType": "\n    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }", "_findSuperTypeChain": "\n    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n    {\n        // If super-type is a class (not interface), bit simpler\n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }", "_findSuperClassChain": "\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        // Otherwise, keep on going down the rat hole...\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }", "_findSuperInterfaceChain": "\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return new HierarchicType(currentType);\n        }\n        // Otherwise, keep on going down the rat hole; first implemented interfaces\n        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's\n         *   try caching certain commonly needed cases\n         */\n        if (raw == HashMap.class) {\n            if (target == Map.class) {\n                return _hashMapSuperInterfaceChain(current);\n            }\n        }\n        if (raw == ArrayList.class) {\n            if (target == List.class) {\n                return _arrayListSuperInterfaceChain(current);\n            }\n        }\n        return _doFindSuperInterfaceChain(current, target);\n    }", "_doFindSuperInterfaceChain": "\n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)\n    {\n        Class<?> raw = current.getRawClass();\n        Type[] parents = raw.getGenericInterfaces();\n        // as long as there are superclasses\n        // and unless we have already seen the type (<T extends X<T>>)\n        if (parents != null) {\n            for (Type parent : parents) {\n                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n                if (sup != null) {\n                    sup.setSubType(current);\n                    current.setSuperType(sup);\n                    return current;\n                }\n            }\n        }\n        // and then super-class if any\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }", "_hashMapSuperInterfaceChain": "\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }", "_arrayListSuperInterfaceChain": "\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedArrayListType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, List.class);\n            _cachedArrayListType = base.getSuperType();\n        }\n        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }"}