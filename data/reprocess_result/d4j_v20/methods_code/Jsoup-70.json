{"ensureChildNodes": "\n    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }", "hasAttributes": "\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }", "attributes": "\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }", "baseUri": "\n    public String baseUri() {\n        return baseUri;\n    }", "doSetBaseUri": "\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }", "childNodeSize": "\n    public int childNodeSize() {\n        return childNodes.size();\n    }", "nodeName": "\n    public String nodeName() {\n        return tag.getName();\n    }", "tagName": "\n    public String tagName() {\n        return tag.getName();\n    }", "tag": "\n    public Tag tag() {\n        return tag;\n    }", "isBlock": "\n    public boolean isBlock() {\n        return tag.isBlock();\n    }", "id": "\n    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }", "attr": "\n    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }", "dataset": "\n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }", "parent": "\n    public final Element parent() {\n        return (Element) parentNode;\n    }", "parents": "\n    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }", "accumulateParents": "\n    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }", "child": "\n    public Element child(int index) {\n        return childElementsList().get(index);\n    }", "children": "\n    public Elements children() {\n        return new Elements(childElementsList());\n    }", "childElementsList": "\n    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }", "nodelistChanged": "\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }", "textNodes": "\n    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }", "dataNodes": "\n    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }", "select": "\n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }", "selectFirst": "\n    public Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }", "is": "\n    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }", "appendChild": "\n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        // was - Node#addChildren(child). short-circuits an array create and a loop.\n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }", "appendTo": "\n    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }", "prependChild": "\n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }", "insertChildren": "\n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n        addChildren(index, nodeArray);\n        return this;\n    }", "appendElement": "\n    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }", "prependElement": "\n    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }", "appendText": "\n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }", "prependText": "\n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }", "append": "\n    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }", "prepend": "\n    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }", "before": "\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }", "after": "\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }", "empty": "\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }", "wrap": "\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }", "cssSelector": "\n    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }", "siblingElements": "\n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }", "nextElementSibling": "\n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }", "previousElementSibling": "\n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }", "firstElementSibling": "\n    public Element firstElementSibling() {\n        // todo: should firstSibling() exclude this?\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }", "elementSiblingIndex": "\n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }", "lastElementSibling": "\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }", "indexInList": "\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        for (int i = 0; i < elements.size(); i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }", "getElementsByTag": "\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }", "getElementById": "\n    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }", "getElementsByClass": "\n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }", "getElementsByAttribute": "\n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }", "getElementsByAttributeStarting": "\n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }", "getElementsByAttributeValue": "\n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }", "getElementsByAttributeValueNot": "\n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }", "getElementsByAttributeValueStarting": "\n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }", "getElementsByAttributeValueEnding": "\n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }", "getElementsByAttributeValueContaining": "\n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }", "getElementsByAttributeValueMatching": "\n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }", "getElementsByIndexLessThan": "\n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }", "getElementsByIndexGreaterThan": "\n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }", "getElementsByIndexEquals": "\n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }", "getElementsContainingText": "\n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }", "getElementsContainingOwnText": "\n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }", "getElementsMatchingText": "\n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }", "getElementsMatchingOwnText": "\n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }", "getAllElements": "\n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }", "text": "\n    public String text() {\n        final StringBuilder accum = new StringBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        }, this);\n        return accum.toString().trim();\n    }", "ownText": "\n    public String ownText() {\n        StringBuilder sb = new StringBuilder();\n        ownText(sb);\n        return sb.toString().trim();\n    }", "appendNormalisedText": "\n    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (preserveWhitespace(textNode.parentNode))\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n    }", "appendWhitespaceIfBr": "\n    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }", "preserveWhitespace": "\n    static boolean preserveWhitespace(Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node != null && node instanceof Element) {\n            Element el = (Element) node;\n                if (el.tag.preserveWhitespace())\n                    return true;\n                else\n                    return el.parent() != null && el.parent().tag.preserveWhitespace();\n        }\n        return false;\n    }", "hasText": "\n    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }", "data": "\n    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   ", "className": "\n    public String className() {\n        return attr(\"class\").trim();\n    }", "classNames": "\n    public Set<String> classNames() {\n    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }", "hasClass": "\n    public boolean hasClass(String className) {\n        final String classAttr = attributes().getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    // we're in a class name : keep the start of the substring\n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        // check the last entry\n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }", "addClass": "\n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }", "removeClass": "\n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }", "toggleClass": "\n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }", "val": "\n    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }", "outerHtmlHead": "\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); // <img> in html, <img /> in xml\n        }\n        else\n            accum.append('>');\n    }", "outerHtmlTail": "\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }", "html": "\n    public String html() {\n        StringBuilder accum = StringUtil.stringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }", "toString": "\n\tpublic String toString() {\n        return outerHtml();\n    }", "clone": "\n    public Element clone() {\n        return (Element) super.clone();\n    }", "shallowClone": "\n    public Element shallowClone() {\n        // simpler than implementing a clone version with no child copy\n        return new Element(tag, baseUri, attributes);\n    }", "doClone": "\n    protected Element doClone(Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new NodeList(clone, childNodes.size());\n        clone.childNodes.addAll(childNodes); // the children then get iterated and cloned in Node.clone\n\n        return clone;\n    }", "onContentsChanged": "\n        public void onContentsChanged() {\n            owner.nodelistChanged();\n        }"}