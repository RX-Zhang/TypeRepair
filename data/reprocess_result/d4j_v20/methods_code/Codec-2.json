{"isUrlSafe": "\n    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }", "hasData": "\n    boolean hasData() {\n        return this.buf != null;\n    }", "avail": "\n    int avail() {\n        return buf != null ? pos - readPos : 0;\n    }", "resizeBuf": "\n    private void resizeBuf() {\n        if (buf == null) {\n            buf = new byte[8192];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buf.length * 2];\n            System.arraycopy(buf, 0, b, 0, buf.length);\n            buf = b;\n        }\n    }", "readResults": "\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buf != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buf != b) {\n                System.arraycopy(buf, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buf = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buf = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }", "setInitialBuffer": "\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buf = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }", "encode": "\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }", "decode": "\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < decodeSize) {\n                resizeBuf();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // WE'RE DONE!!!!\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buf[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned:  actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            x = x << 6;\n            switch (modulus) {\n                case 2:\n                    x = x << 6;\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3:\n                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }", "isBase64": "\n    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }", "isArrayByteBase64": "\n    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "containsBase64Byte": "\n    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }", "encodeBase64": "\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }", "encodeBase64URLSafe": "\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }", "encodeBase64Chunked": "\n    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }", "decodeBase64": "\n    public static byte[] decodeBase64(byte[] base64Data) {\n        if (base64Data == null || base64Data.length == 0) {\n            return base64Data;\n        }\n        Base64 b64 = new Base64();\n        long len = (base64Data.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.decode(base64Data, 0, base64Data.length);\n        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n        // We have no idea what the line-length was, so we\n        // cannot know how much of our array wasn't used.\n        byte[] result = new byte[b64.pos];\n        b64.readResults(result, 0, result.length);\n        return result;\n    }", "discardWhitespace": "\n    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }", "isWhiteSpace": "\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }", "discardNonBase64": "\n    static byte[] discardNonBase64(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            if (isBase64(data[i])) {\n                groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }", "decodeInteger": "\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }", "encodeInteger": "\n    public static byte[] encodeInteger(BigInteger bigInt) {\n        if(bigInt == null)  {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }", "toIntegerBytes": "\n     static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if(((bigInt.bitLength() % 8) != 0) &&\n            (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }"}