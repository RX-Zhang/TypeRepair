{"getNonBlockingInputFeeder": "\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }", "needMoreInput": "\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }", "feedInput": "\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }", "endOfInput": "\n    public void endOfInput() {\n        _endOfInput = true;\n    }", "releaseBuffered": "\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }", "_decodeEscaped": "\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }", "nextToken": "\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            // note: if so, do not even bother changing state\n            if (_endOfInput) { // except for this special case\n                // End-of-input within (possibly...) started token is bit complicated,\n                // so offline\n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: // expect field-name or end-object\n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: // expect comma + field-name or end-object\n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: // expect colon, followed by value\n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: // expect value or end-array\n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: // expect leading comma + value or end-array\n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }", "_finishToken": "\n    protected final JsonToken _finishToken() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        // Field name states\n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        // Value states\n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorToken();\n\n        // Comments\n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }", "_finishTokenWithEOF": "\n    protected final JsonToken _finishTokenWithEOF() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: // fine, just skip some trailing space\n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: // finished at token boundary; probably fine\n            return _eofAsNextToken();\n//        case MINOR_VALUE_EXPECTING_COMMA: // not fine\n//        case MINOR_VALUE_EXPECTING_COLON: // not fine\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorTokenWithEOF();\n\n        // Number-parsing states; valid stopping points, more explicit errors\n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            // NOTE: does NOT retain possible leading minus-sign (can change if\n            // absolutely needs be)\n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            // Fine: just need to ensure we have value fully defined\n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            // fall through\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            // How about comments? \n            // Inside C-comments; not legal\n\n//        case MINOR_COMMENT_LEADING_SLASH: // not legal, but use default error\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            // within C++/YAML comments, ok, as long as major state agrees...\n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; // never gets here\n    }", "_startDocument": "\n    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                // note: if so, do not even bother changing state\n                if (_endOfInput) { // except for this special case\n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }", "_finishBOM": "\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException\n    {\n        // public final static byte UTF8_BOM_1 = (byte) 0xEF;\n        // public final static byte UTF8_BOM_2 = (byte) 0xBB;\n        // public final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                // got it all; go back to \"start document\" handling, without changing\n                // minor state (to let it know we've done BOM)\n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }", "_startFieldName": "\n    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }", "_startFieldNameAfterComma": "\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { // either comma, separating entries, or closing right curly\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }", "_startValue": "\n    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': // c/c++ comments\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }", "_startValueExpectComma": "\n    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }", "_startValueExpectColon": "\n    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            // can not omit colon here\n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }", "_startValueAfterComma": "\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }", "_startUnexpectedValue": "\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }", "_skipWS": "\n    private final int _skipWS(int ch) throws IOException\n    {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }", "_startSlashComment": "\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { // c-style\n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { // c++-style\n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }", "_finishHashComment": "\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException\n    {\n        // Could by-pass this check by refactoring, but for now simplest way...\n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }", "_finishCppComment": "\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }", "_finishCComment": "\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }", "_startAfterComment": "\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }", "_startFalseToken": "\n    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }", "_startTrueToken": "\n    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }", "_startNullToken": "\n    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }", "_finishKeywordToken": "\n    protected JsonToken _finishKeywordToken(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }", "_finishKeywordTokenWithEOF": "\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }", "_finishNonStdToken": "\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }", "_finishNonStdTokenWithEOF": "\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }", "_finishErrorToken": "\n    protected JsonToken _finishErrorToken() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n// !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(i);\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                // 11-Jan-2016, tatu: note: we will fully consume the character,\n                // included or not, so if recovery was possible, it'd be off-by-one...\n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }", "_finishErrorTokenWithEOF": "\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException\n    {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }", "_reportErrorToken": "\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }", "_startPositiveNumber": "\n    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }", "_startNegativeNumber": "\n    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            // One special case: if first char is 0, must not be followed by a digit\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand, to ensure contiguous buffer, outPtr is the length\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }", "_startNumberLeadingZero": "\n    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            // Ok; unfortunately we have closing bracket/curly that are valid so need\n            // (colon not possible since this is within value, not after key)\n            // \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }", "_finishNumberMinus": "\n    protected JsonToken _finishNumberMinus(int ch) throws IOException\n    {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }", "_finishNumberLeadingZeroes": "\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 0 and 9\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }", "_finishNumberLeadingNegZeroes": "\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 1 and 9; go integral\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }", "_finishNumberIntegralPart": "\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException\n    {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }", "_startFloat": "\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; // but here we'll want to mask it to unsigned 8-bit\n                    // must be followed by sequence of ints, one minimum\n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }", "_finishFloatFraction": "\n    protected JsonToken _finishFloatFraction() throws IOException\n    {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        // caller guarantees at least one char; also, sign-extension not needed here\n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        // Ok, fraction done; what have we got next?\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        // Ok: end of floating point number or exponent?\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }", "_finishFloatExponent": "\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException\n    {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }", "_fastParseName": "\n    private final String _fastParseName() throws IOException\n    {\n        // If so, can also unroll loops nicely\n        // This may seem weird, but here we do NOT want to worry about UTF-8\n        // decoding. Rather, we'll assume that part is ok (if not it will be\n        // caught later on), and just handle quotes and backslashes here.\n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }", "_parseMediumName": "\n    private final String _parseMediumName(int ptr, int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { // 8 bytes\n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 7 bytes\n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // 6 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { // 5 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }", "_parseMediumName2": "\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { // 12 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        // Could continue\n        return null;\n    }", "_parseEscapedName": "\n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        // This may seem weird, but here we do not want to worry about\n        // UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n        // caught later on), and just handle quotes and backslashes here.\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            // Otherwise bit longer handling\n            if (ch == INT_QUOTE) { // we are done\n                break;\n            }\n            // Unquoted white space?\n            if (ch != INT_BACKSLASH) {\n                // Call can actually now return (if unquoted linefeeds allowed)\n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                // Nope, escape sequence\n                ch = _decodeCharEscape();\n                if (ch < 0) { // method has set up state about escape sequence\n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            // May need to UTF-8 (re-)encode it, if it's beyond\n            // 7-bit ASCII. Gets pretty messy. If this happens often, may\n            // want to use different name canonicalization to avoid these hits.\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                // Ok, we'll need room for first byte right away\n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { // 2-byte\n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    // Second byte gets output below:\n                } else { // 3 bytes; no need to worry about surrogates here\n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    // need room for middle byte?\n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                // And same last byte in both cases, gets output below:\n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare, but may happen\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }", "_handleOddName": "\n    private JsonToken _handleOddName(int ch) throws IOException\n    {\n        // First: may allow single quotes\n        switch (ch) {\n        case '#':\n            // Careful, since this may alternatively be leading char of\n            // unquoted name...\n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': // for better error reporting...\n            return _closeArrayScope();\n        }\n        // allow unquoted names if feature enabled:\n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         // !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(ch);\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        // Also: note that although we use a different table here, it does NOT handle UTF-8\n        // decoding. It'll just pass those high-bit codes as acceptable for later decoding.\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }", "_finishUnquotedName": "\n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        // Ok, now; instead of ultra-optimizing parsing here (as with regular JSON names),\n        // let's just use the generic \"slow\" variant. Can measure its impact later on if need be.\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }", "_finishAposName": "\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeCharEscape();\n                    if (ch < 0) { // method has set up state about escape sequence\n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare case but possible\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }", "_finishFieldWithEscape": "\n    protected final JsonToken _finishFieldWithEscape() throws IOException\n    {\n        // First: try finishing what wasn't yet:\n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { // ... if possible\n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            // Ok, we'll need room for first byte right away\n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { // 2-byte\n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                // Second byte gets output below:\n            } else { // 3 bytes; no need to worry about surrogates here\n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                // need room for middle byte?\n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            // And same last byte in both cases, gets output below:\n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }", "_decodeSplitEscaped": "\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { // expecting first char after backslash\n            switch (c) {\n                // First, ones that are mapped\n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                // And these are to be returned as they are\n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': // and finally hex-escaped\n                break;\n    \n            default:\n                {\n                 // !!! TODO: Decode UTF-8 characters properly...\n    //              char ch = (char) _decodeCharForError(c);\n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }", "_startString": "\n    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }", "_finishRegularString": "\n    private final JsonToken _finishRegularString() throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }", "_startAposString": "\n    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }", "_finishAposString": "\n    private final JsonToken _finishAposString() throws IOException\n    {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Escape or multi-byte?\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }", "_decodeSplitMultiByte": "\n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext)\n            throws IOException\n    {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: // 2-byte UTF; easy, either got both, or just miss one\n            if (gotNext) {\n                // NOTE: always succeeds, no need to check\n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: // 3-byte UTF\n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: // 4-byte UTF\n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                // Note: call can now actually return (to allow unquoted linefeeds)\n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }", "_decodeSplitUTF8_3": "\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }", "_decodeSplitUTF8_4": "\n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        // Let's add first part right away:\n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        // And let the other char output down below\n        _textBuffer.append((char) c);\n        return true;\n    }", "_decodeCharEscape": "\n    private final int _decodeCharEscape() throws IOException\n    {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { // offline boundary-checking case:\n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }", "_decodeFastCharEscape": "\n    private final int _decodeFastCharEscape() throws IOException\n    {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            {\n             // !!! TODO: Decode UTF-8 characters properly...\n//              char ch = (char) _decodeCharForError(c);\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }", "_decodeUTF8_2": "\n    private final int _decodeUTF8_2(int c, int d) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }", "_decodeUTF8_3": "\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n    {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }", "_decodeUTF8_4": "\n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }"}