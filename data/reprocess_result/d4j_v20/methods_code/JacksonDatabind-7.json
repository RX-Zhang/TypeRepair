{"version": "\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "asParser": "\n    public JsonParser asParser()\n    {\n        return asParser(_objectCodec);\n    }", "firstToken": "\n    public JsonToken firstToken() {\n        if (_first != null) {\n            return _first.type(0);\n        }\n        return null;\n    }", "append": "\n    public TokenBuffer append(TokenBuffer other)\n        throws IOException, JsonGenerationException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {  \n            _hasNativeTypeIds = other.canWriteTypeId();\n        }\n        if (!_hasNativeObjectIds) {\n            _hasNativeObjectIds = other.canWriteObjectId();\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }", "serialize": "\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }", "deserialize": "\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n            copyCurrentStructure(jp);\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        return this;\n    }", "toString": "\n    public String toString()\n    {\n        // Let's print up to 100 first tokens...\n        final int MAX_COUNT = 100;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[TokenBuffer: \");\n\n        /*\nsb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\nsb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n*/\n        \n        JsonParser jp = asParser();\n        int count = 0;\n        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n\n        while (true) {\n            JsonToken t;\n            try {\n                t = jp.nextToken();\n                if (t == null) break;\n\n                if (hasNativeIds) {\n                    _appendNativeIds(sb);\n                }\n                        \n                if (count < MAX_COUNT) {\n                    if (count > 0) {\n                        sb.append(\", \");\n                    }\n                    sb.append(t.toString());\n                    if (t == JsonToken.FIELD_NAME) {\n                        sb.append('(');\n                        sb.append(jp.getCurrentName());\n                        sb.append(')');\n                    }\n                }\n            } catch (IOException ioe) { // should never occur\n                throw new IllegalStateException(ioe);\n            }\n            ++count;\n        }\n\n        if (count >= MAX_COUNT) {\n            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }", "_appendNativeIds": "\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n        Object objectId = _last.findObjectId(_appendAt-1);\n        if (objectId != null) {\n            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n        }\n        Object typeId = _last.findTypeId(_appendAt-1);\n        if (typeId != null) {\n            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n        }\n    }", "enable": "\n    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }", "disable": "\n    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }", "isEnabled": "\n    public boolean isEnabled(Feature f) {\n        return (_generatorFeatures & f.getMask()) != 0;\n    }", "getFeatureMask": "\n    public int getFeatureMask() {\n        return _generatorFeatures;\n    }", "setFeatureMask": "\n    public JsonGenerator setFeatureMask(int mask) {\n        _generatorFeatures = mask;\n        return this;\n    }", "useDefaultPrettyPrinter": "\n    public JsonGenerator useDefaultPrettyPrinter() {\n        // No-op: we don't indent\n        return this;\n    }", "setCodec": "\n    public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }", "getCodec": "\n    public ObjectCodec getCodec() { return _objectCodec; }", "getOutputContext": "\n    public final JsonWriteContext getOutputContext() { return _writeContext; }", "canWriteBinaryNatively": "\n    public boolean canWriteBinaryNatively() {\n        return true;\n    }", "flush": "\n    public void flush() throws IOException { /* NOP */ }", "close": "\n    public void close() throws IOException {\n        _closed = true;\n    }", "isClosed": "\n    public boolean isClosed() { return _closed; }", "writeStartArray": "\n    public final void writeStartArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }", "writeEndArray": "\n    public final void writeEndArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }", "writeStartObject": "\n    public final void writeStartObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }", "writeEndObject": "\n    public final void writeEndObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n            _writeContext = c;\n        }\n    }", "writeFieldName": "\n    public final void writeFieldName(String name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }", "writeString": "\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n            writeNull();\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }", "writeRawUTF8String": "\n    public void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }", "writeUTF8String": "\n    public void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }", "writeRaw": "\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }", "writeRawValue": "\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }", "writeNumber": "\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }", "writeBoolean": "\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }", "writeNull": "\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }", "writeObject": "\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class) {\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n            return;\n        } else if (_objectCodec == null) {\n            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n             *   err out, or just embed? For now, do latter.\n             */\n//          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }", "writeTree": "\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n            writeNull();\n            return;\n        }\n\n        if (_objectCodec == null) {\n            // as with 'writeObject()', is codec optional?\n            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }", "writeBinary": "\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }", "canWriteTypeId": "\n    public boolean canWriteTypeId() {\n        return _hasNativeTypeIds;\n    }", "canWriteObjectId": "\n    public boolean canWriteObjectId() {\n        return _hasNativeObjectIds;\n    }", "writeTypeId": "\n    public void writeTypeId(Object id) {\n        _typeId = id;\n        _hasNativeId = true;\n    }", "writeObjectId": "\n    public void writeObjectId(Object id) {\n        _objectId = id;\n        _hasNativeId = true;\n    }", "copyCurrentEvent": "\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }", "copyCurrentStructure": "\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }", "_checkNativeIds": "\n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }", "_append": "\n    protected final void _append(JsonToken type)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, _objectId, _typeId)\n                : _last.append(_appendAt, type);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1; // since we added first at 0\n        }\n    }", "_appendRaw": "\n    protected final void _appendRaw(int rawType, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n                : _last.appendRaw(_appendAt, rawType, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }", "_reportUnsupportedOperation": "\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n    }", "setLocation": "\n        public void setLocation(JsonLocation l) {\n            _location = l;\n        }", "peekNextToken": "\n        public JsonToken peekNextToken()\n            throws IOException, JsonParseException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                seg = (seg == null) ? null : seg.next();\n            }\n            return (seg == null) ? null : seg.type(ptr);\n        }", "nextToken": "\n        public JsonToken nextToken() throws IOException, JsonParseException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n                _segmentPtr = 0;\n                _segment = _segment.next();\n                if (_segment == null) {\n                    return null;\n                }\n            }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n                _parsingContext.setCurrentName(name);\n            } else if (_currToken == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            } else if (_currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n                // Closing JSON Object/Array? Close matching context\n                _parsingContext = _parsingContext.getParent();\n                // but allow unbalanced cases too (more close markers)\n                if (_parsingContext == null) {\n                    _parsingContext = JsonReadContext.createRootContext(null);\n                }\n            }\n            return _currToken;\n        }", "getParsingContext": "\n        public JsonStreamContext getParsingContext() { return _parsingContext; }", "getTokenLocation": "\n        public JsonLocation getTokenLocation() { return getCurrentLocation(); }", "getCurrentLocation": "\n        public JsonLocation getCurrentLocation() {\n            return (_location == null) ? JsonLocation.NA : _location;\n        }", "getCurrentName": "\n        public String getCurrentName() { return _parsingContext.getCurrentName(); }", "overrideCurrentName": "\n        public void overrideCurrentName(String name)\n        {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonReadContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            try {\n                ctxt.setCurrentName(name);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }", "getText": "\n        public String getText()\n        {\n            // common cases first:\n            if (_currToken == JsonToken.VALUE_STRING\n                    || _currToken == JsonToken.FIELD_NAME) {\n                Object ob = _currentObject();\n                if (ob instanceof String) {\n                    return (String) ob;\n                }\n                return (ob == null) ? null : ob.toString();\n            }\n            if (_currToken == null) {\n                return null;\n            }\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                Object ob = _currentObject();\n                return (ob == null) ? null : ob.toString();\n            default:\n            \treturn _currToken.asString();\n            }\n        }", "getTextCharacters": "\n        public char[] getTextCharacters() {\n            String str = getText();\n            return (str == null) ? null : str.toCharArray();\n        }", "getTextLength": "\n        public int getTextLength() {\n            String str = getText();\n            return (str == null) ? 0 : str.length();\n        }", "getTextOffset": "\n        public int getTextOffset() { return 0; }", "hasTextCharacters": "\n        public boolean hasTextCharacters() {\n            // We never have raw buffer available, so:\n            return false;\n        }", "getBigIntegerValue": "\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n                return (BigInteger) n;\n            }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }", "getDecimalValue": "\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n                return (BigDecimal) n;\n            }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }", "getDoubleValue": "\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }", "getFloatValue": "\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }", "getIntValue": "\n        public int getIntValue() throws IOException, JsonParseException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return ((Number) _currentObject()).intValue();\n            }\n            return getNumberValue().intValue();\n        }", "getLongValue": "\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }", "getNumberType": "\n        public NumberType getNumberType() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }", "getNumberValue": "\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                return (Number) value;\n            }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n                String str = (String) value;\n                if (str.indexOf('.') >= 0) {\n                    return Double.parseDouble(str);\n                }\n                return Long.parseLong(str);\n            }\n            if (value == null) {\n                return null;\n            }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }", "getEmbeddedObject": "\n        public Object getEmbeddedObject()\n        {\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                return _currentObject();\n            }\n            return null;\n        }", "getBinaryValue": "\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n                // Embedded byte array would work nicely...\n                Object ob = _currentObject();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n                // fall through to error case\n            }\n            if (_currToken != JsonToken.VALUE_STRING) {\n                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n            }\n            final String str = getText();\n            if (str == null) {\n                return null;\n            }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n                _byteBuilder = builder = new ByteArrayBuilder(100);\n            } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }", "readBinaryValue": "\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n                out.write(data, 0, data.length);\n                return data.length;\n            }\n            return 0;\n        }", "canReadObjectId": "\n        public boolean canReadObjectId() {\n            return _hasNativeObjectIds;\n        }", "canReadTypeId": "\n        public boolean canReadTypeId() {\n            return _hasNativeTypeIds;\n        }", "getTypeId": "\n        public Object getTypeId() {\n            return _segment.findTypeId(_segmentPtr);\n        }", "getObjectId": "\n        public Object getObjectId() {\n            return _segment.findObjectId(_segmentPtr);\n        }", "_currentObject": "\n        protected final Object _currentObject() {\n            return _segment.get(_segmentPtr);\n        }", "_checkIsNumber": "\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }", "_handleEOF": "\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }", "type": "\n        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }", "rawType": "\n        public int rawType(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return ix;\n        }", "get": "\n        public Object get(int index) {\n            return _tokens[index];\n        }", "next": "\n        public Segment next() { return _next; }", "hasIds": "\n        public boolean hasIds() {\n            return _nativeIds != null;\n        }", "appendRaw": "\n        public Segment appendRaw(int index, int rawTokenType, Object value)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, rawTokenType, value);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, rawTokenType, value);\n            return _next;\n        }", "set": "\n        private void set(int index, JsonToken tokenType)\n        {\n            /* Assumption here is that there are no overwrites, just appends;\n             * and so no masking is needed (nor explicit setting of null)\n             */\n            long typeCode = tokenType.ordinal();\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n        }", "assignNativeIds": "\n        private final void assignNativeIds(int index, Object objectId, Object typeId)\n        {\n            if (_nativeIds == null) {\n                _nativeIds = new TreeMap<Integer,Object>();\n            }\n            if (objectId != null) {\n                _nativeIds.put(_objectIdIndex(index), objectId);\n            }\n            if (typeId != null) {\n                _nativeIds.put(_typeIdIndex(index), typeId);\n            }\n        }", "findObjectId": "\n        public Object findObjectId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n        }", "findTypeId": "\n        public Object findTypeId(int index) {\n            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n        }", "_typeIdIndex": "\n        private final int _typeIdIndex(int i) { return i+i; }", "_objectIdIndex": "\n        private final int _objectIdIndex(int i) { return i+i+1; }"}