{"nodeName": "\n    public abstract String nodeName();\n\n    /**\n     * Get an attribute's value by its key.\n     * <p>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.", "attr": "\n    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }", "attributes": "\n    public Attributes attributes() {\n        return attributes;\n    }", "hasAttr": "\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }", "removeAttr": "\n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }", "baseUri": "\n    public String baseUri() {\n        return baseUri;\n    }", "setBaseUri": "\n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.baseUri = baseUri;\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }", "absUrl": "\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            return StringUtil.resolve(baseUri, attr(attributeKey));\n        }\n    }", "childNode": "\n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }", "childNodes": "\n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }", "childNodesCopy": "\n    public List<Node> childNodesCopy() {\n        List<Node> children = new ArrayList<Node>(childNodes.size());\n        for (Node node : childNodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }", "childNodeSize": "\n    public final int childNodeSize() {\n        return childNodes.size();\n    }", "childNodesAsArray": "\n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodeSize()]);\n    }", "parent": "\n    public Node parent() {\n        return parentNode;\n    }", "parentNode": "\n    public final Node parentNode() {\n        return parentNode;\n    }", "ownerDocument": "\n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }", "remove": "\n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }", "before": "\n    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }", "after": "\n    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }", "addSiblingHtml": "\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }", "wrap": "\n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }", "unwrap": "\n    public Node unwrap() {\n        Validate.notNull(parentNode);\n\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }", "getDeepChild": "\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }", "replaceWith": "\n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }", "setParentNode": "\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }", "replaceChild": "\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        final int index = out.siblingIndex;\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }", "removeChild": "\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        childNodes.remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }", "addChildren": "\n    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        for (Node child: children) {\n            reparentChild(child);\n            ensureChildNodes();\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }", "ensureChildNodes": "\n    protected void ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new ArrayList<Node>(4);\n        }\n    }", "reparentChild": "\n    protected void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }", "reindexChildren": "\n    private void reindexChildren(int start) {\n        for (int i = start; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }", "siblingNodes": "\n    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.childNodes;\n        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }", "nextSibling": "\n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        final List<Node> siblings = parentNode.childNodes;\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }", "previousSibling": "\n    public Node previousSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        if (siblingIndex > 0)\n            return parentNode.childNodes.get(siblingIndex-1);\n        else\n            return null;\n    }", "siblingIndex": "\n    public int siblingIndex() {\n        return siblingIndex;\n    }", "setSiblingIndex": "\n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }", "traverse": "\n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        traversor.traverse(this);\n        return this;\n    }", "outerHtml": "\n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(128);\n        outerHtml(accum);\n        return accum.toString();\n    }", "getOutputSettings": "\n    Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }", "outerHtmlHead": "\n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }", "outerHtmlTail": "\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }", "toString": "\n    public String toString() {\n        return outerHtml();\n    }", "indent": "\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }", "equals": "\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Node node = (Node) o;\n\n        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n    }", "hashCode": "\n    public int hashCode() {\n        int result = childNodes != null ? childNodes.hashCode() : 0;\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }", "clone": "\n    public Node clone() {\n        Node thisClone = doClone(null); // splits for orphan\n\n        // Queue up nodes that need their children cloned (BFS).\n        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            for (int i = 0; i < currParent.childNodes.size(); i++) {\n                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n                currParent.childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }", "doClone": "\n    protected Node doClone(Node parent) {\n        Node clone;\n\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n\n        for (Node child: childNodes)\n            clone.childNodes.add(child);\n\n        return clone;\n    }", "head": "\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }", "tail": "\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n                node.outerHtmlTail(accum, depth, out);\n        }"}