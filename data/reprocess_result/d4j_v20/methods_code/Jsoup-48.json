{"connect": "\n    public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }", "encodeUrl": "\n\tprivate static String encodeUrl(String url) {\n\t\tif(url == null)\n\t\t\treturn null;\n    \treturn url.replaceAll(\" \", \"%20\");\n\t}", "encodeMimeName": "\n    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }", "url": "\n    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }", "userAgent": "\n    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(\"User-Agent\", userAgent);\n        return this;\n    }", "timeout": "\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }", "maxBodySize": "\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }", "followRedirects": "\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }", "referrer": "\n    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }", "method": "\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }", "ignoreHttpErrors": "\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}", "ignoreContentType": "\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }", "validateTLSCertificates": "\n    public Connection validateTLSCertificates(boolean value) {\n        req.validateTLSCertificates(value);\n        return this;\n    }", "data": "\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }", "header": "\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }", "cookie": "\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }", "cookies": "\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }", "parser": "\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }", "get": "\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }", "post": "\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }", "execute": "\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }", "request": "\n    public Connection.Request request() {\n        return req;\n    }", "response": "\n    public Connection.Response response() {\n        return res;\n    }", "postDataCharset": "\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }", "hasHeader": "\n        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeaderCaseInsensitive(name) != null;\n        }", "hasHeaderWithValue": "\n        public boolean hasHeaderWithValue(String name, String value) {\n            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n        }", "removeHeader": "\n        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, String> entry = scanHeaders(name); // remove is case insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }", "headers": "\n        public Map<String, String> headers() {\n            return headers;\n        }", "getHeaderCaseInsensitive": "\n        private String getHeaderCaseInsensitive(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            // quick evals for common case of title case, lower case, then scan for mixed\n            String value = headers.get(name);\n            if (value == null)\n                value = headers.get(name.toLowerCase());\n            if (value == null) {\n                Map.Entry<String, String> entry = scanHeaders(name);\n                if (entry != null)\n                    value = entry.getValue();\n            }\n            return value;\n        }", "scanHeaders": "\n        private Map.Entry<String, String> scanHeaders(String name) {\n            String lc = name.toLowerCase();\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(lc))\n                    return entry;\n            }\n            return null;\n        }", "hasCookie": "\n        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }", "removeCookie": "\n        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }", "statusCode": "\n        public int statusCode() {\n            return statusCode;\n        }", "statusMessage": "\n        public String statusMessage() {\n            return statusMessage;\n        }", "charset": "\n        public String charset() {\n            return charset;\n        }", "contentType": "\n        public String contentType() {\n            return contentType;\n        }", "parse": "\n        public Document parse() throws IOException {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n            byteData.rewind();\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            return doc;\n        }", "body": "\n        public String body() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body;\n            if (charset == null)\n                body = Charset.forName(DataUtil.defaultCharset).decode(byteData).toString();\n            else\n                body = Charset.forName(charset).decode(byteData).toString();\n            byteData.rewind();\n            return body;\n        }", "bodyAsBytes": "\n        public byte[] bodyAsBytes() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            return byteData.array();\n        }", "createConnection": "\n        private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout());\n\n            if (conn instanceof HttpsURLConnection) {\n                if (!req.validateTLSCertificates()) {\n                    initUnSecureTSL();\n                    ((HttpsURLConnection)conn).setSSLSocketFactory(sslSocketFactory);\n                    ((HttpsURLConnection)conn).setHostnameVerifier(getInsecureVerifier());\n                }\n            }\n\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            if (req.cookies().size() > 0)\n                conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n            for (Map.Entry<String, String> header : req.headers().entrySet()) {\n                conn.addRequestProperty(header.getKey(), header.getValue());\n            }\n            return conn;\n        }", "getInsecureVerifier": "\n        private static HostnameVerifier getInsecureVerifier() {\n            return new HostnameVerifier() {\n                public boolean verify(String urlHostName, SSLSession session) {\n                    return true;\n                }\n            };\n        }", "initUnSecureTSL": "\n        private static synchronized void initUnSecureTSL() throws IOException {\n            if (sslSocketFactory == null) {\n                // Create a trust manager that does not validate certificate chains\n                final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n\n                    public void checkClientTrusted(final X509Certificate[] chain, final String authType) {\n                    }\n\n                    public void checkServerTrusted(final X509Certificate[] chain, final String authType) {\n                    }\n\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                }};\n\n                // Install the all-trusting trust manager\n                final SSLContext sslContext;\n                try {\n                    sslContext = SSLContext.getInstance(\"SSL\");\n                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                    // Create an ssl socket factory with our all-trusting manager\n                    sslSocketFactory = sslContext.getSocketFactory();\n                } catch (NoSuchAlgorithmException e) {\n                    throw new IOException(\"Can't create unsecure trust manager\");\n                } catch (KeyManagementException e) {\n                    throw new IOException(\"Can't create unsecure trust manager\");\n                }\n            }\n\n        }", "setupFromConnection": "\n        private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            // if from a redirect, map previous response cookies into this response\n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n            }\n        }", "createHeaderMap": "\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<String>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }", "processResponseHeaders": "\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                    if (!values.isEmpty())\n                        header(name, values.get(0));\n                }\n            }\n        }", "setOutputContentType": "\n        private static String setOutputContentType(final Connection.Request req) {\n            // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n            boolean needsMulti = false;\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (keyVal.hasInputStream()) {\n                    needsMulti = true;\n                    break;\n                }\n            }\n            String bound = null;\n            if (needsMulti) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }", "writePost": "\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n\n            if (bound != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else {\n                // regular form data (application/x-www-form-urlencoded)\n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }", "getRequestCookieString": "\n        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = new StringBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                // todo: spec says only ascii, no escaping / encoding defined. validate on set? or escape somehow here?\n            }\n            return sb.toString();\n        }", "serialiseRequestUrl": "\n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = new StringBuilder();\n            boolean first = true;\n            // reconstitute the query, ready for appends\n            url\n                .append(in.getProtocol())\n                .append(\"://\")\n                .append(in.getAuthority()) // includes host, port\n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(url.toString()));\n            req.data().clear(); // moved into url as get params\n        }", "create": "\n        public static KeyVal create(String key, String value) {\n            return new KeyVal().key(key).value(value);\n        }", "key": "\n        public KeyVal key(String key) {\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            this.key = key;\n            return this;\n        }", "value": "\n        public KeyVal value(String value) {\n            Validate.notNull(value, \"Data value must not be null\");\n            this.value = value;\n            return this;\n        }", "inputStream": "\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNull(value, \"Data input stream must not be null\");\n            this.stream = inputStream;\n            return this;\n        }", "hasInputStream": "\n        public boolean hasInputStream() {\n            return stream != null;\n        }", "toString": "\n        public String toString() {\n            return key + \"=\" + value;\n        }"}