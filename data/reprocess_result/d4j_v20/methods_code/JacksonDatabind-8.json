{"constructValueInstantiator": "\n    public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n    {\n        JavaType delegateType;\n        boolean maybeVanilla = !_hasNonDefaultCreator;\n\n        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {\n            delegateType = null;\n        } else {\n            // need to find type...\n            int ix = 0;\n            if (_delegateArgs != null) {\n                for (int i = 0, len = _delegateArgs.length; i < len; ++i) {\n                    if (_delegateArgs[i] == null) { // marker for delegate itself\n                        ix = i;\n                        break;\n                    }\n                }\n            }\n            TypeBindings bindings = _beanDesc.bindingsForBeanType();\n            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));\n        }\n\n        final JavaType type = _beanDesc.getType();\n\n        // Any non-standard creator will prevent; with one exception: int-valued constructor\n        // that standard containers have can be ignored\n        maybeVanilla &= !_hasNonDefaultCreator;\n\n        if (maybeVanilla) {\n            /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one\n             *   of \"well-known\" types, can create a non-reflection-based instantiator.\n             */\n            final Class<?> rawType = type.getRawClass();\n            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n                return new Vanilla(Vanilla.TYPE_COLLECTION);\n            }\n            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n                return new Vanilla(Vanilla.TYPE_MAP);\n            }\n            if (rawType == HashMap.class) {\n                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n            }\n        }\n        \n        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n                _creators[C_DELEGATE], delegateType, _delegateArgs,\n                _creators[C_PROPS], _propertyBasedArgs);\n        inst.configureFromStringCreator(_creators[C_STRING]);\n        inst.configureFromIntCreator(_creators[C_INT]);\n        inst.configureFromLongCreator(_creators[C_LONG]);\n        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n        inst.configureIncompleteParameter(_incompleteParameter);\n        return inst;\n    }", "setDefaultCreator": "\n    public void setDefaultCreator(AnnotatedWithParams creator) {\n        _creators[C_DEFAULT] = _fixAccess(creator);\n    }", "addStringCreator": "\n    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_STRING, explicit);\n    }", "addIntCreator": "\n    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_INT, explicit);\n    }", "addLongCreator": "\n    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_LONG, explicit);\n    }", "addDoubleCreator": "\n    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_DOUBLE, explicit);\n    }", "addBooleanCreator": "\n    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n        verifyNonDup(creator, C_BOOLEAN, explicit);\n    }", "addDelegatingCreator": "\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n            CreatorProperty[] injectables)\n    {\n        verifyNonDup(creator, C_DELEGATE, explicit);\n        _delegateArgs = injectables;\n    }", "addPropertyCreator": "\n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n            CreatorProperty[] properties)\n    {\n        verifyNonDup(creator, C_PROPS, explicit);\n        // [JACKSON-470] Better ensure we have no duplicate names either...\n        if (properties.length > 1) {\n            HashMap<String,Integer> names = new HashMap<String,Integer>();\n            for (int i = 0, len = properties.length; i < len; ++i) {\n                String name = properties[i].getName();\n                /* [Issue-13]: Need to consider Injectables, which may not have\n                 *   a name at all, and need to be skipped\n                 */\n                if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n                    continue;\n                }\n                Integer old = names.put(name, Integer.valueOf(i));\n                if (old != null) {\n                    throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n                }\n            }\n        }\n        _propertyBasedArgs = properties;\n    }", "addIncompeteParameter": "\n    public void addIncompeteParameter(AnnotatedParameter parameter) {\n        if (_incompleteParameter == null) {\n            _incompleteParameter = parameter;\n        }\n    }", "verifyNonDup": "\n    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex) {\n        verifyNonDup(newOne, typeIndex, false);\n        return _creators[typeIndex];\n    }", "hasDefaultCreator": "\n    public boolean hasDefaultCreator() {\n        return _creators[C_DEFAULT] != null;\n    }", "_fixAccess": "\n    private <T extends AnnotatedMember> T _fixAccess(T member)\n    {\n        if (member != null && _canFixAccess) {\n            ClassUtil.checkAndFixAccess((Member) member.getAnnotated());\n        }\n        return member;\n    }", "getValueTypeDesc": "\n        public String getValueTypeDesc() {\n            switch (_type) {\n            case TYPE_COLLECTION: return ArrayList.class.getName();\n            case TYPE_MAP: return LinkedHashMap.class.getName();\n            case TYPE_HASH_MAP: return HashMap.class.getName();\n            }\n            return Object.class.getName();\n        }", "canInstantiate": "\n        public boolean canInstantiate() { return true; }", "canCreateUsingDefault": "\n        public boolean canCreateUsingDefault() {  return true; }", "createUsingDefault": "\n        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n            switch (_type) {\n            case TYPE_COLLECTION: return new ArrayList<Object>();\n            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n            }\n            throw new IllegalStateException(\"Unknown type \"+_type);\n        }"}