{"builder": "\n    public static Builder builder(JavaType beanType) {\n        return new Builder(beanType);\n    }", "start": "\n    public ExternalTypeHandler start() {\n        return new ExternalTypeHandler(this);\n    }", "handleTypePropertyValue": "\n    public boolean handleTypePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean)\n        throws IOException\n    {\n        Object ob = _nameToPropertyIndex.get(propName);\n        if (ob == null) {\n            return false;\n        }\n        final String typeId = p.getText();\n        // 28-Nov-2016, tatu: For [databind#291], need separate handling\n        if (ob instanceof List<?>) {\n            boolean result = false;\n            for (Integer index : (List<Integer>) ob) {\n                if (_handleTypePropertyValue(p, ctxt, propName, bean,\n                        typeId, index.intValue())) {\n                    result = true;\n                }\n            }\n            return result;\n        }\n        return _handleTypePropertyValue(p, ctxt, propName, bean,\n                typeId, ((Integer) ob).intValue());\n    }", "_handleTypePropertyValue": "\n    private final boolean _handleTypePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean, String typeId, int index)\n        throws IOException\n    {\n        ExtTypedProperty prop = _properties[index];\n        if (!prop.hasTypePropertyName(propName)) { // when could/should this ever happen?\n            return false;\n        }\n        // note: can NOT skip child values (should always be String anyway)\n        boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n        // Minor optimization: deserialize properties as soon as we have all we need:\n        if (canDeserialize) {\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            // clear stored data, to avoid deserializing+setting twice:\n            _tokens[index] = null;\n        } else {\n            _typeIds[index] = typeId;\n        }\n        return true;\n    }", "handlePropertyValue": "\n    public boolean handlePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean) throws IOException\n    {\n        Object ob = _nameToPropertyIndex.get(propName);\n        if (ob == null) {\n            return false;\n        }\n        // 28-Nov-2016, tatu: For [databind#291], need separate handling\n        if (ob instanceof List<?>) {\n            Iterator<Integer> it = ((List<Integer>) ob).iterator();\n            Integer index = it.next();\n\n            ExtTypedProperty prop = _properties[index];\n            // For now, let's assume it's same type (either type id OR value)\n            // for all mappings, so we'll only check first one\n            if (prop.hasTypePropertyName(propName)) {\n                String typeId = p.getText();\n                p.skipChildren();\n                _typeIds[index] = typeId;\n                while (it.hasNext()) {\n                    _typeIds[it.next()] = typeId;\n                }\n            } else {\n                @SuppressWarnings(\"resource\")\n                TokenBuffer tokens = new TokenBuffer(p, ctxt);\n                tokens.copyCurrentStructure(p);\n                _tokens[index] = tokens;\n                while (it.hasNext()) {\n                    _tokens[it.next()] = tokens;\n                }\n            }\n            return true;\n        }\n\n        // Otherwise only maps to a single value, in which case we can\n        // handle things in bit more optimal way...\n        int index = ((Integer) ob).intValue();\n        ExtTypedProperty prop = _properties[index];\n        boolean canDeserialize;\n        if (prop.hasTypePropertyName(propName)) {\n            _typeIds[index] = p.getText();\n            p.skipChildren();\n            canDeserialize = (bean != null) && (_tokens[index] != null);\n        } else {\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tokens = new TokenBuffer(p, ctxt);\n            tokens.copyCurrentStructure(p);\n            _tokens[index] = tokens;\n            canDeserialize = (bean != null) && (_typeIds[index] != null);\n        }\n        // Minor optimization: let's deserialize properties as soon as\n        // we have all pertinent information:\n        if (canDeserialize) {\n            String typeId = _typeIds[index];\n            // clear stored data, to avoid deserializing+setting twice:\n            _typeIds[index] = null;\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            _tokens[index] = null;\n        }\n        return true;\n    }", "complete": "\n    public Object complete(JsonParser p, DeserializationContext ctxt, Object bean)\n        throws IOException\n    {\n        for (int i = 0, len = _properties.length; i < len; ++i) {\n            String typeId = _typeIds[i];\n            if (typeId == null) {\n                TokenBuffer tokens = _tokens[i];\n                // let's allow missing both type and property (may already have been set, too)\n                // but not just one\n                if (tokens == null) {\n                    continue;\n                }\n                // [databind#118]: Need to mind natural types, for which no type id\n                // will be included.\n                JsonToken t = tokens.firstToken();\n                if (t.isScalarValue()) { // can't be null as we never store empty buffers\n                    JsonParser buffered = tokens.asParser(p);\n                    buffered.nextToken();\n                    SettableBeanProperty extProp = _properties[i].getProperty();\n                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());\n                    if (result != null) {\n                        extProp.set(bean, result);\n                        continue;\n                    }\n                    // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                    if (!_properties[i].hasDefaultType()) {\n                        ctxt.reportInputMismatch(bean.getClass(),\n                                \"Missing external type id property '%s'\",\n                                _properties[i].getTypePropertyName());                                \n                    } else  {\n                        typeId = _properties[i].getDefaultTypeId();\n                    }\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = _properties[i].getProperty();\n\n                if(prop.isRequired() ||\n                        ctxt.isEnabled(DeserializationFeature.FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY)) {\n                    ctxt.reportInputMismatch(bean.getClass(),\n                            \"Missing property '%s' for external type id '%s'\",\n                            prop.getName(), _properties[i].getTypePropertyName());\n                }\n                return bean;\n            }\n            _deserializeAndSet(p, ctxt, bean, i, typeId);\n        }\n        return bean;\n    }", "_deserialize": "\n    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        return _properties[index].getProperty().deserialize(mp, ctxt);\n    }", "_deserializeAndSet": "\n    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, int index, String typeId) throws IOException\n    {\n        /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n         * style to ensure we can handle all kinds of JSON constructs.\n         */\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            _properties[index].getProperty().set(bean, null);\n            return;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);\n    }", "addExternal": "\n        public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser)\n        {\n            Integer index = _properties.size();\n            _properties.add(new ExtTypedProperty(property, typeDeser));\n            _addPropertyIndex(property.getName(), index);\n            _addPropertyIndex(typeDeser.getPropertyName(), index);\n        }", "_addPropertyIndex": "\n        private void _addPropertyIndex(String name, Integer index) {\n            Object ob = _nameToPropertyIndex.get(name);\n            if (ob == null) {\n                _nameToPropertyIndex.put(name, index);\n            } else if (ob instanceof List<?>) {\n                @SuppressWarnings(\"unchecked\")\n                List<Object> list = (List<Object>) ob;\n                list.add(index);\n            } else {\n                List<Object> list = new LinkedList<>();\n                list.add(ob);\n                list.add(index);\n                _nameToPropertyIndex.put(name, list);\n            }\n        }", "build": "\n        public ExternalTypeHandler build(BeanPropertyMap otherProps) {\n            // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also\n            final int len = _properties.size();\n            ExtTypedProperty[] extProps = new ExtTypedProperty[len];\n            for (int i = 0; i < len; ++i) {\n                ExtTypedProperty extProp = _properties.get(i);\n                String typePropId = extProp.getTypePropertyName();\n                SettableBeanProperty typeProp = otherProps.find(typePropId);\n                if (typeProp != null) {\n                    extProp.linkTypeProperty(typeProp);\n                }\n                extProps[i] = extProp;\n            }\n            return new ExternalTypeHandler(_beanType, extProps, _nameToPropertyIndex,\n                    null, null);\n        }", "linkTypeProperty": "\n        public void linkTypeProperty(SettableBeanProperty p) {\n            _typeProperty = p;\n        }", "hasTypePropertyName": "\n        public boolean hasTypePropertyName(String n) {\n            return n.equals(_typePropertyName);\n        }", "hasDefaultType": "\n        public boolean hasDefaultType() {\n            return _typeDeserializer.getDefaultImpl() != null;\n        }", "getDefaultTypeId": "\n        public String getDefaultTypeId() {\n            Class<?> defaultType = _typeDeserializer.getDefaultImpl();\n            if (defaultType == null) {\n                return null;\n            }\n            return _typeDeserializer.getTypeIdResolver().idFromValueAndType(null, defaultType);\n        }", "getTypePropertyName": "\n        public String getTypePropertyName() { return _typePropertyName; }", "getProperty": "\n        public SettableBeanProperty getProperty() {\n            return _property;\n        }", "getTypeProperty": "\n        public SettableBeanProperty getTypeProperty() {\n            return _typeProperty;\n        }"}