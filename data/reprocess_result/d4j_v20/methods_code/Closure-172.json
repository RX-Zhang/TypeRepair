{"resolve": "\n    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }", "createScope": "\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      JSType globalThis =\n          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n\n      // Mark the main root, the externs root, and the src root\n      // with the global this type.\n      root.setJSType(globalThis);\n      root.getFirstChild().setJSType(globalThis);\n      root.getLastChild().setJSType(globalThis);\n\n      // Run a first-order analysis over the syntax tree.\n      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))\n          .process(root.getFirstChild(), root.getLastChild());\n\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type.isFunctionType()) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        JSType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes,\n          delegateCallingConventions);\n    }\n\n    newScope.setTypeResolver(scopeBuilder);\n    return newScope;\n  }", "patchGlobalScope": "\n  void patchGlobalScope(Scope globalScope, Node scriptRoot) {\n    // Preconditions: This is supposed to be called only on (named) SCRIPT nodes\n    // and a global typed scope should have been generated already.\n    Preconditions.checkState(scriptRoot.isScript());\n    Preconditions.checkNotNull(globalScope);\n    Preconditions.checkState(globalScope.isGlobal());\n\n    String scriptName = NodeUtil.getSourceName(scriptRoot);\n    Preconditions.checkNotNull(scriptName);\n    for (Node node : ImmutableList.copyOf(functionAnalysisResults.keySet())) {\n      if (scriptName.equals(NodeUtil.getSourceName(node))) {\n        functionAnalysisResults.remove(node);\n      }\n    }\n\n    (new FirstOrderFunctionAnalyzer(\n        compiler, functionAnalysisResults)).process(null, scriptRoot);\n\n    // TODO(bashir): Variable declaration is not the only side effect of last\n    // global scope generation but here we only wipe that part off!\n\n    // Remove all variables that were previously declared in this scripts.\n    // First find all vars to remove then remove them because of iterator!\n    Iterator<Var> varIter = globalScope.getVars();\n    List<Var> varsToRemove = Lists.newArrayList();\n    while (varIter.hasNext()) {\n      Var oldVar = varIter.next();\n      if (scriptName.equals(oldVar.getInputName())) {\n        varsToRemove.add(oldVar);\n      }\n    }\n    for (Var var : varsToRemove) {\n      globalScope.undeclare(var);\n      globalScope.getTypeOfThis().toObjectType().removeProperty(var.getName());\n    }\n\n    // Now re-traverse the given script.\n    GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(globalScope);\n    NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder);\n  }", "createInitialScope": "\n  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(\n        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n\n    Scope s = Scope.createGlobalScope(root);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // There is no longer a need to special case ActiveXObject\n    // but this remains here until we can get the extern forks\n    // cleaned up.\n    declareNativeValueType(s, \"ActiveXObject\", FUNCTION_INSTANCE_TYPE);\n\n    return s;\n  }", "declareNativeFunctionType": "\n  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }", "declareNativeValueType": "\n  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }", "declareNativeType": "\n  private static void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }", "visit": "\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      switch (node.getType()) {\n        case Token.VAR:\n          for (Node child = node.getFirstChild();\n               child != null; child = child.getNext()) {\n            identifyNameNode(\n                child, NodeUtil.getBestJSDocInfo(child));\n          }\n          break;\n        case Token.EXPR_RESULT:\n          Node firstChild = node.getFirstChild();\n          if (firstChild.isAssign()) {\n            identifyNameNode(\n                firstChild.getFirstChild(), firstChild.getJSDocInfo());\n          } else {\n            identifyNameNode(\n                firstChild, firstChild.getJSDocInfo());\n          }\n          break;\n      }\n    }", "identifyNameNode": "\n    private void identifyNameNode(\n        Node nameNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n      }\n    }", "getNativeType": "\n  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }", "setDeferredType": "\n    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }", "resolveTypes": "\n    public void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }", "shouldTraverse": "\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      inputId = t.getInputId();\n      if (n.isFunction() ||\n          n.isScript()) {\n        Preconditions.checkNotNull(inputId);\n        sourceName = NodeUtil.getSourceName(n);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      boolean descend = parent == null || !parent.isFunction() ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n\n      if (descend) {\n        // Handle hoisted functions on pre-order traversal, so that they\n        // get hit before other things in the scope.\n        if (NodeUtil.isStatementParent(n)) {\n          for (Node child = n.getFirstChild();\n               child != null;\n               child = child.getNext()) {\n            if (NodeUtil.isHoistedFunctionDeclaration(child)) {\n              defineFunctionLiteral(child);\n            }\n          }\n        }\n      }\n\n      return descend;\n    }", "attachLiteralTypes": "\n    private void attachLiteralTypes(Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          n.setJSType(getNativeType(STRING_TYPE));\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          JSDocInfo info = n.getJSDocInfo();\n          if (info != null &&\n              info.getLendsName() != null) {\n            if (lentObjectLiterals == null) {\n              lentObjectLiterals = Lists.newArrayList();\n            }\n            lentObjectLiterals.add(n);\n          } else {\n            defineObjectLiteral(n);\n          }\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }", "defineObjectLiteral": "\n    private void defineObjectLiteral(Node objectLit) {\n      // Handle the @lends annotation.\n      JSType type = null;\n      JSDocInfo info = objectLit.getJSDocInfo();\n      if (info != null && info.getLendsName() != null) {\n        String lendsName = info.getLendsName();\n        Var lendsVar = scope.getVar(lendsName);\n        if (lendsVar == null) {\n          compiler.report(\n              JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName));\n        } else {\n          type = lendsVar.getType();\n          if (type == null) {\n            type = unknownType;\n          }\n          if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n            compiler.report(\n                JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT,\n                    lendsName, type.toString()));\n            type = null;\n          } else {\n            objectLit.setJSType(type);\n          }\n        }\n      }\n\n      info = NodeUtil.getBestJSDocInfo(objectLit);\n      Node lValue = NodeUtil.getBestLValue(objectLit);\n      String lValueName = NodeUtil.getBestLValueName(lValue);\n      boolean createdEnumType = false;\n      if (info != null && info.hasEnumParameterType()) {\n        type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);\n        createdEnumType = true;\n      }\n\n      if (type == null) {\n        type = typeRegistry.createAnonymousObjectType(info);\n      }\n\n      setDeferredType(objectLit, type);\n\n      // If this is an enum, the properties were already taken care of above.\n      processObjectLitProperties(\n          objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);\n    }", "processObjectLitProperties": "\n    void processObjectLitProperties(\n        Node objLit, ObjectType objLitType,\n        boolean declareOnOwner) {\n      for (Node keyNode = objLit.getFirstChild(); keyNode != null;\n           keyNode = keyNode.getNext()) {\n        Node value = keyNode.getFirstChild();\n        String memberName = NodeUtil.getObjectLitKeyName(keyNode);\n        JSDocInfo info = keyNode.getJSDocInfo();\n        JSType valueType = getDeclaredType(info, keyNode, value);\n        JSType keyType =  objLitType.isEnumType() ?\n            objLitType.toMaybeEnumType().getElementsType() :\n            NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);\n\n        // Try to declare this property in the current scope if it\n        // has an authoritative name.\n        String qualifiedName = NodeUtil.getBestLValueName(keyNode);\n        if (qualifiedName != null) {\n          boolean inferred = keyType == null;\n          defineSlot(keyNode, objLit, qualifiedName, keyType, inferred);\n        } else if (keyType != null) {\n          setDeferredType(keyNode, keyType);\n        }\n\n        if (keyType != null && objLitType != null && declareOnOwner) {\n          // Declare this property on its object literal.\n          objLitType.defineDeclaredProperty(memberName, keyType, keyNode);\n        }\n      }\n    }", "getDeclaredTypeInAnnotation": "\n    private JSType getDeclaredTypeInAnnotation(Node node, JSDocInfo info) {\n      JSType jsType = null;\n      if (info != null) {\n        if (info.hasType()) {\n\n          ImmutableList<TemplateType> ownerTypeKeys = ImmutableList.of();\n          Node ownerNode = NodeUtil.getBestLValueOwner(node);\n          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n          ObjectType ownerType = null;\n          if (ownerName != null) {\n            Var ownerVar = scope.getVar(ownerName);\n            if (ownerVar != null) {\n              ownerType = getPrototypeOwnerType(\n                  ObjectType.cast(ownerVar.getType()));\n              if (ownerType != null) {\n                ownerTypeKeys =\n                    ownerType.getTemplateTypeMap().getTemplateKeys();\n              }\n            }\n          }\n\n          if (!ownerTypeKeys.isEmpty()) {\n            typeRegistry.setTemplateTypeNames(ownerTypeKeys);\n          }\n\n          jsType = info.getType().evaluate(scope, typeRegistry);\n\n          if (!ownerTypeKeys.isEmpty()) {\n            typeRegistry.clearTemplateTypeNames();\n          }\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n          jsType = createFunctionTypeFromNodes(\n              null, fnName, info, node);\n        }\n      }\n      return jsType;\n    }", "assertDefinitionNode": "\n    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }", "defineCatch": "\n    void defineCatch(Node n) {\n      assertDefinitionNode(n, Token.CATCH);\n      Node catchName = n.getFirstChild();\n      defineSlot(catchName, n,\n          getDeclaredType(\n              catchName.getJSDocInfo(), catchName, null));\n    }", "defineVar": "\n    void defineVar(Node n) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, (info != null) ? info : name.getJSDocInfo());\n      }\n    }", "defineFunctionLiteral": "\n    void defineFunctionLiteral(Node n) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      // Determine the name and JSDocInfo and l-value for the function.\n      // Any of these may be null.\n      Node lValue = NodeUtil.getBestLValue(n);\n      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      String functionName = NodeUtil.getBestLValueName(lValue);\n      FunctionType functionType =\n          createFunctionTypeFromNodes(n, functionName, info, lValue);\n\n      // Assigning the function type to the function node\n      setDeferredType(n, functionType);\n\n      // Declare this symbol in the current scope iff it's a function\n      // declaration. Otherwise, the declaration will happen in other\n      // code paths.\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }", "defineName": "\n    private void defineName(Node name, Node var, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      // variable's type\n      JSType type = getDeclaredType(info, name, value);\n      if (type == null) {\n        // The variable's type will be inferred.\n        type = name.isFromExterns() ? unknownType : null;\n      }\n      defineSlot(name, var, type);\n    }", "shouldUseFunctionLiteralType": "\n    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n      if (info != null) {\n        return true;\n      }\n      if (lValue != null &&\n          NodeUtil.isObjectLitKey(lValue)) {\n        return false;\n      }\n      return scope.isGlobal() || !type.isReturnTypeInferred();\n    }", "createFunctionTypeFromNodes": "\n    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() != null &&\n            var.getType().isFunctionType()) {\n          FunctionType aliasedType  = var.getType().toMaybeFunctionType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.isFunction();\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = type.toMaybeFunctionType();\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode);\n          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n          Var ownerVar = null;\n          String propName = null;\n          ObjectType ownerType = null;\n          if (ownerName != null) {\n            ownerVar = scope.getVar(ownerName);\n            if (ownerVar != null) {\n              ownerType = ObjectType.cast(ownerVar.getType());\n            }\n            if (name != null) {\n              propName = name.substring(ownerName.length() + 1);\n            }\n          }\n\n          ObjectType prototypeOwner = getPrototypeOwnerType(ownerType);\n          TemplateTypeMap prototypeOwnerTypeMap = null;\n          if (prototypeOwner != null &&\n              prototypeOwner.getTypeOfThis() != null) {\n              prototypeOwnerTypeMap =\n                  prototypeOwner.getTypeOfThis().getTemplateTypeMap();\n          }\n\n          FunctionType overriddenType = null;\n          if (ownerType != null && propName != null) {\n            overriddenType = findOverriddenFunction(\n                ownerType, propName, prototypeOwnerTypeMap);\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setContents(getFunctionAnalysisResults(fnRoot))\n              .inferFromOverriddenFunction(overriddenType, parametersNode)\n              .inferTemplateTypeName(info, prototypeOwner)\n              .inferReturnType(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (ownerType != null && ownerType.isFunctionPrototypeType() &&\n              ownerType.getOwnerFunction().hasInstanceType()) {\n            builder.inferThisType(\n                info, ownerType.getOwnerFunction().getInstanceType());\n            searchedForThisType = true;\n          } else if (ownerNode != null && ownerNode.isThis()) {\n            // If 'this' has a type, use that instead.\n            // This is a hack, necessary because CollectProperties (below)\n            // doesn't run with the scope that it's building,\n            // so scope.getTypeOfThis() will be wrong.\n            JSType injectedThisType = ownerNode.getJSType();\n            builder.inferThisType(\n                info,\n                injectedThisType == null ?\n                scope.getTypeOfThis() : injectedThisType);\n            searchedForThisType = true;\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }", "getPrototypeOwnerType": "\n    private ObjectType getPrototypeOwnerType(ObjectType ownerType) {\n      if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n        return ownerType.getOwnerFunction();\n      }\n      return null;\n    }", "findOverriddenFunction": "\n    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName, TemplateTypeMap typeMap) {\n      FunctionType result = null;\n\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType != null && propType.isFunctionType()) {\n        result =  propType.toMaybeFunctionType();\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType != null && propType.isFunctionType()) {\n            result = propType.toMaybeFunctionType();\n            break;\n          }\n        }\n      }\n\n      if (result != null && typeMap != null && !typeMap.isEmpty()) {\n        result = result.visit(\n            new TemplateTypeMapReplacer(typeRegistry, typeMap))\n            .toMaybeFunctionType();\n      }\n\n      return result;\n    }", "createEnumTypeFromNodes": "\n    private EnumType createEnumTypeFromNodes(Node rValue, String name,\n        JSDocInfo info, Node lValueNode) {\n      Preconditions.checkNotNull(info);\n      Preconditions.checkState(info.hasEnumParameterType());\n\n      EnumType enumType = null;\n      if (rValue != null && rValue.isQualifiedName()) {\n        // Handle an aliased enum.\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof EnumType) {\n          enumType = (EnumType) var.getType();\n        }\n      }\n\n      if (enumType == null) {\n        JSType elementsType =\n            info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType = typeRegistry.createEnumType(name, rValue, elementsType);\n\n        if (rValue != null && rValue.isObjectLit()) {\n          // collect enum elements\n          Node key = rValue.getFirstChild();\n          while (key != null) {\n            String keyName = NodeUtil.getStringValue(key);\n            if (keyName == null) {\n              // GET and SET don't have a String value;\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else if (!codingConvention.isValidEnumKey(keyName)) {\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else {\n              enumType.defineElement(keyName, key);\n            }\n            key = key.getNext();\n          }\n        }\n      }\n\n      if (name != null && scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n      }\n\n      return enumType;\n    }", "defineSlot": "\n    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }", "finishConstructorDefinition": "\n    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n      if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }", "isQnameRootedInGlobalScope": "\n    private boolean isQnameRootedInGlobalScope(Node n) {\n      Scope scope = getQnameRootScope(n);\n      return scope != null && scope.isGlobal();\n    }", "getQnameRootScope": "\n    private Scope getQnameRootScope(Node n) {\n      Node root = NodeUtil.getRootOfQualifiedName(n);\n      if (root.isName()) {\n        Var var = scope.getVar(root.getString());\n        if (var != null) {\n          return var.getScope();\n        }\n      }\n      return null;\n    }", "getDeclaredType": "\n    private JSType getDeclaredType(JSDocInfo info, Node lValue,\n        @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        }\n      }\n\n      // Check if this is constant, and if it has a known type.\n      if (isConstantSymbol(info, lValue)) {\n        if (rValue != null) {\n          JSDocInfo rValueInfo = rValue.getJSDocInfo();\n          if (rValueInfo != null && rValueInfo.hasType()) {\n            // If rValue has a type-cast, we use the type in the type-cast.\n            return rValueInfo.getType().evaluate(scope, typeRegistry);\n          } else if (rValue.getJSType() != null\n              && !rValue.getJSType().isUnknownType()) {\n            // If rValue's type was already computed during scope creation,\n            // then we can safely use that.\n            return rValue.getJSType();\n          } else if (rValue.isOr()) {\n            // Check for a very specific JS idiom:\n            // var x = x || TYPE;\n            // This is used by Closure's base namespace for esoteric\n            // reasons.\n            Node firstClause = rValue.getFirstChild();\n            Node secondClause = firstClause.getNext();\n            boolean namesMatch = firstClause.isName()\n                && lValue.isName()\n                && firstClause.getString().equals(lValue.getString());\n            if (namesMatch && secondClause.getJSType() != null\n                && !secondClause.getJSType().isUnknownType()) {\n              return secondClause.getJSType();\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(lValue, info);\n    }", "getFunctionType": "\n    private FunctionType getFunctionType(@Nullable Var v) {\n      JSType t = v == null ? null : v.getType();\n      ObjectType o = t == null ? null : t.dereference();\n      return JSType.toMaybeFunctionType(o);\n    }", "checkForCallingConventionDefiningCalls": "\n    private void checkForCallingConventionDefiningCalls(\n        Node n, Map<String, String> delegateCallingConventions) {\n      codingConvention.checkForCallingConventionDefiningCalls(n,\n          delegateCallingConventions);\n    }", "checkForClassDefiningCalls": "\n    private void checkForClassDefiningCalls(NodeTraversal t, Node n) {\n      SubclassRelationship relationship =\n          codingConvention.getClassesDefinedByCall(n);\n      if (relationship != null) {\n        FunctionType superCtor = getFunctionType(\n            scope.getVar(relationship.superclassName));\n        FunctionType subCtor = getFunctionType(\n            scope.getVar(relationship.subclassName));\n        if (superCtor != null && superCtor.isConstructor() &&\n            subCtor != null && subCtor.isConstructor()) {\n          ObjectType superClass = superCtor.getInstanceType();\n          ObjectType subClass = subCtor.getInstanceType();\n\n          // superCtor and subCtor might be structural constructors\n          // (like {function(new:Object)}) so we need to resolve them back\n          // to the original ctor objects.\n          superCtor = superClass.getConstructor();\n          subCtor = subClass.getConstructor();\n\n          if (relationship.type == SubclassType.INHERITS &&\n              !superClass.isEmptyType() && !subClass.isEmptyType()) {\n            validator.expectSuperType(t, n, superClass, subClass);\n          }\n\n          if (superCtor != null && subCtor != null) {\n            codingConvention.applySubclassRelationship(\n                superCtor, subCtor, relationship.type);\n          }\n        }\n      }\n\n      String singletonGetterClassName =\n          codingConvention.getSingletonGetterClassName(n);\n      if (singletonGetterClassName != null) {\n        ObjectType objectType = ObjectType.cast(\n            typeRegistry.getType(singletonGetterClassName));\n        if (objectType != null) {\n          FunctionType functionType = objectType.getConstructor();\n\n          if (functionType != null) {\n            FunctionType getterType =\n                typeRegistry.createFunctionType(objectType);\n            codingConvention.applySingletonGetter(functionType, getterType,\n                objectType);\n          }\n        }\n      }\n\n      DelegateRelationship delegateRelationship =\n          codingConvention.getDelegateRelationship(n);\n      if (delegateRelationship != null) {\n        applyDelegateRelationship(delegateRelationship);\n      }\n\n      ObjectLiteralCast objectLiteralCast =\n          codingConvention.getObjectLiteralCast(n);\n      if (objectLiteralCast != null) {\n        if (objectLiteralCast.diagnosticType == null) {\n          ObjectType type = ObjectType.cast(\n              typeRegistry.getType(objectLiteralCast.typeName));\n          if (type != null && type.getConstructor() != null) {\n            setDeferredType(objectLiteralCast.objectNode, type);\n            objectLiteralCast.objectNode.putBooleanProp(\n                Node.REFLECTED_OBJECT, true);\n          } else {\n            compiler.report(JSError.make(t.getSourceName(), n,\n                    CONSTRUCTOR_EXPECTED));\n          }\n        } else {\n          compiler.report(JSError.make(t.getSourceName(), n,\n                  objectLiteralCast.diagnosticType));\n        }\n      }\n    }", "applyDelegateRelationship": "\n    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n      ObjectType delegatorObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegator));\n      ObjectType delegateBaseObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegateBase));\n      ObjectType delegateSuperObject = ObjectType.cast(\n          typeRegistry.getType(codingConvention.getDelegateSuperclassName()));\n      if (delegatorObject != null &&\n          delegateBaseObject != null &&\n          delegateSuperObject != null) {\n        FunctionType delegatorCtor = delegatorObject.getConstructor();\n        FunctionType delegateBaseCtor = delegateBaseObject.getConstructor();\n        FunctionType delegateSuperCtor = delegateSuperObject.getConstructor();\n\n        if (delegatorCtor != null && delegateBaseCtor != null &&\n            delegateSuperCtor != null) {\n          FunctionParamBuilder functionParamBuilder =\n              new FunctionParamBuilder(typeRegistry);\n          functionParamBuilder.addRequiredParams(\n              getNativeType(U2U_CONSTRUCTOR_TYPE));\n          FunctionType findDelegate = typeRegistry.createFunctionType(\n              typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n              functionParamBuilder.build());\n\n          FunctionType delegateProxy = typeRegistry.createConstructorType(\n              delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX,\n              null, null, null, null);\n          delegateProxy.setPrototypeBasedOn(delegateBaseObject);\n\n          codingConvention.applyDelegateRelationship(\n              delegateSuperObject, delegateBaseObject, delegatorObject,\n              delegateProxy, findDelegate);\n          delegateProxyPrototypes.add(delegateProxy.getPrototype());\n        }\n      }\n    }", "maybeDeclareQualifiedName": "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has JsDoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n\n          qVar.getScope().undeclare(qVar);\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = isQualifiedNameInferred(\n          qName, n, info, rhsValue, valueType);\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        FunctionType ownerFnType = JSType.toMaybeFunctionType(ownerType);\n        if (ownerFnType != null) {\n          JSType ownerTypeOfThis = ownerFnType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }", "isQualifiedNameInferred": "\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          return false;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }", "isConstantSymbol": "\n    private boolean isConstantSymbol(JSDocInfo info, Node node) {\n      if (info != null && info.isConstant()) {\n        return true;\n      }\n\n      switch (node.getType()) {\n        case Token.NAME:\n          return NodeUtil.isConstantByConvention(\n              compiler.getCodingConvention(), node, node.getParent());\n        case Token.GETPROP:\n          return node.isQualifiedName() && NodeUtil.isConstantByConvention(\n              compiler.getCodingConvention(), node.getLastChild(), node);\n      }\n      return false;\n    }", "getObjectSlot": "\n    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }", "resolveStubDeclarations": "\n    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, n);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }", "maybeCollectMember": "\n      private void maybeCollectMember(Node member,\n          Node nodeWithJsDocInfo, @Nullable Node value) {\n        JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();\n\n        // Do nothing if there is no JSDoc type info, or\n        // if the node is not a member expression, or\n        // if the member expression is not of the form: this.someProperty.\n        if (info == null ||\n            !member.isGetProp() ||\n            !member.getFirstChild().isThis()) {\n          return;\n        }\n\n        member.getFirstChild().setJSType(thisType);\n\n        // TODO(johnlenz): We are evaluating these values in the wrong scope:\n        // https://code.google.com/p/closure-compiler/issues/detail?id=926\n        JSType thisObjectType = thisType.toObjectType();\n        if (thisObjectType != null) {\n          ImmutableList<TemplateType> keys =\n              thisObjectType.getTemplateTypeMap().getTemplateKeys();\n          typeRegistry.setTemplateTypeNames(keys);\n        }\n\n        JSType jsType = getDeclaredType(info, member, value);\n\n        if (thisObjectType != null) {\n          typeRegistry.clearTemplateTypeNames();\n        }\n\n        Node name = member.getLastChild();\n        if (jsType != null &&\n            (name.isName() || name.isString()) &&\n            thisType.toObjectType() != null) {\n          thisType.toObjectType().defineDeclaredProperty(\n              name.getString(),\n              jsType,\n              member);\n        }\n      }", "checkForTypedef": "\n    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recursive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.declareType(typedef, unknownType);\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.overwriteDeclaredType(typedef, realType);\n      if (candidate.isGetProp()) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }", "build": "\n    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents != null) {\n        for (String varName : contents.getEscapedVarNames()) {\n          Var v = scope.getVar(varName);\n          Preconditions.checkState(v.getScope() == scope);\n          v.markEscaped();\n        }\n\n        for (Multiset.Entry<String> entry :\n                 contents.getAssignedNameCounts().entrySet()) {\n          Var v = scope.getVar(entry.getElement());\n          Preconditions.checkState(v.getScope() == scope);\n          if (entry.getCount() == 1) {\n            v.markAssignedExactlyOnce();\n          }\n        }\n      }\n    }", "handleFunctionInputs": "\n    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }", "declareArguments": "\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node iifeArgumentNode = null;\n\n      if (NodeUtil.isCallOrNewTarget(functionNode)) {\n        iifeArgumentNode = functionNode.getNext();\n      }\n\n      FunctionType functionType =\n          JSType.toMaybeFunctionType(functionNode.getJSType());\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            JSType paramType = jsDocParameter == null ?\n                unknownType : jsDocParameter.getJSType();\n            boolean inferred = paramType == null || paramType == unknownType;\n\n            if (iifeArgumentNode != null && inferred) {\n              String argumentName = iifeArgumentNode.getQualifiedName();\n              Var argumentVar =\n                  argumentName == null || scope.getParent() == null\n                  ? null : scope.getParent().getVar(argumentName);\n              if (argumentVar != null && !argumentVar.isTypeInferred()) {\n                paramType = argumentVar.getType();\n              }\n            }\n\n            if (paramType == null) {\n              paramType = unknownType;\n            }\n\n            defineSlot(astParameter, functionNode, paramType, inferred);\n\n            if (jsDocParameter != null) {\n              jsDocParameter = jsDocParameter.getNext();\n            }\n            if (iifeArgumentNode != null) {\n              iifeArgumentNode = iifeArgumentNode.getNext();\n            }\n          }\n        }\n      }\n    } // end declareArguments", "process": "\n    @Override public void process(Node externs, Node root) {\n      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }", "enterScope": "\n    @Override public void enterScope(NodeTraversal t) {\n      if (!t.inGlobalScope()) {\n        Node n = t.getScopeRoot();\n        data.put(n, new AstFunctionContents(n));\n      }\n    }", "getFunctionAnalysisResults": "\n  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {\n    if (n == null) {\n      return null;\n    }\n\n    // Sometimes this will return null in things like\n    // NameReferenceGraphConstruction that build partial scopes.\n    return functionAnalysisResults.get(n);\n  }"}