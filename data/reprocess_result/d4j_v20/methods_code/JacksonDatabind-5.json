{"withAnnotations": "\n    public AnnotatedClass withAnnotations(AnnotationMap ann) {\n        return new AnnotatedClass(_class, _superTypes,\n                _annotationIntrospector, _mixInResolver, ann);\n    }", "construct": "\n    public static AnnotatedClass construct(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n        return new AnnotatedClass(cls,\n                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);\n    }", "constructWithoutSuperTypes": "\n    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n        return new AnnotatedClass(cls,\n                Collections.<Class<?>>emptyList(), aintr, mir, null);\n    }", "getAnnotated": "\n    public Class<?> getAnnotated() { return _class; }", "getModifiers": "\n    public int getModifiers() { return _class.getModifiers(); }", "getName": "\n    public String getName() { return _class.getName(); }", "getAnnotation": "\n    public <A extends Annotation> A getAnnotation(Class<A> acls)\n    {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.get(acls);\n    }", "getGenericType": "\n    public Type getGenericType() {\n        return _class;\n    }", "getRawType": "\n    public Class<?> getRawType() {\n        return _class;\n    }", "annotations": "\n    public Iterable<Annotation> annotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.annotations();\n    }", "getAllAnnotations": "\n    protected AnnotationMap getAllAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }", "getAnnotations": "\n    public Annotations getAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations;\n    }", "hasAnnotations": "\n    public boolean hasAnnotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.size() > 0;\n    }", "getDefaultConstructor": "\n    public AnnotatedConstructor getDefaultConstructor()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _defaultConstructor;\n    }", "getConstructors": "\n    public List<AnnotatedConstructor> getConstructors()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _constructors;\n    }", "getStaticMethods": "\n    public List<AnnotatedMethod> getStaticMethods()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _creatorMethods;\n    }", "memberMethods": "\n    public Iterable<AnnotatedMethod> memberMethods()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods;\n    }", "getMemberMethodCount": "\n    public int getMemberMethodCount()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.size();\n    }", "findMethod": "\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.find(name, paramTypes);\n    }", "getFieldCount": "\n    public int getFieldCount() {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields.size();\n    }", "fields": "\n    public Iterable<AnnotatedField> fields()\n    {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields;\n    }", "resolveClassAnnotations": "\n    private void resolveClassAnnotations()\n    {\n        _classAnnotations = new AnnotationMap();\n        // [JACKSON-659] Should skip processing if annotation processing disabled\n        if (_annotationIntrospector != null) {\n            // add mix-in annotations first (overrides)\n            if (_primaryMixIn != null) {\n                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n            }\n            // first, annotations from the class itself:\n            _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n    \n            // and then from super types\n            for (Class<?> cls : _superTypes) {\n                // and mix mix-in annotations in-between\n                _addClassMixIns(_classAnnotations, cls);\n                _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n            }\n            /* and finally... any annotations there might be for plain\n             * old Object.class: separate because for all other purposes\n             * it is just ignored (not included in super types)\n             */\n            /* 12-Jul-2009, tatu: Should this be done for interfaces too?\n             *   For now, yes, seems useful for some cases, and not harmful for any?\n             */\n            _addClassMixIns(_classAnnotations, Object.class);\n        }\n    }", "resolveCreators": "\n    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n            if (_primaryMixIn != null) {\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }", "resolveMemberMethods": "\n    private void resolveMemberMethods()\n    {\n        _memberMethods = new AnnotatedMethodMap();\n        AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n        // first: methods from the class itself\n        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);\n\n        // and then augment these with annotations from super-types:\n        for (Class<?> cls : _superTypes) {\n            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n            _addMemberMethods(cls, _memberMethods, mixin, mixins);\n        }\n        // Special case: mix-ins for Object.class? (to apply to ALL classes)\n        if (_mixInResolver != null) {\n            Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n            if (mixin != null) {\n                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n            }\n        }\n\n        /* Any unmatched mix-ins? Most likely error cases (not matching\n         * any method); but there is one possible real use case:\n         * exposing Object#hashCode (alas, Object#getClass can NOT be\n         * exposed, see [JACKSON-140])\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (!mixins.isEmpty()) {\n                Iterator<AnnotatedMethod> it = mixins.iterator();\n                while (it.hasNext()) {\n                    AnnotatedMethod mixIn = it.next();\n                    try {\n                        Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes());\n                        if (m != null) {\n                            AnnotatedMethod am = _constructMethod(m);\n                            _addMixOvers(mixIn.getAnnotated(), am, false);\n                            _memberMethods.add(am);\n                        }\n                    } catch (Exception e) { }\n                }\n            }\n        }\n    }", "resolveFields": "\n    private void resolveFields()\n    {\n        Map<String,AnnotatedField> foundFields = _findFields(_class, null);\n        if (foundFields == null || foundFields.size() == 0) {\n            _fields = Collections.emptyList();\n        } else {\n            _fields = new ArrayList<AnnotatedField>(foundFields.size());\n            _fields.addAll(foundFields.values());\n        }\n    }", "_addClassMixIns": "\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)\n    {\n        if (_mixInResolver != null) {\n            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));\n        }\n    }", "_addConstructorMixIns": "\n    protected void _addConstructorMixIns(Class<?> mixin)\n    {\n        MemberKey[] ctorKeys = null;\n        int ctorCount = (_constructors == null) ? 0 : _constructors.size();\n        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {\n            if (ctor.getParameterTypes().length == 0) {\n                if (_defaultConstructor != null) {\n                    _addMixOvers(ctor, _defaultConstructor, false);\n                }\n            } else {\n                if (ctorKeys == null) {\n                    ctorKeys = new MemberKey[ctorCount];\n                    for (int i = 0; i < ctorCount; ++i) {\n                        ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated());\n                    }\n                }\n                MemberKey key = new MemberKey(ctor);\n\n                for (int i = 0; i < ctorCount; ++i) {\n                    if (!key.equals(ctorKeys[i])) {\n                        continue;\n                    }\n                    _addMixOvers(ctor, _constructors.get(i), true);\n                    break;\n                }\n            }\n        }\n    }", "_addFactoryMixIns": "\n    protected void _addFactoryMixIns(Class<?> mixin)\n    {\n        MemberKey[] methodKeys = null;\n        int methodCount = _creatorMethods.size();\n\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            if (m.getParameterTypes().length == 0) {\n                continue;\n            }\n            if (methodKeys == null) {\n                methodKeys = new MemberKey[methodCount];\n                for (int i = 0; i < methodCount; ++i) {\n                    methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated());\n                }\n            }\n            MemberKey key = new MemberKey(m);\n            for (int i = 0; i < methodCount; ++i) {\n                if (!key.equals(methodKeys[i])) {\n                    continue;\n                }\n                _addMixOvers(m, _creatorMethods.get(i), true);\n                break;\n            }\n        }\n    }", "_addMemberMethods": "\n    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        // first, mixIns, since they have higher priority then class methods\n        if (mixInCls != null) {\n            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n        }        \n        if (cls == null) { // just so caller need not check when passing super-class\n            return;\n        }\n\n        // then methods from the class itself\n        for (Method m : cls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod old = methods.find(m);\n            if (old == null) {\n                AnnotatedMethod newM = _constructMethod(m);\n                methods.add(newM);\n                // Ok, but is there a mix-in to connect now?\n                old = mixIns.remove(m);\n                if (old != null) {\n                    _addMixOvers(old.getAnnotated(), newM, false);\n                }\n            } else {\n                /* If sub-class already has the method, we only want to augment\n                 * annotations with entries that are not masked by sub-class.\n                 */\n                _addMixUnders(m, old);\n\n                /* 06-Jan-2010, tatu: [JACKSON-450] Except that if method we saw first is\n                 *   from an interface, and we now find a non-interface definition, we should\n                 *   use this method, but with combination of annotations.\n                 *   This helps (or rather, is essential) with JAXB annotations and\n                 *   may also result in faster method calls (interface calls are slightly\n                 *   costlier than regular method calls)\n                 */\n                if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) {\n                    methods.add(old.withMethod(m));\n                }\n            }\n        }\n    }", "_addMethodMixIns": "\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                        mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }", "_findFields": "\n    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)\n    {\n        /* First, a quick test: we only care for regular classes (not\n         * interfaces, primitive types etc), except for Object.class.\n         * A simple check to rule out other cases is to see if there\n         * is a super class or not.\n         */\n        Class<?> parent = c.getSuperclass();\n        if (parent != null) {\n            // Let's add super-class' fields first, then ours.\n            /* 21-Feb-2010, tatu: Need to handle masking: as per [JACKSON-226]\n             *    we otherwise get into trouble...\n             */\n            fields = _findFields(parent, fields);\n            for (Field f : c.getDeclaredFields()) {\n                // static fields not included, nor transient\n                if (!_isIncludableField(f)) {\n                    continue;\n                }\n                /* Ok now: we can (and need) not filter out ignorable fields\n                 * at this point; partly because mix-ins haven't been\n                 * added, and partly because logic can be done when\n                 * determining get/settability of the field.\n                 */\n                if (fields == null) {\n                    fields = new LinkedHashMap<String,AnnotatedField>();\n                }\n                fields.put(f.getName(), _constructField(f));\n            }\n            // And then... any mix-in overrides?\n            if (_mixInResolver != null) {\n                Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                if (mixin != null) {\n                    _addFieldMixIns(parent, mixin, fields);\n                }\n            }\n        }\n        return fields;\n    }", "_addFieldMixIns": "\n    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,\n            Map<String,AnnotatedField> fields)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Field mixinField : mixin.getDeclaredFields()) {\n                // there are some dummy things (static, synthetic); better ignore\n                if (!_isIncludableField(mixinField)) {\n                    continue;\n                }\n                String name = mixinField.getName();\n                // anything to mask? (if not, quietly ignore)\n                AnnotatedField maskedField = fields.get(name);\n                if (maskedField != null) {\n                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n                }\n            }\n        }\n    }", "_constructMethod": "\n    protected AnnotatedMethod _constructMethod(Method m)\n    {\n        /* note: parameter annotations not used for regular (getter, setter)\n         * methods; only for creator methods (static factory methods)\n         * -- at least not yet!\n         */\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n    }", "_constructConstructor": "\n    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }", "_constructCreatorMethod": "\n    protected AnnotatedMethod _constructCreatorMethod(Method m)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n                                   _collectRelevantAnnotations(m.getParameterAnnotations()));\n    }", "_constructField": "\n    protected AnnotatedField _constructField(Field f)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedField(f, _emptyAnnotationMap());\n        }\n        return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n    }", "_emptyAnnotationMap": "\n    private AnnotationMap _emptyAnnotationMap() {\n        return new AnnotationMap();\n    }", "_emptyAnnotationMaps": "\n    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n        if (count == 0) {\n            return NO_ANNOTATION_MAPS;\n        }\n        AnnotationMap[] maps = new AnnotationMap[count];\n        for (int i = 0; i < count; ++i) {\n            maps[i] = _emptyAnnotationMap();\n        }\n        return maps;\n    }", "_isIncludableMemberMethod": "\n    protected boolean _isIncludableMemberMethod(Method m)\n    {\n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        /* 07-Apr-2009, tatu: Looks like generics can introduce hidden\n         *   bridge and/or synthetic methods. I don't think we want to\n         *   consider those...\n         */\n        if (m.isSynthetic() || m.isBridge()) {\n            return false;\n        }\n        // also, for now we have no use for methods with 2 or more arguments:\n        int pcount = m.getParameterTypes().length;\n        return (pcount <= 2);\n    }", "_isIncludableField": "\n    private boolean _isIncludableField(Field f)\n    {\n        /* I'm pretty sure synthetic fields are to be skipped...\n         * (methods definitely are)\n         */\n        if (f.isSynthetic()) {\n            return false;\n        }\n        // Static fields are never included, nor transient\n        int mods = f.getModifiers();\n        if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) {\n            return false;\n        }\n        return true;\n    }", "_collectRelevantAnnotations": "\n    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)\n    {\n        int len = anns.length;\n        AnnotationMap[] result = new AnnotationMap[len];\n        for (int i = 0; i < len; ++i) {\n            result[i] = _collectRelevantAnnotations(anns[i]);\n        }\n        return result;\n    }", "_addAnnotationsIfNotPresent": "\n    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: we will NOT filter out non-Jackson anns any more\n                    result.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(result, annotations);\n                }\n            }\n        }\n    }", "_addOrOverrideAnnotations": "\n    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: no filtering by jackson-annotations\n                    target.addOrOverride(ann);\n                }\n            }\n            if (bundles != null) { // and then bundles, if any: important for precedence\n                for (Annotation[] annotations : bundles) {\n                    _addOrOverrideAnnotations(target, annotations);\n                }\n            }\n        }\n    }", "_addMixOvers": "\n    protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target,\n            boolean addParamAnnotations)\n    {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }", "_addMixUnders": "\n    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n        _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n    }", "_isAnnotationBundle": "\n   private final boolean _isAnnotationBundle(Annotation ann)\n   {\n       return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n   }", "toString": "\n    public String toString()\n    {\n        return \"[AnnotedClass \"+_class.getName()+\"]\";\n    }"}