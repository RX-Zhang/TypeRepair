{"isEmpty": "\n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }", "remainingLength": "\n    private int remainingLength() {\n        return queue.length() - pos;\n    }", "peek": "\n    public char peek() {\n        return isEmpty() ? 0 : queue.charAt(pos);\n    }", "addFirst": "\n    public void addFirst(Character c) {\n        addFirst(c.toString());\n    }", "matches": "\n    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }", "matchesCS": "\n    public boolean matchesCS(String seq) {\n        return queue.startsWith(seq, pos);\n    }", "matchesAny": "\n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }", "matchesStartTag": "\n    public boolean matchesStartTag() {\n        // micro opt for matching \"<x\"\n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }", "matchChomp": "\n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }", "matchesWhitespace": "\n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }", "matchesWord": "\n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }", "advance": "\n    public void advance() {\n        if (!isEmpty()) pos++;\n    }", "consume": "\n    public char consume() {\n        return queue.charAt(pos++);\n    }", "consumeTo": "\n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }", "consumeToIgnoreCase": "\n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }", "consumeToAny": "\n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }", "chompTo": "\n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }", "chompToIgnoreCase": "\n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }", "chompBalanced": "\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }", "unescape": "\n    public static String unescape(String in) {\n        StringBuilder out = new StringBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last != 0 && last == ESC)\n                    out.append(c);\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return out.toString();\n    }", "consumeWhitespace": "\n    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }", "consumeWord": "\n    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }", "consumeTagName": "\n    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }", "consumeElementSelector": "\n    public String consumeElementSelector() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }", "consumeCssIdentifier": "\n    public String consumeCssIdentifier() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))\n            pos++;\n\n        return queue.substring(start, pos);\n    }", "consumeAttributeKey": "\n    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }", "remainder": "\n    public String remainder() {\n        final String remainder = queue.substring(pos, queue.length());\n        pos = queue.length();\n        return remainder;\n    }", "toString": "\n    public String toString() {\n        return queue.substring(pos);\n    }"}