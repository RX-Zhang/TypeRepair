{"getNativeType": "\n  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }", "getJSDocInfo": "\n  public JSDocInfo getJSDocInfo() {\n    return null;\n  }", "forgiveUnknownNames": "\n  void forgiveUnknownNames() {}", "isNoType": "\n  public boolean isNoType() {\n    return false;\n  }", "isNoObjectType": "\n  public boolean isNoObjectType() {\n    return false;\n  }", "isEmptyType": "\n  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType();\n  }", "isNumberObjectType": "\n  public boolean isNumberObjectType() {\n    return false;\n  }", "isNumberValueType": "\n  public boolean isNumberValueType() {\n    return false;\n  }", "isFunctionPrototypeType": "\n  public boolean isFunctionPrototypeType() {\n    return false;\n  }", "isStringObjectType": "\n  public boolean isStringObjectType() {\n    return false;\n  }", "isTheObjectType": "\n  boolean isTheObjectType() {\n    return false;\n  }", "isStringValueType": "\n  public boolean isStringValueType() {\n    return false;\n  }", "isString": "\n  public final boolean isString() {\n    return this.isSubtype(\n        getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));\n  }", "isNumber": "\n  public final boolean isNumber() {\n    return this.isSubtype(\n        getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));\n  }", "isArrayType": "\n  public boolean isArrayType() {\n    return false;\n  }", "isBooleanObjectType": "\n  public boolean isBooleanObjectType() {\n    return false;\n  }", "isBooleanValueType": "\n  public boolean isBooleanValueType() {\n    return false;\n  }", "isRegexpType": "\n  public boolean isRegexpType() {\n    return false;\n  }", "isDateType": "\n  public boolean isDateType() {\n    return false;\n  }", "isNullType": "\n  public boolean isNullType() {\n    return false;\n  }", "isVoidType": "\n  public boolean isVoidType() {\n    return false;\n  }", "isAllType": "\n  public boolean isAllType() {\n    return false;\n  }", "isUnknownType": "\n  public boolean isUnknownType() {\n    return false;\n  }", "isCheckedUnknownType": "\n  public boolean isCheckedUnknownType() {\n    return false;\n  }", "isUnionType": "\n  public boolean isUnionType() {\n    return false;\n  }", "isFunctionType": "\n  public boolean isFunctionType() {\n    return false;\n  }", "isEnumElementType": "\n  public boolean isEnumElementType() {\n    return false;\n  }", "isEnumType": "\n  public boolean isEnumType() {\n    return false;\n  }", "isNamedType": "\n  boolean isNamedType() {\n    return false;\n  }", "isRecordType": "\n  public boolean isRecordType() {\n    return false;\n  }", "isTemplateType": "\n  public boolean isTemplateType() {\n    return false;\n  }", "isObject": "\n  public boolean isObject() {\n    return false;\n  }", "isConstructor": "\n  public boolean isConstructor() {\n    return false;\n  }", "isNominalType": "\n  public boolean isNominalType() {\n    return false;\n  }", "isInstanceType": "\n  public boolean isInstanceType() {\n    return false;\n  }", "isInterface": "\n  public boolean isInterface() {\n    return false;\n  }", "isOrdinaryFunction": "\n  public boolean isOrdinaryFunction() {\n    return false;\n  }", "isEquivalentTo": "\n  public boolean isEquivalentTo(JSType jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.isEquivalentTo(this);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == jsType;\n  }", "isEquivalent": "\n  public static boolean isEquivalent(JSType typeA, JSType typeB) {\n    return (typeA == null || typeB == null) ?\n        typeA == typeB : typeA.isEquivalentTo(typeB);\n  }", "equals": "\n  public boolean equals(Object jsType) {\n    return (jsType instanceof JSType) ?\n        isEquivalentTo((JSType) jsType) : false;\n  }", "hashCode": "\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }", "matchesInt32Context": "\n  public final boolean matchesInt32Context() {\n    return matchesNumberContext();\n  }", "matchesUint32Context": "\n  public final boolean matchesUint32Context() {\n    return matchesNumberContext();\n  }", "matchesNumberContext": "\n  public boolean matchesNumberContext() {\n    return false;\n  }", "matchesStringContext": "\n  public boolean matchesStringContext() {\n    return false;\n  }", "matchesObjectContext": "\n  public boolean matchesObjectContext() {\n    return false;\n  }", "findPropertyType": "\n  public JSType findPropertyType(String propertyName) {\n    ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());\n    if (autoboxObjType != null) {\n      return autoboxObjType.findPropertyType(propertyName);\n    }\n\n    return null;\n  }", "canBeCalled": "\n  public boolean canBeCalled() {\n    return false;\n  }", "canAssignTo": "\n  public boolean canAssignTo(JSType that) {\n    if (this.isSubtype(that)) {\n      return true;\n    }\n    return false;\n  }", "autoboxesTo": "\n  public JSType autoboxesTo() {\n    return null;\n  }", "unboxesTo": "\n  public JSType unboxesTo() {\n    return null;\n  }", "toObjectType": "\n  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }", "dereference": "\n  public final ObjectType dereference() {\n    JSType restricted = restrictByNotNullOrUndefined();\n    JSType autobox = restricted.autoboxesTo();\n    return ObjectType.cast(autobox == null ? restricted : autobox);\n  }", "canTestForEqualityWith": "\n  public final boolean canTestForEqualityWith(JSType that) {\n    return this.testForEquality(that).equals(UNKNOWN);\n  }", "testForEquality": "\n  public TernaryValue testForEquality(JSType that) {\n    if (that.isAllType() || that.isNoType() || that.isUnknownType()) {\n      return UNKNOWN;\n    }\n    if (that.isEnumElementType()) {\n      return that.testForEquality(this);\n    }\n    if (that instanceof UnionType) {\n      UnionType union = (UnionType) that;\n      TernaryValue result = null;\n      for (JSType t : union.alternates) {\n        TernaryValue test = this.testForEquality(t);\n        if (result == null) {\n          result = test;\n        } else if (!result.equals(test)) {\n          return UNKNOWN;\n        }\n      }\n    }\n    return null;\n  }", "canTestForShallowEqualityWith": "\n  public final boolean canTestForShallowEqualityWith(JSType that) {\n    return this.isSubtype(that) || that.isSubtype(this);\n  }", "isNullable": "\n  public boolean isNullable() {\n    return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));\n  }", "getLeastSupertype": "\n  public JSType getLeastSupertype(JSType that) {\n    if (that.isUnionType()) {\n      // Union types have their own implementation of getLeastSupertype.\n      return that.getLeastSupertype(this);\n    }\n    return getLeastSupertype(this, that);\n  }", "getGreatestSubtype": "\n  public JSType getGreatestSubtype(JSType that) {\n     if (that.isRecordType()) {\n      // Record types have their own implementation of getGreatestSubtype.\n      return that.getGreatestSubtype(this);\n    }\n    return getGreatestSubtype(this, that);\n  }", "getRestrictedTypeGivenToBooleanOutcome": "\n  public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n      return this;\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }", "getPossibleToBooleanOutcomes": "\n  public abstract BooleanLiteralSet getPossibleToBooleanOutcomes();\n\n  /**\n   * Computes the subset of {@code this} and {@code that} types if equality", "getTypesUnderEquality": "\n  public TypePair getTypesUnderEquality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderEquality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case FALSE:\n        return new TypePair(null, null);\n\n      case TRUE:\n      case UNKNOWN:\n        return new TypePair(this, that);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }", "getTypesUnderInequality": "\n  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        return new TypePair(null, null);\n\n      case FALSE:\n      case UNKNOWN:\n        return new TypePair(this, that);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }", "getTypesUnderShallowEquality": "\n  public TypePair getTypesUnderShallowEquality(JSType that) {\n    JSType commonType = getGreatestSubtype(that);\n    return new TypePair(commonType, commonType);\n  }", "getTypesUnderShallowInequality": "\n  public TypePair getTypesUnderShallowInequality(JSType that) {\n    // union types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderShallowInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // Other types.\n    // There are only two types whose shallow inequality is deterministically\n    // true -- null and undefined. We can just enumerate them.\n    if (this.isNullType() && that.isNullType() ||\n        this.isVoidType() && that.isVoidType()) {\n      return new TypePair(null, null);\n    } else {\n      return new TypePair(this, that);\n    }\n  }", "restrictByNotNullOrUndefined": "\n  public JSType restrictByNotNullOrUndefined() {\n    return this;\n  }", "isSubtype": "\n  public abstract boolean isSubtype(JSType that);\n\n  /**\n   * Whether this type is meaningfully different from {@code that} type.", "differsFrom": "\n  public boolean differsFrom(JSType that) {\n    // if there are no unknowns, just use normal equality.\n    if (!this.isUnknownType() && !that.isUnknownType()) {\n      return !this.isEquivalentTo(that);\n    }\n    // otherwise, they're different iff one is unknown and the other is not.\n    return this.isUnknownType() ^ that.isUnknownType();\n  }", "visit": "\n  public abstract <T> T visit(Visitor<T> visitor);\n\n  /**\n   * Force this type to resolve, even if the registry is in a lazy\n   * resolving mode.\n   * @see #resolve\n   */\n  public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {\n    ResolveMode oldResolveMode = registry.getResolveMode();\n    registry.setResolveMode(ResolveMode.IMMEDIATE);\n    JSType result = resolve(t, scope);\n    registry.setResolveMode(oldResolveMode);\n    return result;\n  }", "forceResolve": "\n  public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {\n    ResolveMode oldResolveMode = registry.getResolveMode();\n    registry.setResolveMode(ResolveMode.IMMEDIATE);\n    JSType result = resolve(t, scope);\n    registry.setResolveMode(oldResolveMode);\n    return result;\n  }", "resolve": "\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "resolveInternal": "\n  abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n\n  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }", "setResolvedTypeInternal": "\n  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }", "isResolved": "\n  public final boolean isResolved() {\n    return resolved;\n  }", "clearResolved": "\n  public final void clearResolved() {\n    resolved = false;\n    resolveResult = null;\n  }", "safeResolve": "\n  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }", "toDebugHashCodeString": "\n  public String toDebugHashCodeString() {\n    return \"{\" + this.hashCode() + \"}\";\n  }"}