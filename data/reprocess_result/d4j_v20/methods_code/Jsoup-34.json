{"pos": "\n    int pos() {\n        return pos;\n    }", "isEmpty": "\n    boolean isEmpty() {\n        return pos >= length;\n    }", "current": "\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }", "consume": "\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }", "unconsume": "\n    void unconsume() {\n        pos--;\n    }", "advance": "\n    void advance() {\n        pos++;\n    }", "mark": "\n    void mark() {\n        mark = pos;\n    }", "rewindToMark": "\n    void rewindToMark() {\n        pos = mark;\n    }", "consumeAsString": "\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }", "nextIndexOf": "\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }", "consumeTo": "\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }", "consumeToAny": "\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }", "consumeToEnd": "\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }", "consumeLetterSequence": "\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }", "consumeLetterThenDigitSequence": "\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }", "consumeHexSequence": "\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }", "consumeDigitSequence": "\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }", "matches": "\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }", "matchesIgnoreCase": "\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }", "matchesAny": "\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }", "matchesLetter": "\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }", "matchesDigit": "\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }", "matchConsume": "\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }", "matchConsumeIgnoreCase": "\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }", "containsIgnoreCase": "\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }", "toString": "\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }"}