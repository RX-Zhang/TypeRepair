{"setCodec": "\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }", "getCodec": "\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }", "version": "\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "close": "\n    public void close() throws IOException\n    {\n        if (!_closed) {\n            _closed = true;\n            _nodeCursor = null;\n            _currToken = null;\n        }\n    }", "nextToken": "\n    public JsonToken nextToken() throws IOException, JsonParseException\n    {\n        if (_nextToken != null) {\n            _currToken = _nextToken;\n            _nextToken = null;\n            return _currToken;\n        }\n        // are we to descend to a container child?\n        if (_startContainer) {\n            _startContainer = false;\n            // minor optimization: empty containers can be skipped\n            if (!_nodeCursor.currentHasChildren()) {\n                _currToken = (_currToken == JsonToken.START_OBJECT) ?\n                    JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n                return _currToken;\n            }\n            _nodeCursor = _nodeCursor.iterateChildren();\n            _currToken = _nodeCursor.nextToken();\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        // No more content?\n        if (_nodeCursor == null) {\n            _closed = true; // if not already set\n            return null;\n        }\n        // Otherwise, next entry from current cursor\n        _currToken = _nodeCursor.nextToken();\n        if (_currToken != null) {\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _startContainer = true;\n            }\n            return _currToken;\n        }\n        // null means no more children; need to return end marker\n        _currToken = _nodeCursor.endToken();\n        _nodeCursor = _nodeCursor.getParent();\n        return _currToken;\n    }", "skipChildren": "\n    public JsonParser skipChildren() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.START_OBJECT) {\n            _startContainer = false;\n            _currToken = JsonToken.END_OBJECT;\n        } else if (_currToken == JsonToken.START_ARRAY) {\n            _startContainer = false;\n            _currToken = JsonToken.END_ARRAY;\n        }\n        return this;\n    }", "isClosed": "\n    public boolean isClosed() {\n        return _closed;\n    }", "getCurrentName": "\n    public String getCurrentName() {\n        return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName();\n    }", "overrideCurrentName": "\n    public void overrideCurrentName(String name)\n    {\n        if (_nodeCursor != null) {\n            _nodeCursor.overrideCurrentName(name);\n        }\n    }", "getParsingContext": "\n    public JsonStreamContext getParsingContext() {\n        return _nodeCursor;\n    }", "getTokenLocation": "\n    public JsonLocation getTokenLocation() {\n        return JsonLocation.NA;\n    }", "getCurrentLocation": "\n    public JsonLocation getCurrentLocation() {\n        return JsonLocation.NA;\n    }", "getText": "\n    public String getText()\n    {\n        if (_closed) {\n            return null;\n        }\n        // need to separate handling a bit...\n        switch (_currToken) {\n        case FIELD_NAME:\n            return _nodeCursor.getCurrentName();\n        case VALUE_STRING:\n            return currentNode().textValue();\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return String.valueOf(currentNode().numberValue());\n        case VALUE_EMBEDDED_OBJECT:\n            JsonNode n = currentNode();\n            if (n != null && n.isBinary()) {\n                // this will convert it to base64\n                return n.asText();\n            }\n        default:\n        \treturn (_currToken == null) ? null : _currToken.asString();\n        }\n    }", "getTextCharacters": "\n    public char[] getTextCharacters() throws IOException, JsonParseException {\n        return getText().toCharArray();\n    }", "getTextLength": "\n    public int getTextLength() throws IOException, JsonParseException {\n        return getText().length();\n    }", "getTextOffset": "\n    public int getTextOffset() throws IOException, JsonParseException {\n        return 0;\n    }", "hasTextCharacters": "\n    public boolean hasTextCharacters() {\n        // generally we do not have efficient access as char[], hence:\n        return false;\n    }", "getNumberType": "\n    public NumberType getNumberType() throws IOException, JsonParseException {\n        JsonNode n = currentNumericNode();\n        return (n == null) ? null : n.numberType();\n    }", "getBigIntegerValue": "\n    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n    {\n        return currentNumericNode().bigIntegerValue();\n    }", "getDecimalValue": "\n    public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n        return currentNumericNode().decimalValue();\n    }", "getDoubleValue": "\n    public double getDoubleValue() throws IOException, JsonParseException {\n        return currentNumericNode().doubleValue();\n    }", "getFloatValue": "\n    public float getFloatValue() throws IOException, JsonParseException {\n        return (float) currentNumericNode().doubleValue();\n    }", "getLongValue": "\n    public long getLongValue() throws IOException, JsonParseException {\n        return currentNumericNode().longValue();\n    }", "getIntValue": "\n    public int getIntValue() throws IOException, JsonParseException {\n        return currentNumericNode().intValue();\n    }", "getNumberValue": "\n    public Number getNumberValue() throws IOException, JsonParseException {\n        return currentNumericNode().numberValue();\n    }", "getEmbeddedObject": "\n    public Object getEmbeddedObject()\n    {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n != null) {\n                if (n.isPojo()) {\n                    return ((POJONode) n).getPojo();\n                }\n                if (n.isBinary()) {\n                    return ((BinaryNode) n).binaryValue();\n                }\n            }\n        }\n        return null;\n    }", "isNaN": "\n    public boolean isNaN() {\n        if (!_closed) {\n            JsonNode n = currentNode();\n            if (n instanceof NumericNode) {\n                return ((NumericNode) n).isNaN();\n            }\n        }\n        return false;\n    }", "getBinaryValue": "\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        // Multiple possibilities...\n        JsonNode n = currentNode();\n        if (n != null) {\n            // [databind#2096]: although `binaryValue()` works for real binary node\n            // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n            byte[] data = n.binaryValue();\n            if (data != null) {\n                return data;\n            }\n            if (n.isPojo()) {\n                Object ob = ((POJONode) n).getPojo();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n            }\n        }\n        // otherwise return null to mark we have no binary content\n        return null;\n    }", "readBinaryValue": "\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n    {\n        byte[] data = getBinaryValue(b64variant);\n        if (data != null) {\n            out.write(data, 0, data.length);\n            return data.length;\n        }\n        return 0;\n    }", "currentNode": "\n    protected JsonNode currentNode() {\n        if (_closed || _nodeCursor == null) {\n            return null;\n        }\n        return _nodeCursor.currentNode();\n    }", "currentNumericNode": "\n    protected JsonNode currentNumericNode()\n        throws JsonParseException\n    {\n        JsonNode n = currentNode();\n        if (n == null || !n.isNumber()) {\n            JsonToken t = (n == null) ? null : n.asToken();\n            throw _constructError(\"Current token (\"+t+\") not numeric, cannot use numeric value accessors\");\n        }\n        return n;\n    }", "_handleEOF": "\n    protected void _handleEOF() throws JsonParseException {\n        _throwInternal(); // should never get called\n    }"}