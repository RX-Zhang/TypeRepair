{"nodeName": "\n    public abstract String nodeName();\n\n    /**\n     * Get an attribute's value by its key.\n     * <p/>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.", "attr": "\n    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributes.hasKey(attributeKey))\n            return attributes.get(attributeKey);\n        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }", "attributes": "\n    public Attributes attributes() {\n        return attributes;\n    }", "hasAttr": "\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        return attributes.hasKey(attributeKey);\n    }", "removeAttr": "\n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }", "baseUri": "\n    public String baseUri() {\n        return baseUri;\n    }", "setBaseUri": "\n    public void setBaseUri(String baseUri) {\n        Validate.notNull(baseUri);\n        this.baseUri = baseUri;\n    }", "absUrl": "\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }", "childNode": "\n    public Node childNode(int index) {\n        return childNodes.get(index);\n    }", "childNodes": "\n    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }", "childNodesAsArray": "\n    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }", "parent": "\n    public Node parent() {\n        return parentNode;\n    }", "ownerDocument": "\n    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }", "remove": "\n    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }", "before": "\n    public Node before(String html) {\n        addSiblingHtml(siblingIndex(), html);\n        return this;\n    }", "after": "\n    public Node after(String html) {\n        addSiblingHtml(siblingIndex()+1, html);\n        return this;\n    }", "addSiblingHtml": "\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }", "wrap": "\n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }", "getDeepChild": "\n    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }", "replaceWith": "\n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }", "setParentNode": "\n    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }", "replaceChild": "\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }", "removeChild": "\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }", "addChildren": "\n    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        for (Node child: children) {\n            reparentChild(child);\n            childNodes.add(child);\n            child.setSiblingIndex(childNodes.size()-1);\n        }\n    }", "reparentChild": "\n    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }", "reindexChildren": "\n    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }", "siblingNodes": "\n    public List<Node> siblingNodes() {\n        return parent().childNodes(); // TODO: should this strip out this node? i.e. not a sibling of self?\n    }", "nextSibling": "\n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }", "previousSibling": "\n    public Node previousSibling() {\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }", "siblingIndex": "\n    public int siblingIndex() {\n        return siblingIndex;\n    }", "setSiblingIndex": "\n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }", "outerHtml": "\n    public String outerHtml() {\n        StringBuilder accum = new StringBuilder(32*1024);\n        outerHtml(accum);\n        return accum.toString();\n    }", "getOutputSettings": "\n    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }", "outerHtmlHead": "\n    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    public String toString() {\n        return outerHtml();\n    }", "outerHtmlTail": "\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    public String toString() {\n        return outerHtml();\n    }", "toString": "\n    public String toString() {\n        return outerHtml();\n    }", "indent": "\n    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }", "equals": "\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        // todo: have nodes hold a child index, compare against that and parent (not children)\n        return false;\n    }", "hashCode": "\n    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        // not children, or will block stack as they go back up to parent)\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }", "clone": "\n    public Node clone() {\n        return doClone(null); // splits for orphan\n    }", "doClone": "\n    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); // clone() creates orphans, doClone() keeps parent\n\n        return clone;\n    }", "head": "\n        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }", "tail": "\n        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n                node.outerHtmlTail(accum, depth, out);\n        }"}