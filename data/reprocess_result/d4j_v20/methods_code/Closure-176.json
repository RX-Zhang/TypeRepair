{"inferArguments": "\n  private void inferArguments(Scope functionScope) {\n    Node functionNode = functionScope.getRootNode();\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType != null) {\n      Node parameterTypes = functionType.getParametersNode();\n      if (parameterTypes != null) {\n        Node parameterTypeNode = parameterTypes.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n          Var var = functionScope.getVar(astParameter.getString());\n          Preconditions.checkNotNull(var);\n          if (var.isTypeInferred() &&\n              var.getType() == unknownType) {\n            JSType newType = null;\n\n            if (iifeArgumentNode != null) {\n              newType = iifeArgumentNode.getJSType();\n            } else if (parameterTypeNode != null) {\n              newType = parameterTypeNode.getJSType();\n            }\n\n            if (newType != null) {\n              var.setType(newType);\n              astParameter.setJSType(newType);\n            }\n          }\n\n          if (parameterTypeNode != null) {\n            parameterTypeNode = parameterTypeNode.getNext();\n          }\n          if (iifeArgumentNode != null) {\n            iifeArgumentNode = iifeArgumentNode.getNext();\n          }\n        }\n      }\n    }\n  }", "createInitialEstimateLattice": "\n  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }", "createEntryLattice": "\n  FlowScope createEntryLattice() {\n    return functionScope;\n  }", "flowThrough": "\n  FlowScope flowThrough(Node n, FlowScope input) {\n    // If we have not walked a path from <entry> to <n>, then we don't\n    // want to infer anything about this scope.\n    if (input == bottomScope) {\n      return input;\n    }\n\n    FlowScope output = input.createChildFlowScope();\n    output = traverse(n, output);\n    return output;\n  }", "branchedFlowThrough": "\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably too expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            Node obj = item.getNext();\n\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\n\n            if (item.isVar()) {\n              item = item.getFirstChild();\n            }\n            if (item.isName()) {\n              JSType iterKeyType = getNativeType(STRING_TYPE);\n              ObjectType objType = getJSType(obj).dereference();\n              JSType objIndexType = objType == null ?\n                  null : objType.getTemplateTypeMap().getTemplateType(\n                      registry.getObjectIndexKey());\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\n                JSType narrowedKeyType =\n                    iterKeyType.getGreatestSubtype(objIndexType);\n                if (!narrowedKeyType.isEmptyType()) {\n                  iterKeyType = narrowedKeyType;\n                }\n              }\n              redeclareSimpleVar(informed, item, iterKeyType);\n            }\n            newScope = informed;\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.isCase()) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.isAnd() ||\n                condition.isOr()) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.isAnd() ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }", "traverse": "\n  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n\n      case Token.CAST:\n        scope = traverseChildren(n, scope);\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.hasType()) {\n          n.setJSType(info.getType().evaluate(syntacticScope, registry));\n        }\n        break;\n    }\n\n    return scope;\n  }", "traverseReturn": "\n  private FlowScope traverseReturn(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node retValue = n.getFirstChild();\n    if (retValue != null) {\n      JSType type = functionScope.getRootNode().getJSType();\n      if (type != null) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        if (fnType != null) {\n          inferPropertyTypesToMatchConstraint(\n              retValue.getJSType(), fnType.getReturnType());\n        }\n      }\n    }\n    return scope;\n  }", "traverseCatch": "\n  private FlowScope traverseCatch(Node catchNode, FlowScope scope) {\n    Node name = catchNode.getFirstChild();\n    JSType type;\n    // If the catch expression name was declared in the catch use that type,\n    // otherwise use \"unknown\".\n    JSDocInfo info = name.getJSDocInfo();\n    if (info != null && info.hasType()) {\n      type = info.getType().evaluate(syntacticScope, registry);\n    } else {\n      type = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    redeclareSimpleVar(scope, name, type);\n    name.setJSType(type);\n    return scope;\n  }", "traverseAssign": "\n  private FlowScope traverseAssign(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = getJSType(right);\n    n.setJSType(rightType);\n\n    updateScopeForTypeChange(scope, left, leftType, rightType);\n    return scope;\n  }", "updateScopeForTypeChange": "\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        boolean isVarDeclaration = left.hasChildren();\n\n        // When looking at VAR initializers for declared VARs, we tend\n        // to use the declared type over the type it's being\n        // initialized to in the global scope.\n        //\n        // For example,\n        // /** @param {number} */ var f = goog.abstractMethod;\n        // it's obvious that the programmer wants you to use\n        // the declared function signature, not the inferred signature.\n        //\n        // Or,\n        // /** @type {Object.<string>} */ var x = {};\n        // the one-time anonymous object on the right side\n        // is as narrow as it can possibly be, but we need to make\n        // sure we back-infer the <string> element constraint on\n        // the left hand side, so we use the left hand side.\n\n        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            // Makes it easier to check for NPEs.\n\n        // TODO(nicksantos): This might be a better check once we have\n        // back-inference of object/array constraints.  It will probably\n        // introduce more type warnings.  It uses the result type iff it's\n        // strictly narrower than the declared var type.\n        //\n        //boolean isVarTypeBetter = isVarDeclaration &&\n        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n        //     || !resultType.isSubtype(varType));\n\n\n        if (isVarTypeBetter) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }", "ensurePropertyDefined": "\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor = obj.isThis() &&\n        getJSType(syntacticScope.getRootNode()).isConstructor();\n\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        // In general, we don't want to define a property on a struct object,\n        // b/c TypeCheck will later check for improper property creation on\n        // structs. There are two exceptions.\n        // 1) If it's a property created inside the constructor, on the newly\n        //    created instance, allow it.\n        // 2) If it's a prototype property, allow it. For example:\n        //    Foo.prototype.bar = baz;\n        //    where Foo.prototype is a struct and the assignment happens at the\n        //    top level and the constructor Foo is defined in the same file.\n        boolean staticPropCreation = false;\n        Node maybeAssignStm = getprop.getParent().getParent();\n        if (syntacticScope.isGlobal() &&\n            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n          String propCreationFilename = maybeAssignStm.getSourceFileName();\n          Node ctor = objectType.getOwnerFunction().getSource();\n          if (ctor != null &&\n              ctor.getSourceFileName().equals(propCreationFilename)) {\n            staticPropCreation = true;\n          }\n        }\n        if (!propCreationInConstructor && !staticPropCreation) {\n          return; // Early return to avoid creating the property below.\n        }\n      }\n\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the property.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(propName, rightType, getprop);\n          }\n        } else if (propCreationInConstructor) {\n          objectType.defineInferredProperty(propName, rightType, getprop);\n        } else {\n          registry.registerPropertyOnType(propName, objectType);\n        }\n      }\n    }\n  }", "ensurePropertyDeclared": "\n  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }", "ensurePropertyDeclaredHelper": "\n  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }", "traverseName": "\n  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped and assigned in an inner scope, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable = isInferred &&\n            isUnflowable(syntacticScope.getVar(varName));\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable. That variable is assigned more than once,\n        // and we can't know which type we're getting.\n        //\n        // var t = null; function f() { (t); } doStuff(); t = {};\n        //\n        // Notice that this heuristic isn't perfect. For example, you might\n        // have:\n        //\n        // function f() { (t); } f(); var t = 3;\n        //\n        // In this case, we would infer the first reference to t as\n        // type {number}, even though it's undefined.\n        boolean nonLocalInferredSlot = false;\n        if (isInferred && syntacticScope.isLocal()) {\n          Var maybeOuterVar = syntacticScope.getParent().getVar(varName);\n          if (var == maybeOuterVar &&\n              !maybeOuterVar.isMarkedAssignedExactlyOnce()) {\n            nonLocalInferredSlot = true;\n          }\n        }\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = unknownType;\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }", "traverseArrayLiteral": "\n  private FlowScope traverseArrayLiteral(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n    n.setJSType(getNativeType(ARRAY_TYPE));\n    return scope;\n  }", "traverseObjectLiteral": "\n  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n      scope = traverse(name.getFirstChild(), scope);\n    }\n\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCast and goog.reflect.object\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null\n        || n.getBooleanProp(Node.REFLECTED_OBJECT)\n        || objectType.isEnumType()) {\n      return scope;\n    }\n\n    String qObjName = NodeUtil.getBestLValueName(\n        NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null;\n         name = name.getNext()) {\n      String memberName = NodeUtil.getObjectLitKeyName(name);\n      if (memberName != null) {\n        JSType rawValueType =  name.getFirstChild().getJSType();\n        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n            name, rawValueType);\n        if (valueType == null) {\n          valueType = unknownType;\n        }\n        objectType.defineInferredProperty(memberName, valueType, name);\n\n        // Do normal flow inference if this is a direct property assignment.\n        if (qObjName != null && name.isStringKey()) {\n          String qKeyName = qObjName + \".\" + memberName;\n          Var var = syntacticScope.getVar(qKeyName);\n          JSType oldType = var == null ? null : var.getType();\n          if (var != null && var.isTypeInferred()) {\n            var.setType(oldType == null ?\n                valueType : oldType.getLeastSupertype(oldType));\n          }\n\n          scope.inferQualifiedSlot(name, qKeyName,\n              oldType == null ? unknownType : oldType,\n              valueType);\n        }\n      } else {\n        n.setJSType(unknownType);\n      }\n    }\n    return scope;\n  }", "traverseAdd": "\n  private FlowScope traverseAdd(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = left.getNext();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = right.getJSType();\n\n    JSType type = unknownType;\n    if (leftType != null && rightType != null) {\n      boolean leftIsUnknown = leftType.isUnknownType();\n      boolean rightIsUnknown = rightType.isUnknownType();\n      if (leftIsUnknown && rightIsUnknown) {\n        type = unknownType;\n      } else if ((!leftIsUnknown && leftType.isString()) ||\n                 (!rightIsUnknown && rightType.isString())) {\n        type = getNativeType(STRING_TYPE);\n      } else if (leftIsUnknown || rightIsUnknown) {\n        type = unknownType;\n      } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) {\n        type = getNativeType(NUMBER_TYPE);\n      } else {\n        type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE);\n      }\n    }\n    n.setJSType(type);\n\n    if (n.isAssignAdd()) {\n      updateScopeForTypeChange(scope, left, leftType, type);\n    }\n\n    return scope;\n  }", "isAddedAsNumber": "\n  private boolean isAddedAsNumber(JSType type) {\n    return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE,\n        NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE));\n  }", "traverseHook": "\n  private FlowScope traverseHook(Node n, FlowScope scope) {\n    Node condition = n.getFirstChild();\n    Node trueNode = condition.getNext();\n    Node falseNode = n.getLastChild();\n\n    // verify the condition\n    scope = traverse(condition, scope);\n\n    // reverse abstract interpret the condition to produce two new scopes\n    FlowScope trueScope = reverseInterpreter.\n        getPreciserScopeKnowingConditionOutcome(\n            condition, scope, true);\n    FlowScope falseScope = reverseInterpreter.\n        getPreciserScopeKnowingConditionOutcome(\n            condition, scope, false);\n\n    // traverse the true node with the trueScope\n    traverse(trueNode, trueScope.createChildFlowScope());\n\n    // traverse the false node with the falseScope\n    traverse(falseNode, falseScope.createChildFlowScope());\n\n    // meet true and false nodes' types and assign\n    JSType trueType = trueNode.getJSType();\n    JSType falseType = falseNode.getJSType();\n    if (trueType != null && falseType != null) {\n      n.setJSType(trueType.getLeastSupertype(falseType));\n    } else {\n      n.setJSType(null);\n    }\n\n    return scope.createChildFlowScope();\n  }", "traverseCall": "\n  private FlowScope traverseCall(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node left = n.getFirstChild();\n    JSType functionType = getJSType(left).restrictByNotNullOrUndefined();\n    if (functionType.isFunctionType()) {\n      FunctionType fnType = functionType.toMaybeFunctionType();\n      n.setJSType(fnType.getReturnType());\n      backwardsInferenceFromCallSite(n, fnType);\n    } else if (functionType.isEquivalentTo(\n        getNativeType(CHECKED_UNKNOWN_TYPE))) {\n      n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n    }\n\n    scope = tightenTypesAfterAssertions(scope, n);\n    return scope;\n  }", "tightenTypesAfterAssertions": "\n  private FlowScope tightenTypesAfterAssertions(FlowScope scope,\n      Node callNode) {\n    Node left = callNode.getFirstChild();\n    Node firstParam = left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec =\n        assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec == null || firstParam == null) {\n      return scope;\n    }\n    Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode == null) {\n      return scope;\n    }\n    JSType assertedType = assertionFunctionSpec.getAssertedType(\n        callNode, registry);\n    String assertedNodeName = assertedNode.getQualifiedName();\n\n    JSType narrowed;\n    // Handle assertions that enforce expressions evaluate to true.\n    if (assertedType == null) {\n      // Handle arbitrary expressions within the assert.\n      scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n          assertedNode, scope, true);\n      // Build the result of the assertExpression\n      narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined();\n    } else {\n      // Handle assertions that enforce expressions are of a certain type.\n      JSType type = getJSType(assertedNode);\n      narrowed = type.getGreatestSubtype(assertedType);\n      if (assertedNodeName != null && type.differsFrom(narrowed)) {\n        scope = narrowScope(scope, assertedNode, narrowed);\n      }\n    }\n\n    callNode.setJSType(narrowed);\n    return scope;\n  }", "narrowScope": "\n  private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) {\n    if (node.isThis()) {\n      // \"this\" references don't need to be modeled in the control flow graph.\n      return scope;\n    }\n\n    scope = scope.createChildFlowScope();\n    if (node.isGetProp()) {\n      scope.inferQualifiedSlot(\n          node, node.getQualifiedName(), getJSType(node), narrowed);\n    } else {\n      redeclareSimpleVar(scope, node, narrowed);\n    }\n    return scope;\n  }", "backwardsInferenceFromCallSite": "\n  private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n    boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n    if (updatedFnType) {\n      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n    }\n    updateTypeOfParameters(n, fnType);\n    updateBind(n);\n  }", "updateBind": "\n  private void updateBind(Node n) {\n    CodingConvention.Bind bind =\n        compiler.getCodingConvention().describeFunctionBind(n, true);\n    if (bind == null) {\n      return;\n    }\n\n    FunctionType callTargetFn = getJSType(bind.target)\n        .restrictByNotNullOrUndefined().toMaybeFunctionType();\n    if (callTargetFn == null) {\n      return;\n    }\n\n    n.setJSType(\n        callTargetFn.getBindReturnType(\n            // getBindReturnType expects the 'this' argument to be included.\n            bind.getBoundParameterCount() + 1));\n  }", "updateTypeOfParameters": "\n  private void updateTypeOfParameters(Node n, FunctionType fnType) {\n    int i = 0;\n    int childCount = n.getChildCount();\n    for (Node iParameter : fnType.getParameters()) {\n      if (i + 1 >= childCount) {\n        // TypeCheck#visitParametersList will warn so we bail.\n        return;\n      }\n\n      JSType iParameterType = getJSType(iParameter);\n      Node iArgument = n.getChildAtIndex(i + 1);\n      JSType iArgumentType = getJSType(iArgument);\n      inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);\n\n      // TODO(johnlenz): Filter out non-function types\n      // (such as null and undefined) as\n      // we only care about FUNCTION subtypes here.\n      JSType restrictedParameter = iParameterType\n          .restrictByNotNullOrUndefined()\n          .toMaybeFunctionType();\n      if (restrictedParameter != null) {\n        if (iArgument.isFunction() &&\n            iArgumentType.isFunctionType() &&\n            iArgument.getJSDocInfo() == null) {\n          iArgument.setJSType(restrictedParameter);\n        }\n      }\n      i++;\n    }\n  }", "inferTemplateTypesFromParameters": "\n  private Map<TemplateType, JSType> inferTemplateTypesFromParameters(\n      FunctionType fnType, Node call) {\n    if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {\n      return Collections.emptyMap();\n    }\n\n    Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap();\n    Set<JSType> seenTypes = Sets.newIdentityHashSet();\n\n    Node callTarget = call.getFirstChild();\n    if (NodeUtil.isGet(callTarget)) {\n      Node obj = callTarget.getFirstChild();\n      maybeResolveTemplatedType(\n          fnType.getTypeOfThis(),\n          getJSType(obj),\n          resolvedTypes,\n          seenTypes);\n    }\n\n    if (call.hasMoreThanOneChild()) {\n      maybeResolveTemplateTypeFromNodes(\n          fnType.getParameters(),\n          call.getChildAtIndex(1).siblings(),\n          resolvedTypes,\n          seenTypes);\n    }\n    return resolvedTypes;\n  }", "maybeResolveTemplatedType": "\n  private void maybeResolveTemplatedType(\n      JSType paramType,\n      JSType argType,\n      Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) {\n    if (paramType.isTemplateType()) {\n      // @param {T}\n      resolvedTemplateType(\n          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n    } else if (paramType.isUnionType()) {\n      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n      UnionType unionType = paramType.toMaybeUnionType();\n      for (JSType alernative : unionType.getAlternates()) {\n        maybeResolveTemplatedType(alernative, argType, resolvedTypes, seenTypes);\n      }\n    } else if (paramType.isFunctionType()) {\n      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n      FunctionType argFunctionType = argType\n          .restrictByNotNullOrUndefined()\n          .collapseUnion()\n          .toMaybeFunctionType();\n      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n        // infer from return type of the function type\n        maybeResolveTemplatedType(\n            paramFunctionType.getTypeOfThis(),\n            argFunctionType.getTypeOfThis(), resolvedTypes, seenTypes);\n        // infer from return type of the function type\n        maybeResolveTemplatedType(\n            paramFunctionType.getReturnType(),\n            argFunctionType.getReturnType(), resolvedTypes, seenTypes);\n        // infer from parameter types of the function type\n        maybeResolveTemplateTypeFromNodes(\n            paramFunctionType.getParameters(),\n            argFunctionType.getParameters(), resolvedTypes, seenTypes);\n      }\n    } else if (paramType.isRecordType() && !paramType.isNominalType()) {\n      // @param {{foo:T}}\n      if(!seenTypes.contains(paramType)) {\n        seenTypes.add(paramType);\n        ObjectType paramRecordType = paramType.toObjectType();\n        ObjectType argObjectType = argType.restrictByNotNullOrUndefined()\n            .toObjectType();\n        if (argObjectType != null\n            && !argObjectType.isUnknownType()\n            && !argObjectType.isEmptyType()) {\n          Set<String> names = paramRecordType.getPropertyNames();\n          for (String name : names) {\n            if (paramRecordType.hasOwnProperty(name)\n                && argObjectType.hasProperty(name)) {\n              maybeResolveTemplatedType(\n                  paramRecordType.getPropertyType(name),\n                  argObjectType.getPropertyType(name),\n                  resolvedTypes,\n                  seenTypes);\n            }\n          }\n        }\n        seenTypes.remove(paramType);\n      }\n    } else if (paramType.isTemplatizedType()) {\n      // @param {Array.<T>}\n      ObjectType referencedParamType = paramType\n          .toMaybeTemplatizedType()\n          .getReferencedType();\n      JSType argObjectType = argType\n          .restrictByNotNullOrUndefined()\n          .collapseUnion();\n\n      if (argObjectType.isSubtype(referencedParamType)) {\n        // If the argument type is a subtype of the parameter type, resolve any\n        // template types amongst their templatized types.\n        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n          maybeResolveTemplatedType(\n              paramTypeMap.getTemplateType(key),\n              argTypeMap.getTemplateType(key),\n              resolvedTypes, seenTypes);\n        }\n      }\n    }\n  }", "maybeResolveTemplateTypeFromNodes": "\n  private void maybeResolveTemplateTypeFromNodes(\n      Iterable<Node> declParams,\n      Iterable<Node> callParams,\n      Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) {\n    maybeResolveTemplateTypeFromNodes(\n        declParams.iterator(), callParams.iterator(), resolvedTypes, seenTypes);\n  }", "resolvedTemplateType": "\n  private static void resolvedTemplateType(\n      Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n    JSType previous = map.get(template);\n    if (!resolved.isUnknownType()) {\n      if (previous == null) {\n        map.put(template, resolved);\n      } else {\n        JSType join = previous.getLeastSupertype(resolved);\n        map.put(template, join);\n      }\n    }\n  }", "caseTemplateType": "\n    public JSType caseTemplateType(TemplateType type) {\n      madeChanges = true;\n      JSType replacement = replacements.get(type);\n      return replacement != null ?\n          replacement : registry.getNativeType(UNKNOWN_TYPE);\n    }", "inferTemplatedTypesForCall": "\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types\n    Map<TemplateType, JSType> inferred = Maps.filterKeys(\n        inferTemplateTypesFromParameters(fnType, n),\n        new Predicate<TemplateType>() {\n\n          @Override\n          public boolean apply(TemplateType key) {\n            return keys.contains(key);\n          }}\n        );\n\n    // Replace all template types. If we couldn't find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferred);\n    Node callTarget = n.getFirstChild();\n\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    return replacer.madeChanges;\n  }", "traverseNew": "\n  private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node constructor = n.getFirstChild();\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = unknownType;\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          backwardsInferenceFromCallSite(n, ct);\n\n          // If necessary, create a TemplatizedType wrapper around the instance\n          // type, based on the types of the constructor parameters.\n          ObjectType instanceType = ct.getInstanceType();\n          Map<TemplateType, JSType> inferredTypes =\n              inferTemplateTypesFromParameters(ct, n);\n          if (inferredTypes.isEmpty()) {\n            type = instanceType;\n          } else {\n            type = registry.createTemplatizedType(instanceType, inferredTypes);\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }", "traverseAnd": "\n  private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {\n    return traverseShortCircuitingBinOp(n, scope, true);\n  }", "traverseChildren": "\n  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }", "traverseGetElem": "\n  private FlowScope traverseGetElem(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n    JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined();\n    TemplateTypeMap typeMap = type.getTemplateTypeMap();\n    if (typeMap.hasTemplateType(registry.getObjectElementKey())) {\n      n.setJSType(typeMap.getTemplateType(registry.getObjectElementKey()));\n    }\n    return dereferencePointer(n.getFirstChild(), scope);\n  }", "traverseGetProp": "\n  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }", "inferPropertyTypesToMatchConstraint": "\n  private static void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    type.matchConstraint(constraint);\n  }", "dereferencePointer": "\n  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }\n    }\n    return scope;\n  }", "getPropertyType": "\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // We often have a couple of different types to choose from for the\n    // property. Ordered by accuracy, we have\n    // 1) A locally inferred qualified name (which is in the FlowScope)\n    // 2) A globally declared qualified name (which is in the FlowScope)\n    // 3) A property on the owner type (which is on objType)\n    // 4) A name in the type registry (as a last resort)\n    JSType propertyType = null;\n    boolean isLocallyInferred = false;\n\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        boolean isDeclared = !var.isTypeInferred();\n        isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));\n        if (isDeclared || isLocallyInferred) {\n          propertyType = varType;\n        }\n      }\n    }\n\n    if (propertyType == null && objType != null) {\n      JSType foundType = objType.findPropertyType(propName);\n      if (foundType != null) {\n        propertyType = foundType;\n      }\n    }\n\n    if (propertyType != null && objType != null) {\n      JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n      if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n          && propertyType.hasAnyTemplateTypes()) {\n        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n            registry, typeMap);\n        propertyType = propertyType.visit(replacer);\n      }\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType())\n        && qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    if (propertyType == null) {\n      return unknownType;\n    } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n      // If the type has been checked in this scope,\n      // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n      return getNativeType(CHECKED_UNKNOWN_TYPE);\n    } else {\n      return propertyType;\n    }\n  }", "traverseOr": "\n  private BooleanOutcomePair traverseOr(Node n, FlowScope scope) {\n    return traverseShortCircuitingBinOp(n, scope, false);\n  }", "traverseShortCircuitingBinOp": "\n  private BooleanOutcomePair traverseShortCircuitingBinOp(\n      Node n, FlowScope scope, boolean condition) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n\n    // type the left node\n    BooleanOutcomePair leftLiterals =\n        traverseWithinShortCircuitingBinOp(left,\n            scope.createChildFlowScope());\n    JSType leftType = left.getJSType();\n\n    // reverse abstract interpret the left node to produce the correct\n    // scope in which to verify the right node\n    FlowScope rightScope = reverseInterpreter.\n        getPreciserScopeKnowingConditionOutcome(\n            left, leftLiterals.getOutcomeFlowScope(left.getType(), condition),\n            condition);\n\n    // type the right node\n    BooleanOutcomePair rightLiterals =\n        traverseWithinShortCircuitingBinOp(\n            right, rightScope.createChildFlowScope());\n    JSType rightType = right.getJSType();\n\n    JSType type;\n    BooleanOutcomePair literals;\n    if (leftType != null && rightType != null) {\n      leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition);\n      if (leftLiterals.toBooleanOutcomes ==\n          BooleanLiteralSet.get(!condition)) {\n        // Use the restricted left type, since the right side never gets\n        // evaluated.\n        type = leftType;\n        literals = leftLiterals;\n      } else {\n        // Use the join of the restricted left type knowing the outcome of the\n        // ToBoolean predicate and of the right type.\n        type = leftType.getLeastSupertype(rightType);\n        literals =\n            getBooleanOutcomePair(leftLiterals, rightLiterals, condition);\n      }\n\n      // Exclude the boolean type if the literal set is empty because a boolean\n      // can never actually be returned.\n      if (literals.booleanValues == BooleanLiteralSet.EMPTY &&\n          getNativeType(BOOLEAN_TYPE).isSubtype(type)) {\n        // Exclusion only make sense for a union type.\n        if (type.isUnionType()) {\n          type = type.toMaybeUnionType().getRestrictedUnion(\n              getNativeType(BOOLEAN_TYPE));\n        }\n      }\n    } else {\n      type = null;\n      literals = new BooleanOutcomePair(\n          BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH,\n          leftLiterals.getJoinedFlowScope(),\n          rightLiterals.getJoinedFlowScope());\n    }\n    n.setJSType(type);\n\n    return literals;\n  }", "traverseWithinShortCircuitingBinOp": "\n  private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n,\n      FlowScope scope) {\n    switch (n.getType()) {\n      case Token.AND:\n        return traverseAnd(n, scope);\n\n      case Token.OR:\n        return traverseOr(n, scope);\n\n      default:\n        scope = traverse(n, scope);\n        return newBooleanOutcomePair(n.getJSType(), scope);\n    }\n  }", "getBooleanOutcomePair": "\n  BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left,\n      BooleanOutcomePair right, boolean condition) {\n    return new BooleanOutcomePair(\n        getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes,\n                           condition),\n        getBooleanOutcomes(left.booleanValues, right.booleanValues, condition),\n        left.getJoinedFlowScope(), right.getJoinedFlowScope());\n  }", "getBooleanOutcomes": "\n  static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left,\n      BooleanLiteralSet right, boolean condition) {\n    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));\n  }", "getJoinedFlowScope": "\n    FlowScope getJoinedFlowScope() {\n      if (joinedScope == null) {\n        if (leftScope == rightScope) {\n          joinedScope = rightScope;\n        } else {\n          joinedScope = join(leftScope, rightScope);\n        }\n      }\n      return joinedScope;\n    }", "getOutcomeFlowScope": "\n    FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) {\n      if (nodeType == Token.AND && outcome ||\n          nodeType == Token.OR && !outcome) {\n        // We know that the whole expression must have executed.\n        return rightScope;\n      } else {\n        return getJoinedFlowScope();\n      }\n    }", "newBooleanOutcomePair": "\n  private BooleanOutcomePair newBooleanOutcomePair(\n      JSType jsType, FlowScope flowScope) {\n    if (jsType == null) {\n      return new BooleanOutcomePair(\n          BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope);\n    }\n    return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(),\n        registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ?\n            BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY,\n        flowScope, flowScope);\n  }", "redeclareSimpleVar": "\n  private void redeclareSimpleVar(\n      FlowScope scope, Node nameNode, JSType varType) {\n    Preconditions.checkState(nameNode.isName());\n    String varName = nameNode.getString();\n    if (varType == null) {\n      varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    if (isUnflowable(syntacticScope.getVar(varName))) {\n      return;\n    }\n    scope.inferSlotType(varName, varType);\n  }", "isUnflowable": "\n  private boolean isUnflowable(Var v) {\n    return v != null && v.isLocal() && v.isMarkedEscaped() &&\n        // It's OK to flow a variable in the scope where it's escaped.\n        v.getScope() == syntacticScope;\n  }", "getJSType": "\n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return unknownType;\n    } else {\n      return jsType;\n    }\n  }", "getNativeType": "\n  private JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }"}