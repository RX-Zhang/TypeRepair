{"types": "\n    public static Class<?>[] types() {\n        return new Class<?>[] {\n            File.class,\n            URL.class,\n            URI.class,\n            Class.class,\n            JavaType.class,\n            Currency.class,\n            Pattern.class,\n            Locale.class,\n            Charset.class,\n            TimeZone.class,\n            InetAddress.class,\n            InetSocketAddress.class,\n        };\n    }", "findDeserializer": "\n    public static Std findDeserializer(Class<?> rawType)\n    {\n        int kind = 0;\n        if (rawType == File.class) {\n            kind = Std.STD_FILE;\n        } else if (rawType == URL.class) {\n            kind = Std.STD_URL;\n        } else if (rawType == URI.class) {\n            kind = Std.STD_URI;\n        } else if (rawType == Class.class) {\n            kind = Std.STD_CLASS;\n        } else if (rawType == JavaType.class) {\n            kind = Std.STD_JAVA_TYPE;\n        } else if (rawType == Currency.class) {\n            kind = Std.STD_CURRENCY;\n        } else if (rawType == Pattern.class) {\n            kind = Std.STD_PATTERN;\n        } else if (rawType == Locale.class) {\n            kind = Std.STD_LOCALE;\n        } else if (rawType == Charset.class) {\n            kind = Std.STD_CHARSET;\n        } else if (rawType == TimeZone.class) {\n            kind = Std.STD_TIME_ZONE;\n        } else if (rawType == InetAddress.class) {\n            kind = Std.STD_INET_ADDRESS;\n        } else if (rawType == InetSocketAddress.class) {\n            kind = Std.STD_INET_SOCKET_ADDRESS;\n        } else {\n            return null;\n        }\n        return new Std(rawType, kind);\n    }", "deserialize": "\n    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Issue#381\n        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            jp.nextToken();\n            final T value = deserialize(jp, ctxt);\n            if (jp.nextToken() != JsonToken.END_ARRAY) {\n                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n            }\n            return value;\n        }\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = jp.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                T result = _deserialize(text, ctxt);\n                if (result != null) {\n                    return result;\n                }\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            // nothing to do here, yet? We'll fail anyway\n        }\n        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = jp.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        throw ctxt.mappingException(_valueClass);\n    }", "_deserialize": "\n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n\n    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        // default impl: error out\n        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n    }", "_deserializeEmbedded": "\n    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        // default impl: error out\n        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n    }", "_deserializeFromEmptyString": "\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }"}