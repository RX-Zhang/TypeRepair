{"unwrappingDeserializer": "\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n    {\n        /* main thing really is to just enforce ignoring of unknown\n         * properties; since there may be multiple unwrapped values\n         * and properties for all may be interleaved...\n         */\n        return new BuilderBasedDeserializer(this, unwrapper);\n    }", "withObjectIdReader": "\n    public BeanDeserializerBase withObjectIdReader(ObjectIdReader oir) {\n        return new BuilderBasedDeserializer(this, oir);\n    }", "withIgnorableProperties": "\n    public BeanDeserializerBase withIgnorableProperties(Set<String> ignorableProps) {\n        return new BuilderBasedDeserializer(this, ignorableProps);\n    }", "withBeanProperties": "\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BuilderBasedDeserializer(this, props);\n    }", "asArrayDeserializer": "\n    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayBuilderDeserializer(this, props, _buildMethod);\n    }", "finishBuild": "\n    protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n            throws IOException\n    {\n        // As per [databind#777], allow returning builder itself\n        if (null == _buildMethod) {\n            return builder;\n        }\n        try {\n            return _buildMethod.getMember().invoke(builder);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }", "deserialize": "\n    public final Object deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n\n        // common case first:\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n            if (_vanillaProcessing) {\n            \treturn finishBuild(ctxt, vanillaDeserialize(p, ctxt, t));\n            }\n            Object builder = deserializeFromObject(p, ctxt);\n            return finishBuild(ctxt, builder);\n        }\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n            switch (t) {\n            case VALUE_STRING:\n                return finishBuild(ctxt, deserializeFromString(p, ctxt));\n            case VALUE_NUMBER_INT:\n                return finishBuild(ctxt, deserializeFromNumber(p, ctxt));\n            case VALUE_NUMBER_FLOAT:\n            \treturn finishBuild(ctxt, deserializeFromDouble(p, ctxt));\n            case VALUE_EMBEDDED_OBJECT:\n                return p.getEmbeddedObject();\n            case VALUE_TRUE:\n            case VALUE_FALSE:\n                return finishBuild(ctxt, deserializeFromBoolean(p, ctxt));\n            case START_ARRAY:\n                // these only work if there's a (delegating) creator...\n                return finishBuild(ctxt, deserializeFromArray(p, ctxt));\n            case FIELD_NAME:\n            case END_OBJECT:\n                return finishBuild(ctxt, deserializeFromObject(p, ctxt));\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }", "_deserialize": "\n    protected final Object _deserialize(JsonParser p,\n            DeserializationContext ctxt, Object builder)\n        throws IOException, JsonProcessingException\n    {\n        if (_injectables != null) {\n            injectValues(ctxt, builder);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, builder);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, builder);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, builder, view);\n            }\n        }\n        JsonToken t = p.getCurrentToken();\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                } catch (Exception e) {\n                    wrapAndThrow(e, builder, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, handledType(), propName);\n        }\n        return builder;\n    }", "vanillaDeserialize": "\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException, JsonProcessingException\n    {\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n            } else {\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            }\n        }\n        return bean;\n    }", "deserializeFromObject": "\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            return deserializeFromObjectUsingNonDefault(p, ctxt);\n        }\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return bean;\n    }", "_deserializeUsingPropertyBased": "\n    protected final Object _deserializeUsingPropertyBased(final JsonParser p,\n            final DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; // never gets here\n                    }\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return _deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // As per [JACKSON-313], things marked as ignorable should not be\n            // passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p, ctxt);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            bean = wrapInstantiationProblem(e, ctxt);\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }", "deserializeWithView": "\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                if (!prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return bean;\n    }", "deserializeWithUnwrapped": "\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n        }\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }", "deserializeUsingPropertyBasedWithUnwrapped": "\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    t = p.nextToken();\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue;\n                    }\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken();\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }", "deserializeWithExternalTypeId": "\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }", "deserializeUsingPropertyBasedWithExternalTypeId": "\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // !!! 04-Mar-2012, TODO: Need to fix -- will not work as is...\n        throw new IllegalStateException(\"Deserialization with Builder, External type id, @JsonCreator not yet implemented\");\n    }"}