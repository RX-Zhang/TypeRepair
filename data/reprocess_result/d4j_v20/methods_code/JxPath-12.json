{"testNode": "\n    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }", "equalStrings": "\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        s1 = s1 == null ? \"\" : s1.trim();\n        s2 = s2 == null ? \"\" : s2.trim();\n        return s1.equals(s2);\n    }", "getName": "\n    public QName getName() {\n        String ln = null;\n        String ns = null;\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            ns = DOMNodePointer.getPrefix(node);\n            ln = DOMNodePointer.getLocalName(node);\n        }\n        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n            ln = ((ProcessingInstruction) node).getTarget();\n        }\n        return new QName(ns, ln);\n    }", "getNamespaceURI": "\n    public String getNamespaceURI() {\n        return getNamespaceURI(node);\n    }", "childIterator": "\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        return new DOMNodeIterator(this, test, reverse, startWith);\n    }", "attributeIterator": "\n    public NodeIterator attributeIterator(QName name) {\n        return new DOMAttributeIterator(this, name);\n    }", "namespacePointer": "\n    public NodePointer namespacePointer(String prefix) {\n        return new NamespacePointer(this, prefix);\n    }", "namespaceIterator": "\n    public NodeIterator namespaceIterator() {\n        return new DOMNamespaceIterator(this);\n    }", "getDefaultNamespaceURI": "\n    public String getDefaultNamespaceURI() {\n        if (defaultNamespace == null) {\n            Node aNode = node;\n            if (aNode instanceof Document) {\n                aNode = ((Document) aNode).getDocumentElement();\n            }\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n                    if (attr != null) {\n                        defaultNamespace = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        if (defaultNamespace == null) {\n            defaultNamespace = \"\";\n        }\n        // TBD: We are supposed to resolve relative URIs to absolute ones.\n        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n    }", "getBaseValue": "\n    public Object getBaseValue() {\n        return node;\n    }", "getImmediateNode": "\n    public Object getImmediateNode() {\n        return node;\n    }", "isActual": "\n    public boolean isActual() {\n        return true;\n    }", "isCollection": "\n    public boolean isCollection() {\n        return false;\n    }", "getLength": "\n    public int getLength() {\n        return 1;\n    }", "isLeaf": "\n    public boolean isLeaf() {\n        return !node.hasChildNodes();\n    }", "isLanguage": "\n    public boolean isLanguage(String lang) {\n        String current = getLanguage();\n        return current == null ? super.isLanguage(lang)\n                : current.toUpperCase().startsWith(lang.toUpperCase());\n    }", "findEnclosingAttribute": "\n    protected static String findEnclosingAttribute(Node n, String attrName) {\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                Element e = (Element) n;\n                String attr = e.getAttribute(attrName);\n                if (attr != null && !attr.equals(\"\")) {\n                    return attr;\n                }\n            }\n            n = n.getParentNode();\n        }\n        return null;\n    }", "getLanguage": "\n    protected String getLanguage() {\n        return findEnclosingAttribute(node, \"xml:lang\");\n    }", "setValue": "\n    public void setValue(Object value) {\n        if (node.getNodeType() == Node.TEXT_NODE\n            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n            String string = (String) TypeUtils.convert(value, String.class);\n            if (string != null && !string.equals(\"\")) {\n                node.setNodeValue(string);\n            }\n            else {\n                node.getParentNode().removeChild(node);\n            }\n        }\n        else {\n            NodeList children = node.getChildNodes();\n            int count = children.getLength();\n            for (int i = count; --i >= 0;) {\n                Node child = children.item(i);\n                node.removeChild(child);\n            }\n\n            if (value instanceof Node) {\n                Node valueNode = (Node) value;\n                if (valueNode instanceof Element\n                    || valueNode instanceof Document) {\n                    children = valueNode.getChildNodes();\n                    for (int i = 0; i < children.getLength(); i++) {\n                        Node child = children.item(i);\n                        node.appendChild(child.cloneNode(true));\n                    }\n                }\n                else {\n                    node.appendChild(valueNode.cloneNode(true));\n                }\n            }\n            else {\n                String string = (String) TypeUtils.convert(value, String.class);\n                if (string != null && !string.equals(\"\")) {\n                    Node textNode =\n                        node.getOwnerDocument().createTextNode(string);\n                    node.appendChild(textNode);\n                }\n            }\n        }\n    }", "createChild": "\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index) \n    {\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        boolean success =\n            getAbstractFactory(context).createObject(\n                context,\n                this,\n                node,\n                name.toString(),\n                index);\n        if (success) {\n            NodeTest nodeTest;\n            String prefix = name.getPrefix();\n            String namespaceURI = prefix == null ? null : \n                context.getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(name, namespaceURI);\n\n            NodeIterator it = childIterator(nodeTest, false, null);\n            if (it != null && it.setPosition(index + 1)) {\n                return it.getNodePointer();\n            }\n        }\n        throw new JXPathAbstractFactoryException(\n                \"Factory could not create a child node for path: \" + asPath()\n                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n    }", "createAttribute": "\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        if (!(node instanceof Element)) {\n            return super.createAttribute(context, name);\n        }\n        Element element = (Element) node;\n        String prefix = name.getPrefix();\n        if (prefix != null) {\n            String ns = getNamespaceURI(prefix);\n            if (ns == null) {\n                throw new JXPathException(\n                    \"Unknown namespace prefix: \" + prefix);\n            }\n            element.setAttributeNS(ns, name.toString(), \"\");\n        }\n        else {\n            if (!element.hasAttribute(name.getName())) {\n                element.setAttribute(name.getName(), \"\");\n            }\n        }\n        NodeIterator it = attributeIterator(name);\n        it.setPosition(1);\n        return it.getNodePointer();\n    }", "remove": "\n    public void remove() {\n        Node parent = node.getParentNode();\n        if (parent == null) {\n            throw new JXPathException(\"Cannot remove root DOM node\");\n        }\n        parent.removeChild(node);\n    }", "asPath": "\n    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                String target = ((ProcessingInstruction) node).getTarget();\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(target).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI(target)).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n        }\n        return buffer.toString();\n    }", "escape": "\n    private String escape(String string) {\n        int index = string.indexOf('\\'');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&apos;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\'');\n        }\n        index = string.indexOf('\\\"');\n        while (index != -1) {\n            string =\n                string.substring(0, index)\n                    + \"&quot;\"\n                    + string.substring(index + 1);\n            index = string.indexOf('\\\"');\n        }\n        return string;\n    }", "getRelativePositionByName": "\n    private int getRelativePositionByName() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String nm = n.getNodeName();\n                if (nm.equals(node.getNodeName())) {\n                    count++;\n                }\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }", "getRelativePositionOfElement": "\n    private int getRelativePositionOfElement() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }", "getRelativePositionOfTextNode": "\n    private int getRelativePositionOfTextNode() {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.TEXT_NODE\n                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }", "getRelativePositionOfPI": "\n    private int getRelativePositionOfPI(String target) {\n        int count = 1;\n        Node n = node.getPreviousSibling();\n        while (n != null) {\n            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n                count++;\n            }\n            n = n.getPreviousSibling();\n        }\n        return count;\n    }", "hashCode": "\n    public int hashCode() {\n        return System.identityHashCode(node);\n    }", "equals": "\n    public boolean equals(Object object) {\n        return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n    }", "getPrefix": "\n    public static String getPrefix(Node node) {\n        String prefix = node.getPrefix();\n        if (prefix != null) {\n            return prefix;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? null : name.substring(0, index);\n    }", "getLocalName": "\n    public static String getLocalName(Node node) {\n        String localName = node.getLocalName();\n        if (localName != null) {\n            return localName;\n        }\n\n        String name = node.getNodeName();\n        int index = name.lastIndexOf(':');\n        return index < 0 ? name : name.substring(index + 1);\n    }", "getValue": "\n    public Object getValue() {\n        if (node.getNodeType() == Node.COMMENT_NODE) {\n            String text = ((Comment) node).getData();\n            return text == null ? \"\" : text.trim();\n        }\n        return stringValue(node);\n    }", "stringValue": "\n    private String stringValue(Node node) {\n        int nodeType = node.getNodeType();\n        if (nodeType == Node.COMMENT_NODE) {\n            return \"\";\n        }\n        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n        if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n            String text = node.getNodeValue();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n            String text = ((ProcessingInstruction) node).getData();\n            return text == null ? \"\" : trim ? text.trim() : text;\n        }\n        NodeList list = node.getChildNodes();\n        StringBuffer buf = new StringBuffer(16);\n        for (int i = 0; i < list.getLength(); i++) {\n            Node child = list.item(i);\n            buf.append(stringValue(child));\n        }\n        return buf.toString();\n    }", "getPointerByID": "\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                : node.getOwnerDocument();\n        Element element = document.getElementById(id);\n        return element == null ? (Pointer) new NullPointer(getLocale(), id)\n                : new DOMNodePointer(element, getLocale(), id);\n    }", "getAbstractFactory": "\n    private AbstractFactory getAbstractFactory(JXPathContext context) {\n        AbstractFactory factory = context.getFactory();\n        if (factory == null) {\n            throw new JXPathException(\n                \"Factory is not set on the JXPathContext - \"\n                    + \"cannot create path: \"\n                    + asPath());\n        }\n        return factory;\n    }", "compareChildNodePointers": "\n    public int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2)\n    {\n        Node node1 = (Node) pointer1.getBaseValue();\n        Node node2 = (Node) pointer2.getBaseValue();\n        if (node1 == node2) {\n            return 0;\n        }\n\n        int t1 = node1.getNodeType();\n        int t2 = node2.getNodeType();\n        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n            return -1;\n        }\n        if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            return 1;\n        }\n        if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n            NamedNodeMap map = ((Node) getNode()).getAttributes();\n            int length = map.getLength();\n            for (int i = 0; i < length; i++) {\n                Node n = map.item(i);\n                if (n == node1) {\n                    return -1;\n                }\n                if (n == node2) {\n                    return 1;\n                }\n            }\n            return 0; // Should not happen\n        }\n\n        Node current = node.getFirstChild();\n        while (current != null) {\n            if (current == node1) {\n                return -1;\n            }\n            if (current == node2) {\n                return 1;\n            }\n            current = current.getNextSibling();\n        }\n        return 0;\n    }"}