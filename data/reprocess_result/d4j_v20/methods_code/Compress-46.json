{"getHeaderId": "\n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }", "getLocalFileDataLength": "\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0) +\n                (bit1_accessTimePresent && accessTime != null ? 4 : 0) +\n                (bit2_createTimePresent && createTime != null ? 4 : 0)\n        );\n    }", "getCentralDirectoryLength": "\n    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0)\n        );\n    }", "getLocalFileDataData": "\n    public byte[] getLocalFileDataData() {\n        final byte[] data = new byte[getLocalFileDataLength().getValue()];\n        int pos = 0;\n        data[pos++] = 0;\n        if (bit0_modifyTimePresent) {\n            data[0] |= MODIFY_TIME_BIT;\n            System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit1_accessTimePresent && accessTime != null) {\n            data[0] |= ACCESS_TIME_BIT;\n            System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit2_createTimePresent && createTime != null) {\n            data[0] |= CREATE_TIME_BIT;\n            System.arraycopy(createTime.getBytes(), 0, data, pos, 4);\n            pos += 4; // NOSONAR - assignment as documentation\n        }\n        return data;\n    }", "getCentralDirectoryData": "\n    public byte[] getCentralDirectoryData() {\n        final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n        final byte[] localData = getLocalFileDataData();\n\n        // Truncate out create & access time (last 8 bytes) from\n        // the copy of the local data we obtained:\n        System.arraycopy(localData, 0, centralData, 0, centralData.length);\n        return centralData;\n    }", "parseFromLocalFileData": "\n    public void parseFromLocalFileData(\n            final byte[] data, int offset, final int length\n    ) throws ZipException {\n        reset();\n        final int len = offset + length;\n        setFlags(data[offset++]);\n        if (bit0_modifyTimePresent) {\n            modifyTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n\n        // Notice the extra length check in case we are parsing the shorter\n        // central data field (for both access and create timestamps).\n        if (bit1_accessTimePresent && offset + 4 <= len) {\n            accessTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n        if (bit2_createTimePresent && offset + 4 <= len) {\n            createTime = new ZipLong(data, offset);\n            offset += 4; // NOSONAR - assignment as documentation\n        }\n    }", "parseFromCentralDirectoryData": "\n    public void parseFromCentralDirectoryData(\n            final byte[] buffer, final int offset, final int length\n    ) throws ZipException {\n        reset();\n        parseFromLocalFileData(buffer, offset, length);\n    }", "reset": "\n    private void reset() {\n        setFlags((byte) 0);\n        this.modifyTime = null;\n        this.accessTime = null;\n        this.createTime = null;\n    }", "setFlags": "\n    public void setFlags(final byte flags) {\n        this.flags = flags;\n        this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\n        this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\n        this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n    }", "getFlags": "\n    public byte getFlags() { return flags; }", "isBit0_modifyTimePresent": "\n    public boolean isBit0_modifyTimePresent() { return bit0_modifyTimePresent; }", "isBit1_accessTimePresent": "\n    public boolean isBit1_accessTimePresent() { return bit1_accessTimePresent; }", "isBit2_createTimePresent": "\n    public boolean isBit2_createTimePresent() { return bit2_createTimePresent; }", "getModifyTime": "\n    public ZipLong getModifyTime() { return modifyTime; }", "getAccessTime": "\n    public ZipLong getAccessTime() { return accessTime; }", "getCreateTime": "\n    public ZipLong getCreateTime() { return createTime; }", "getModifyJavaTime": "\n    public Date getModifyJavaTime() {\n        return zipLongToDate(modifyTime);\n    }", "getAccessJavaTime": "\n    public Date getAccessJavaTime() {\n        return zipLongToDate(accessTime);\n    }", "zipLongToDate": "\n    private static Date zipLongToDate(ZipLong unixTime) {\n        return unixTime != null ? new Date(unixTime.getIntValue() * 1000L) : null;\n    }", "getCreateJavaTime": "\n    public Date getCreateJavaTime() {\n        return zipLongToDate(createTime);\n    }", "setModifyTime": "\n    public void setModifyTime(final ZipLong l) {\n        bit0_modifyTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | MODIFY_TIME_BIT)\n                        : (flags & ~MODIFY_TIME_BIT));\n        this.modifyTime = l;\n    }", "setAccessTime": "\n    public void setAccessTime(final ZipLong l) {\n        bit1_accessTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | ACCESS_TIME_BIT)\n                        : (flags & ~ACCESS_TIME_BIT));\n        this.accessTime = l;\n    }", "setCreateTime": "\n    public void setCreateTime(final ZipLong l) {\n        bit2_createTimePresent = l != null;\n        flags = (byte) (l != null ? (flags | CREATE_TIME_BIT)\n                        : (flags & ~CREATE_TIME_BIT));\n        this.createTime = l;\n    }", "setModifyJavaTime": "\n    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }", "setAccessJavaTime": "\n    public void setAccessJavaTime(final Date d) { setAccessTime(dateToZipLong(d)); }", "setCreateJavaTime": "\n    public void setCreateJavaTime(final Date d) { setCreateTime(dateToZipLong(d)); }", "dateToZipLong": "\n    private static ZipLong dateToZipLong(final Date d) {\n        if (d == null) { return null; }\n\n        return unixTimeToZipLong(d.getTime() / 1000);\n    }", "unixTimeToZipLong": "\n    private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x100000000L;\n        if (l >= TWO_TO_32) {\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }", "toString": "\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"0x5455 Zip Extra Field: Flags=\");\n        buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append(\" \");\n        if (bit0_modifyTimePresent && modifyTime != null) {\n            final Date m = getModifyJavaTime();\n            buf.append(\" Modify:[\").append(m).append(\"] \");\n        }\n        if (bit1_accessTimePresent && accessTime != null) {\n            final Date a = getAccessJavaTime();\n            buf.append(\" Access:[\").append(a).append(\"] \");\n        }\n        if (bit2_createTimePresent && createTime != null) {\n            final Date c = getCreateJavaTime();\n            buf.append(\" Create:[\").append(c).append(\"] \");\n        }\n        return buf.toString();\n    }", "clone": "\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }", "equals": "\n    public boolean equals(final Object o) {\n        if (o instanceof X5455_ExtendedTimestamp) {\n            final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n\n            // The ZipLong==ZipLong clauses handle the cases where both are null.\n            // and only last 3 bits of flags matter.\n            return ((flags & 0x07) == (xf.flags & 0x07)) &&\n                    (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n                    (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n                    (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n        }\n        return false;\n    }", "hashCode": "\n    public int hashCode() {\n        int hc = (-123 * (flags & 0x07)); // only last 3 bits of flags matter\n        if (modifyTime != null) {\n            hc ^= modifyTime.hashCode();\n        }\n        if (accessTime != null) {\n            // Since accessTime is often same as modifyTime,\n            // this prevents them from XOR negating each other.\n            hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);\n        }\n        if (createTime != null) {\n            hc ^= Integer.rotateLeft(createTime.hashCode(), 22);\n        }\n        return hc;\n    }"}