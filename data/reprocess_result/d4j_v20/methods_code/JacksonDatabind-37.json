{"constructUnsafe": "\n    public static SimpleType constructUnsafe(Class<?> raw) {\n        return new SimpleType(raw, null,\n                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?\n                null, null, null, null, false);\n    }", "construct": "\n    public static SimpleType construct(Class<?> cls)\n    {\n        /* Let's add sanity checks, just to ensure no\n         * Map/Collection entries are constructed\n         */\n        if (Map.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n        }\n        if (Collection.class.isAssignableFrom(cls)) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }", "_narrow": "\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }", "withContentType": "\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }", "withTypeHandler": "\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }", "withContentTypeHandler": "\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }", "withValueHandler": "\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);\n    }", "withContentValueHandler": "\n    public  SimpleType withContentValueHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n    }", "withStaticTyping": "\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this : new SimpleType(_class, _bindings,\n                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);\n    }", "refine": "\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // SimpleType means something not-specialized, so:\n        return null;\n    }", "buildCanonicalName": "\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                JavaType t = containedType(i);\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }", "isContainerType": "\n    public boolean isContainerType() { return false; }", "getErasedSignature": "\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }", "getGenericSignature": "\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n\n        final int count = _bindings.size();\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = containedType(i).getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }", "toString": "\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }", "equals": "\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical... \n        if (other._class != this._class) return false;\n\n        // And finally, generic bindings, if any\n        TypeBindings b1 = _bindings;\n        TypeBindings b2 = other._bindings;\n        return b1.equals(b2);\n    }"}