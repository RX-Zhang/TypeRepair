{"equals": "\n    public boolean equals(final TarArchiveEntry it) {\n        return getName().equals(it.getName());\n    }", "hashCode": "\n    public int hashCode() {\n        return getName().hashCode();\n    }", "isDescendent": "\n    public boolean isDescendent(final TarArchiveEntry desc) {\n        return desc.getName().startsWith(getName());\n    }", "getName": "\n    public String getName() {\n        return name;\n    }", "setName": "\n    public void setName(final String name) {\n        this.name = normalizeFileName(name, this.preserveLeadingSlashes);\n    }", "setMode": "\n    public void setMode(final int mode) {\n        this.mode = mode;\n    }", "getLinkName": "\n    public String getLinkName() {\n        return linkName;\n    }", "setLinkName": "\n    public void setLinkName(final String link) {\n        this.linkName = link;\n    }", "getUserId": "\n    public int getUserId() {\n        return (int) (userId & 0xffffffff);\n    }", "setUserId": "\n    public void setUserId(final int userId) {\n        setUserId((long) userId);\n    }", "getLongUserId": "\n    public long getLongUserId() {\n        return userId;\n    }", "getGroupId": "\n    public int getGroupId() {\n        return (int) (groupId & 0xffffffff);\n    }", "setGroupId": "\n    public void setGroupId(final int groupId) {\n        setGroupId((long) groupId);\n    }", "getLongGroupId": "\n    public long getLongGroupId() {\n        return groupId;\n    }", "getUserName": "\n    public String getUserName() {\n        return userName;\n    }", "setUserName": "\n    public void setUserName(final String userName) {\n        this.userName = userName;\n    }", "getGroupName": "\n    public String getGroupName() {\n        return groupName;\n    }", "setGroupName": "\n    public void setGroupName(final String groupName) {\n        this.groupName = groupName;\n    }", "setIds": "\n    public void setIds(final int userId, final int groupId) {\n        setUserId(userId);\n        setGroupId(groupId);\n    }", "setNames": "\n    public void setNames(final String userName, final String groupName) {\n        setUserName(userName);\n        setGroupName(groupName);\n    }", "setModTime": "\n    public void setModTime(final long time) {\n        modTime = time / MILLIS_PER_SECOND;\n    }", "getModTime": "\n    public Date getModTime() {\n        return new Date(modTime * MILLIS_PER_SECOND);\n    }", "getLastModifiedDate": "\n    public Date getLastModifiedDate() {\n        return getModTime();\n    }", "isCheckSumOK": "\n    public boolean isCheckSumOK() {\n        return checkSumOK;\n    }", "getFile": "\n    public File getFile() {\n        return file;\n    }", "getMode": "\n    public int getMode() {\n        return mode;\n    }", "getSize": "\n    public long getSize() {\n        return size;\n    }", "setSize": "\n    public void setSize(final long size) {\n        if (size < 0){\n            throw new IllegalArgumentException(\"Size is out of range: \"+size);\n        }\n        this.size = size;\n    }", "getDevMajor": "\n    public int getDevMajor() {\n        return devMajor;\n    }", "setDevMajor": "\n    public void setDevMajor(final int devNo) {\n        if (devNo < 0){\n            throw new IllegalArgumentException(\"Major device number is out of \"\n                                               + \"range: \" + devNo);\n        }\n        this.devMajor = devNo;\n    }", "getDevMinor": "\n    public int getDevMinor() {\n        return devMinor;\n    }", "setDevMinor": "\n    public void setDevMinor(final int devNo) {\n        if (devNo < 0){\n            throw new IllegalArgumentException(\"Minor device number is out of \"\n                                               + \"range: \" + devNo);\n        }\n        this.devMinor = devNo;\n    }", "isExtended": "\n    public boolean isExtended() {\n        return isExtended;\n    }", "getRealSize": "\n    public long getRealSize() {\n        return realSize;\n    }", "isGNUSparse": "\n    public boolean isGNUSparse() {\n        return isOldGNUSparse() || isPaxGNUSparse();\n    }", "isOldGNUSparse": "\n    public boolean isOldGNUSparse() {\n        return linkFlag == LF_GNUTYPE_SPARSE;\n    }", "isPaxGNUSparse": "\n    public boolean isPaxGNUSparse() {\n        return paxGNUSparse;\n    }", "isStarSparse": "\n    public boolean isStarSparse() {\n        return starSparse;\n    }", "isGNULongLinkEntry": "\n    public boolean isGNULongLinkEntry() {\n        return linkFlag == LF_GNUTYPE_LONGLINK;\n    }", "isGNULongNameEntry": "\n    public boolean isGNULongNameEntry() {\n        return linkFlag == LF_GNUTYPE_LONGNAME;\n    }", "isPaxHeader": "\n    public boolean isPaxHeader(){\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }", "isGlobalPaxHeader": "\n    public boolean isGlobalPaxHeader(){\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }", "isDirectory": "\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }", "isFile": "\n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }", "isSymbolicLink": "\n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }", "isLink": "\n    public boolean isLink() {\n        return linkFlag == LF_LINK;\n    }", "isCharacterDevice": "\n    public boolean isCharacterDevice() {\n        return linkFlag == LF_CHR;\n    }", "isBlockDevice": "\n    public boolean isBlockDevice() {\n        return linkFlag == LF_BLK;\n    }", "isFIFO": "\n    public boolean isFIFO() {\n        return linkFlag == LF_FIFO;\n    }", "isSparse": "\n    public boolean isSparse() {\n        return isGNUSparse() || isStarSparse();\n    }", "getDirectoryEntries": "\n    public TarArchiveEntry[] getDirectoryEntries() {\n        if (file == null || !file.isDirectory()) {\n            return EMPTY_TAR_ARCHIVE_ENTRIES;\n        }\n\n        final String[] list = file.list();\n        if (list == null) {\n            return EMPTY_TAR_ARCHIVE_ENTRIES;\n        }\n        final TarArchiveEntry[] result = new TarArchiveEntry[list.length];\n\n        for (int i = 0; i < result.length; ++i) {\n            result[i] = new TarArchiveEntry(new File(file, list[i]));\n        }\n\n        return result;\n    }", "writeEntryHeader": "\n    public void writeEntryHeader(final byte[] outbuf) {\n        try {\n            writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n        } catch (final IOException ex) {\n            try {\n                writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n            } catch (final IOException ex2) {\n                // impossible\n                throw new RuntimeException(ex2);\n            }\n        }\n    }", "writeEntryHeaderField": "\n    private int writeEntryHeaderField(final long value, final byte[] outbuf, final int offset,\n                                      final int length, final boolean starMode) {\n        if (!starMode && (value < 0\n                          || value >= 1l << 3 * (length - 1))) {\n            // value doesn't fit into field when written as octal\n            // number, will be written to PAX header or causes an\n            // error\n            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n        }\n        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n                                                     length);\n    }", "parseTarHeader": "\n    public void parseTarHeader(final byte[] header) {\n        try {\n            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n        } catch (final IOException ex) {\n            try {\n                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n            } catch (final IOException ex2) {\n                // not really possible\n                throw new RuntimeException(ex2);\n            }\n        }\n    }", "normalizeFileName": "\n    private static String normalizeFileName(String fileName,\n                                            final boolean preserveLeadingSlashes) {\n        final String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n\n        if (osname != null) {\n\n            // Strip off drive letters!\n            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n\n            if (osname.startsWith(\"windows\")) {\n                if (fileName.length() > 2) {\n                    final char ch1 = fileName.charAt(0);\n                    final char ch2 = fileName.charAt(1);\n\n                    if (ch2 == ':'\n                        && (ch1 >= 'a' && ch1 <= 'z'\n                            || ch1 >= 'A' && ch1 <= 'Z')) {\n                        fileName = fileName.substring(2);\n                    }\n                }\n            } else if (osname.contains(\"netware\")) {\n                final int colon = fileName.indexOf(':');\n                if (colon != -1) {\n                    fileName = fileName.substring(colon + 1);\n                }\n            }\n        }\n\n        fileName = fileName.replace(File.separatorChar, '/');\n\n        // No absolute pathnames\n        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n        // so we loop on starting /'s.\n        while (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\n            fileName = fileName.substring(1);\n        }\n        return fileName;\n    }", "evaluateType": "\n    private int evaluateType(final byte[] header) {\n        if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\n            return FORMAT_OLDGNU;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\n            if (ArchiveUtils.matchAsciiBuffer(MAGIC_XSTAR, header, XSTAR_MAGIC_OFFSET,\n                                              XSTAR_MAGIC_LEN)) {\n                return FORMAT_XSTAR;\n            }\n            return FORMAT_POSIX;\n        }\n        return 0;\n    }", "fillGNUSparse0xData": "\n    void fillGNUSparse0xData(final Map<String, String> headers) {\n        paxGNUSparse = true;\n        realSize = Integer.parseInt(headers.get(\"GNU.sparse.size\"));\n        if (headers.containsKey(\"GNU.sparse.name\")) {\n            // version 0.1\n            name = headers.get(\"GNU.sparse.name\");\n        }\n    }", "fillGNUSparse1xData": "\n    void fillGNUSparse1xData(final Map<String, String> headers) {\n        paxGNUSparse = true;\n        realSize = Integer.parseInt(headers.get(\"GNU.sparse.realsize\"));\n        name = headers.get(\"GNU.sparse.name\");\n    }", "fillStarSparseData": "\n    void fillStarSparseData(final Map<String, String> headers) {\n        starSparse = true;\n        if (headers.containsKey(\"SCHILY.realsize\")) {\n            realSize = Long.parseLong(headers.get(\"SCHILY.realsize\"));\n        }\n    }"}