{"withResolved": "\n    protected StringCollectionDeserializer withResolved(JsonDeserializer<?> delegateDeser,\n            JsonDeserializer<?> valueDeser,\n            NullValueProvider nuller, Boolean unwrapSingle)\n    {\n        if ((_unwrapSingle == unwrapSingle) && (_nullProvider == nuller)\n                && (_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) {\n            return this;\n        }\n        return new StringCollectionDeserializer(_containerType, _valueInstantiator,\n                delegateDeser, valueDeser, nuller, unwrapSingle);\n    }", "isCachable": "\n    public boolean isCachable() {\n        // 26-Mar-2015, tatu: Important: prevent caching if custom deserializers via annotations\n        //    are involved\n        return (_valueDeserializer == null) && (_delegateDeserializer == null);\n    }", "createContextual": "\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            // [databind#2324]: check both array-delegating and delegating\n            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n            if (delegateCreator != null) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            // [databind#125]: May have a content converter\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n            // And we may also need to get deserializer for String\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }", "getContentDeserializer": "\n    public JsonDeserializer<Object> getContentDeserializer() {\n        JsonDeserializer<?> deser = _valueDeserializer;\n        return (JsonDeserializer<Object>) deser;\n    }", "getValueInstantiator": "\n    public ValueInstantiator getValueInstantiator() {\n        return _valueInstantiator;\n    }", "deserialize": "\n    public Collection<String> deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return (Collection<String>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n        final Collection<String> result = (Collection<String>) _valueInstantiator.createUsingDefault(ctxt);\n        return deserialize(p, ctxt, result);\n    }", "deserializeUsingCustom": "\n    private Collection<String> deserializeUsingCustom(JsonParser p, DeserializationContext ctxt,\n            Collection<String> result, final JsonDeserializer<String> deser) throws IOException\n    {\n        while (true) {\n            /* 30-Dec-2014, tatu: This may look odd, but let's actually call method\n             *   that suggest we are expecting a String; this helps with some formats,\n             *   notably XML. Note, however, that while we can get String, we can't\n             *   assume that's what we use due to custom deserializer\n             */\n            String value;\n            if (p.nextTextValue() == null) {\n                JsonToken t = p.getCurrentToken();\n                if (t == JsonToken.END_ARRAY) {\n                    break;\n                }\n                // Ok: no need to convert Strings, but must recognize nulls\n                if (t == JsonToken.VALUE_NULL) {\n                    if (_skipNullValues) {\n                        continue;\n                    }\n                    value = (String) _nullProvider.getNullValue(ctxt);\n                } else {\n                    value = deser.deserialize(p, ctxt);\n                }\n            } else {\n                value = deser.deserialize(p, ctxt);\n            }\n            result.add(value);\n        }\n        return result;\n    }", "deserializeWithType": "\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer) throws IOException {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromArray(p, ctxt);\n    }", "handleNonArray": "\n    private final Collection<String> handleNonArray(JsonParser p, DeserializationContext ctxt,\n            Collection<String> result) throws IOException\n    {\n        // implicit arrays from single values?\n        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||\n                ((_unwrapSingle == null) &&\n                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));\n        if (!canWrap) {\n            return (Collection<String>) ctxt.handleUnexpectedToken(_containerType.getRawClass(), p);\n        }\n        // Strings are one of \"native\" (intrinsic) types, so there's never type deserializer involved\n        JsonDeserializer<String> valueDes = _valueDeserializer;\n        JsonToken t = p.getCurrentToken();\n\n        String value;\n        \n        if (t == JsonToken.VALUE_NULL) {\n            // 03-Feb-2017, tatu: Does this work?\n            if (_skipNullValues) {\n                return result;\n            }\n            value = (String) _nullProvider.getNullValue(ctxt);\n        } else {\n            value = (valueDes == null) ? _parseString(p, ctxt) : valueDes.deserialize(p, ctxt);\n        }\n        result.add(value);\n        return result;\n    }"}