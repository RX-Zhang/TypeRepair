{"parse": "\n    public static Document parse(String html, String baseUri) {\n        Parser parser = new Parser(html, baseUri, false);\n        return parser.parse();\n    }", "parseBodyFragment": "\n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Parser parser = new Parser(bodyHtml, baseUri, true);\n        return parser.parse();\n    }", "parseBodyFragmentRelaxed": "\n    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n        Parser parser = new Parser(bodyHtml, baseUri, true);\n        parser.relaxed = true;\n        return parser.parse();\n    }", "parseComment": "\n    private void parseComment() {\n        tq.consume(\"<!--\");\n        String data = tq.chompTo(\"->\");\n\n        if (data.endsWith(\"-\")) // i.e. was -->\n            data = data.substring(0, data.length()-1);\n        Comment comment = new Comment(data, baseUri);\n        last().appendChild(comment);\n    }", "parseXmlDecl": "\n    private void parseXmlDecl() {\n        tq.consume(\"<\");\n        Character firstChar = tq.consume(); // <? or <!, from initial match.\n        boolean procInstr = firstChar.toString().equals(\"!\");\n        String data = tq.chompTo(\">\");\n\n        XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr);\n        last().appendChild(decl);\n    }", "parseEndTag": "\n    private void parseEndTag() {\n        tq.consume(\"</\");\n        String tagName = tq.consumeTagName();\n        tq.chompTo(\">\");\n\n        if (tagName.length() != 0) {\n            Tag tag = Tag.valueOf(tagName);\n            popStackToClose(tag);\n        }\n    }", "parseStartTag": "\n    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeTagName();\n        Validate.notEmpty(tagName, \"Unexpectedly empty tagname. (This should not occur, please report!)\");\n        \n        tq.consumeWhitespace();\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n            if (!tag.isKnownTag()) // if unknown and a self closed, allow it to be self closed on output. this doesn't force all instances to be empty\n                tag.setSelfClosing();\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompToIgnoreCase(\"</\" + tagName);\n            tq.chompTo(\">\");\n            popStackToClose(tag);\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }", "parseAttribute": "\n    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n        String key = tq.consumeAttributeKey();\n        String value = \"\";\n        tq.consumeWhitespace();\n        if (tq.matchChomp(\"=\")) {\n            tq.consumeWhitespace();\n\n            if (tq.matchChomp(SQ)) {\n                value = tq.chompTo(SQ);\n            } else if (tq.matchChomp(DQ)) {\n                value = tq.chompTo(DQ);\n            } else {\n                StringBuilder valueAccum = new StringBuilder();\n                // no ' or \" to look for, so scan to end tag or space (or end of stream)\n                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                    valueAccum.append(tq.consume());\n                }\n                value = valueAccum.toString();\n            }\n            tq.consumeWhitespace();\n        }\n        if (key.length() != 0)\n            return Attribute.createFromEncoded(key, value);\n        else {\n            tq.consume();\n                \n            return null;\n        }\n    }", "parseTextNode": "\n    private void parseTextNode() {\n        TextNode textNode;\n        // special case: handle string like \"hello < there\". first char will be \"<\", because of matchStartTag\n        if (tq.peek().equals('<')) {\n            tq.advance();\n            textNode = new TextNode(\"<\", baseUri);\n        } else {\n            String text = tq.consumeTo(\"<\");\n            textNode = TextNode.createFromEncoded(text, baseUri);\n        }\n        last().appendChild(textNode);\n    }", "parseCdata": "\n    private void parseCdata() {\n        tq.consume(\"<![CDATA[\");\n        String rawText = tq.chompTo(\"]]>\");\n        TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape\n        last().appendChild(textNode);\n    }", "addChildToParent": "\n    private Element addChildToParent(Element child, boolean isEmptyElement) {\n        Element parent = popStackToSuitableContainer(child.tag());\n        Tag childTag = child.tag();\n        boolean validAncestor = stackHasValidParent(childTag);\n\n        if (!validAncestor && !relaxed) {\n            // create implicit parent around this child\n            Tag parentTag = childTag.getImplicitParent();\n            Element implicit = new Element(parentTag, baseUri);\n            // special case: make sure there's a head before putting in body\n            if (child.tag().equals(bodyTag)) {\n                Element head = new Element(headTag, baseUri);\n                implicit.appendChild(head);\n            }\n            implicit.appendChild(child);\n\n            // recurse to ensure somewhere to put parent\n            Element root = addChildToParent(implicit, false);\n            if (!isEmptyElement)\n                stack.addLast(child);\n            return root;\n        }\n\n        parent.appendChild(child);\n\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return parent;\n    }", "stackHasValidParent": "\n    private boolean stackHasValidParent(Tag childTag) {\n        if (stack.size() == 1 && childTag.equals(htmlTag))\n            return true; // root is valid for html node\n\n        if (childTag.requiresSpecificParent())\n            return stack.getLast().tag().isValidParent(childTag);\n\n        // otherwise, look up the stack for valid ancestors\n        for (int i = stack.size() -1; i >= 0; i--) {\n            Element el = stack.get(i);\n            Tag parent2 = el.tag();\n            if (parent2.isValidAncestor(childTag)) {\n                return true;\n            }\n        }\n        return false;\n    }", "popStackToSuitableContainer": "\n    private Element popStackToSuitableContainer(Tag tag) {\n        while (!stack.isEmpty()) {\n            if (last().tag().canContain(tag))\n                return last();\n            else\n                stack.removeLast();\n        }\n        return null;\n    }", "popStackToClose": "\n    private Element popStackToClose(Tag tag) {\n        // first check to see if stack contains this tag; if so pop to there, otherwise ignore\n        int counter = 0;\n        Element elToClose = null;\n        for (int i = stack.size() -1; i > 0; i--) {\n            counter++;\n            Element el = stack.get(i);\n            Tag elTag = el.tag();\n            if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body\n                break;\n            } else if (elTag.equals(tag)) {\n                elToClose = el;\n                break;\n            }\n        }\n        if (elToClose != null) {\n            for (int i = 0; i < counter; i++) {\n                stack.removeLast();\n            }\n        }\n        return elToClose;\n    }", "last": "\n    private Element last() {\n        return stack.getLast();\n    }"}