{"setErrorManager": "\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }", "createMessageFormatter": "\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }", "initOptions": "\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        (warningsGuard == null || !warningsGuard.disables(\n            DiagnosticGroups.CHECK_VARIABLES))) {\n      guards.add(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = new ComposeWarningsGuard(guards);\n  }", "init": "\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }", "initModules": "\n  public void initModules(\n      List<JSSourceFile> externs, List<JSModule> modules,\n      CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }", "initBasedOnOptions": "\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n    }\n  }", "makeCompilerInput": "\n  private List<CompilerInput> makeCompilerInput(\n      List<JSSourceFile> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (JSSourceFile file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }", "checkFirstModule": "\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }", "fillEmptyModules": "\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n      }\n    }\n  }", "rebuildInputsFromModules": "\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByNameMap();\n  }", "getAllInputsFromModules": "\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }", "initInputsByNameMap": "\n  void initInputsByNameMap() {\n    inputsByName = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }", "compile": "\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options) {\n     return compile(extern, new JSSourceFile[] { input }, options);\n  }", "compileModules": "\n  public Result compileModules(List<JSSourceFile> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }", "disableThreads": "\n  public void disableThreads() {\n    useThreads = false;\n  }", "runInCompilerThread": "\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }", "runCallableWithLargeStack": "\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }", "runCallable": "\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }", "compileInternal": "\n  private void compileInternal() {\n    parse();\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n  }", "parse": "\n  public void parse() {\n    parseInputs();\n  }", "getPassConfig": "\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }", "createPassConfigInternal": "\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }", "setPassConfig": "\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }", "precheck": "\n  boolean precheck() {\n    return true;\n  }", "check": "\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }", "externExports": "\n  private void externExports() {\n    logger.info(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }", "process": "\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }", "maybeSanityCheck": "\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }", "runSanityCheck": "\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }", "removeTryCatchFinally": "\n  void removeTryCatchFinally() {\n    logger.info(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }", "stripCode": "\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.info(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }", "runCustomPasses": "\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }", "startPass": "\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }", "endPass": "\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }", "newTracer": "\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }", "stopTracer": "\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }", "getResult": "\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }", "getMessages": "\n  public JSError[] getMessages() {\n    return getErrors();\n  }", "getErrors": "\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }", "getWarnings": "\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }", "getRoot": "\n  public Node getRoot() {\n    return externAndJsRoot;\n  }", "nextUniqueNameId": "\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }", "resetUniqueNameId": "\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }", "getUniqueNameIdSupplier": "\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }", "areNodesEqualForInlining": "\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }", "getInput": "\n  public CompilerInput getInput(String name) {\n    return inputsByName.get(name);\n  }", "removeInput": "\n  protected void removeInput(String name) {\n    CompilerInput input = getInput(name);\n    if (input == null) {\n      return;\n    }\n    inputsByName.remove(name);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }", "newExternInput": "\n  public CompilerInput newExternInput(String name) {\n    if (inputsByName.containsKey(name)) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    SourceAst ast = new SyntheticAst(name);\n    CompilerInput input = new CompilerInput(ast, name, true);\n    inputsByName.put(name, input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    return input;\n  }", "addIncrementalSourceAst": "\n  void addIncrementalSourceAst(JsAst ast) {\n    String sourceName = ast.getSourceFile().getName();\n    Preconditions.checkState(\n        getInput(sourceName) == null,\n        \"Duplicate input of name \" + sourceName);\n    inputsByName.put(sourceName, new CompilerInput(ast));\n  }", "replaceIncrementalSourceAst": "\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    String sourceName = ast.getSourceFile().getName();\n    CompilerInput oldInput =\n        Preconditions.checkNotNull(\n            getInput(sourceName),\n            \"No input to replace: \" + sourceName);\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    inputsByName.put(sourceName, newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n    return true;\n  }", "getModuleGraph": "\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }", "getTypeRegistry": "\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }", "getTypedScopeCreator": "\n  ScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }", "getTopScope": "\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }", "getReverseAbstractInterpreter": "\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }", "getTypeValidator": "\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }", "parseInputs": "\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = new Node(Token.BLOCK);\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Check if the sources need to be re-ordered.\n      if (options.manageClosureDependencies) {\n        for (CompilerInput input : inputs) {\n          input.setCompiler(this);\n\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(\n                  options.manageClosureDependenciesEntryPoints, inputs);\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          return null;\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          return null;\n        }\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }", "parseSyntheticCode": "\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        JSSourceFile.fromCode(\" [synthetic] \", js));\n    inputsByName.put(input.getName(), input);\n    return input.getAstRoot(this);\n  }", "initCompilerOptionsIfTesting": "\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(new CompilerOptions());\n    }\n  }", "parseTestCode": "\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        JSSourceFile.fromCode(\" [testcode] \", js));\n    if (inputsByName == null) {\n      inputsByName = Maps.newHashMap();\n    }\n    inputsByName.put(input.getName(), input);\n    return input.getAstRoot(this);\n  }", "getDefaultErrorReporter": "\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }", "toSource": "\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }", "toSourceArray": "\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }", "reset": "\n    void reset() {\n      sb.setLength(0);\n    }", "append": "\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }", "toString": "\n    public String toString() {\n      return sb.toString();\n    }", "getLength": "\n    public int getLength() {\n      return sb.length();\n    }", "getLineIndex": "\n    int getLineIndex() {\n      return lineCount;\n    }", "getColumnIndex": "\n    int getColumnIndex() {\n      return colCount;\n    }", "endsWith": "\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }", "optimize": "\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }", "setCssRenamingMap": "\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }", "getCssRenamingMap": "\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }", "processDefines": "\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }", "isInliningForbidden": "\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }", "computeCFG": "\n  ControlFlowGraph<Node> computeCFG() {\n    logger.info(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }", "normalize": "\n  public void normalize() {\n    logger.info(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }", "prepareAst": "\n  void prepareAst(Node root) {\n    Tracer tracer = newTracer(\"prepareAst\");\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"prepareAst\");\n  }", "recordFunctionInformation": "\n  void recordFunctionInformation() {\n    logger.info(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }", "addChangeHandler": "\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }", "removeChangeHandler": "\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }", "reportCodeChange": "\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }", "getCodingConvention": "\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }", "isIdeMode": "\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }", "acceptEcmaScript5": "\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }", "languageMode": "\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }", "acceptConstKeyword": "\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }", "getParserConfig": "\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword());\n    }\n    return parserConfig;\n  }", "isTypeCheckingEnabled": "\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }", "getDiagnosticGroups": "\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }", "report": "\n  public void report(JSError error) {\n    CheckLevel level = error.level;\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      errorManager.report(level, error);\n    }\n  }", "getErrorLevel": "\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }", "throwInternalError": "\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }", "getErrorCount": "\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }", "getWarningCount": "\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }", "hasHaltingErrors": "\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }", "hasErrors": "\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }", "addToDebugLog": "\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }", "getSourceFileByName": "\n  private SourceFile getSourceFileByName(String sourceName) {\n    if (inputsByName.containsKey(sourceName)) {\n      return inputsByName.get(sourceName).getSourceFile();\n    }\n    return null;\n  }", "getSourceLine": "\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }", "getSourceRegion": "\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }", "getNodeForCodeInsertion": "\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }", "getSourceMap": "\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }", "getVariableMap": "\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }", "getPropertyMap": "\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }", "getOptions": "\n  CompilerOptions getOptions() {\n    return options;\n  }", "getFunctionalInformationMap": "\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }", "setLoggingLevel": "\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }", "getAstDotGraph": "\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }", "getErrorManager": "\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(new CompilerOptions());\n    }\n    return errorManager;\n  }", "getInputsInOrder": "\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }", "getState": "\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n\n    return state;\n  }", "setState": "\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n  }", "getInputsForTesting": "\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }", "getExternsForTesting": "\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }", "hasRegExpGlobalReferences": "\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }", "setHasRegExpGlobalReferences": "\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }", "updateGlobalVarReferences": "\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT\n        || collectionRoot.getType() == Token.BLOCK);\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }", "getGlobalVarReferences": "\n  ReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }"}