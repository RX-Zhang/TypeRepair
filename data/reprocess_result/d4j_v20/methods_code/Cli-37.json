{"parse": "\n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }", "handleProperties": "\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }", "checkRequiredOptions": "\n    private void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }", "checkRequiredArgs": "\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }", "handleToken": "\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }", "isArgument": "\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }", "isNegativeNumber": "\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }", "isOption": "\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }", "isShortOption": "\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n        // remove leading \"-\" and \"=value\"\n    }", "isLongOption": "\n    private boolean isLongOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }", "handleUnknownToken": "\n    private void handleUnknownToken(String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }", "handleLongOption": "\n    private void handleLongOption(String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }", "handleLongOptionWithoutEqual": "\n    private void handleLongOptionWithoutEqual(String token) throws ParseException\n    {\n        List<String> matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption(matchingOpts.get(0)));\n        }\n    }", "handleLongOptionWithEqual": "\n    private void handleLongOptionWithEqual(String token) throws ParseException\n    {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n\n        String opt = token.substring(0, pos);\n\n        List<String> matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption(matchingOpts.get(0));\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }", "handleShortAndLongOption": "\n    private void handleShortAndLongOption(String token) throws ParseException\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            // equal sign found (-xxx=yyy)\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                // -S=V\n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }", "getLongPrefix": "\n    private String getLongPrefix(String token)\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }", "isJavaProperty": "\n    private boolean isJavaProperty(String token)\n    {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }", "handleOption": "\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }", "updateRequiredOptions": "\n    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }", "handleConcatenatedOptions": "\n    protected void handleConcatenatedOptions(String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }"}