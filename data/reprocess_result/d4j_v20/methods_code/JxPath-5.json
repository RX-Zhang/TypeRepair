{"newNodePointer": "\n    public static NodePointer newNodePointer(\n        QName name,\n        Object bean,\n        Locale locale) \n    {\n        NodePointer pointer = null;\n        if (bean == null) {\n            pointer = new NullPointer(name, locale);\n            return pointer;\n        }\n        \n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            pointer = factories[i].createNodePointer(name, bean, locale);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }", "newChildNodePointer": "\n    public static NodePointer newChildNodePointer(\n        NodePointer parent,\n        QName name,\n        Object bean) \n    {\n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            NodePointer pointer =\n                factories[i].createNodePointer(parent, name, bean);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }", "getNamespaceResolver": "\n    public NamespaceResolver getNamespaceResolver() {\n        if (namespaceResolver == null && parent != null) {\n            namespaceResolver = parent.getNamespaceResolver();\n        }\n        return namespaceResolver;\n    }", "setNamespaceResolver": "\n    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n        this.namespaceResolver = namespaceResolver;\n    }", "getParent": "\n    public NodePointer getParent() {\n        NodePointer pointer = parent;\n        while (pointer != null && pointer.isContainer()) {\n            pointer = pointer.getImmediateParentPointer();\n        }\n        return pointer;\n    }", "getImmediateParentPointer": "\n    public NodePointer getImmediateParentPointer() {\n        return parent;\n    }", "setAttribute": "\n    public void setAttribute(boolean attribute) {\n        this.attribute = attribute;\n    }", "isAttribute": "\n    public boolean isAttribute() {\n        return attribute;\n    }", "isRoot": "\n    public boolean isRoot() {\n        return parent == null;\n    }", "isLeaf": "\n    public abstract boolean isLeaf();\n\n    /**\n     * @deprecated Please use !isContainer()\n     */\n    public boolean isNode() {\n        return !isContainer();\n    }", "isNode": "\n    public boolean isNode() {\n        return !isContainer();\n    }", "isContainer": "\n    public boolean isContainer() {\n        return false;\n    }", "getIndex": "\n    public int getIndex() {\n        return index;\n    }", "setIndex": "\n    public void setIndex(int index) {\n        this.index = index;\n    }", "isCollection": "\n    public abstract boolean isCollection();\n\n    /**\n     * If the pointer represents a collection (or collection element),\n     * returns the length of the collection.\n     * Otherwise returns 1 (even if the value is null).\n     */\n    public abstract int getLength();\n\n    /**\n     * By default, returns <code>getNode()</code>, can be overridden to\n     * return a \"canonical\" value, like for instance a DOM element should\n     * return its string value.\n     */\n    public Object getValue() {\n        NodePointer valuePointer = getValuePointer();\n        if (valuePointer != this) {\n            return valuePointer.getValue();\n        }\n        // Default behavior is to return the same as getNode() \n        return getNode();\n    }", "getLength": "\n    public abstract int getLength();\n\n    /**\n     * By default, returns <code>getNode()</code>, can be overridden to\n     * return a \"canonical\" value, like for instance a DOM element should\n     * return its string value.\n     */\n    public Object getValue() {\n        NodePointer valuePointer = getValuePointer();\n        if (valuePointer != this) {\n            return valuePointer.getValue();\n        }\n        // Default behavior is to return the same as getNode() \n        return getNode();\n    }", "getValue": "\n    public Object getValue() {\n        NodePointer valuePointer = getValuePointer();\n        if (valuePointer != this) {\n            return valuePointer.getValue();\n        }\n        // Default behavior is to return the same as getNode() \n        return getNode();\n    }", "getValuePointer": "\n    public NodePointer getValuePointer() {\n        NodePointer ivp = getImmediateValuePointer();\n        return ivp == this ? this : ivp.getValuePointer();\n    }", "getImmediateValuePointer": "\n    public NodePointer getImmediateValuePointer() {\n        return this;\n    }", "isActual": "\n    public boolean isActual() {\n        return index == WHOLE_COLLECTION || index >= 0 && index < getLength();\n    }", "getName": "\n    public abstract QName getName();\n\n    /**\n     * Returns the value represented by the pointer before indexing.\n     * So, if the node represents an element of a collection, this\n     * method returns the collection itself.\n     */\n    public abstract Object getBaseValue();\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     *\n     * @deprecated 1.1 Please use getNode()\n     */\n    public Object getNodeValue() {\n        return getNode();\n    }", "getBaseValue": "\n    public abstract Object getBaseValue();\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     *\n     * @deprecated 1.1 Please use getNode()\n     */\n    public Object getNodeValue() {\n        return getNode();\n    }", "getNodeValue": "\n    public Object getNodeValue() {\n        return getNode();\n    }", "getNode": "\n    public Object getNode() {\n        return getValuePointer().getImmediateNode();\n    }", "getRootNode": "\n    public Object getRootNode() {\n        if (rootNode == null) {\n            rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n        }\n        return rootNode;\n    }", "getImmediateNode": "\n    public abstract Object getImmediateNode();\n\n    /**\n     * Converts the value to the required type and changes the corresponding\n     * object to that value.\n     */\n    public abstract void setValue(Object value);\n\n    /**\n     * Compares two child NodePointers and returns a positive number,\n     * zero or a positive number according to the order of the pointers.\n     */\n    public abstract int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2);\n\n    /**\n     * Checks if this Pointer matches the supplied NodeTest.\n     */\n    public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }", "setValue": "\n    public abstract void setValue(Object value);\n\n    /**\n     * Compares two child NodePointers and returns a positive number,\n     * zero or a positive number according to the order of the pointers.\n     */\n    public abstract int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2);\n\n    /**\n     * Checks if this Pointer matches the supplied NodeTest.\n     */\n    public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }", "compareChildNodePointers": "\n    public abstract int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2);\n\n    /**\n     * Checks if this Pointer matches the supplied NodeTest.\n     */\n    public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }", "testNode": "\n    public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }", "equalStrings": "\n    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }", "createPath": "\n    public NodePointer createPath(JXPathContext context, Object value) {\n        setValue(value);\n        return this;\n    }", "remove": "\n    public void remove() {\n        // It is a no-op\n\n//        System.err.println(\"REMOVING: \" + asPath() + \" \" + getClass());\n//        printPointerChain();\n    }", "createChild": "\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index,\n        Object value) \n    {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }", "createAttribute": "\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n        throw new JXPathException(\"Cannot create an attribute for path \"\n                + asPath() + \"/@\" + name\n                + \", operation is not allowed for this type of node\");\n    }", "getLocale": "\n    public Locale getLocale() {\n        if (locale == null) {\n            if (parent != null) {\n                locale = parent.getLocale();\n            }\n        }\n        return locale;\n    }", "isLanguage": "\n    public boolean isLanguage(String lang) {\n        Locale loc = getLocale();\n        String name = loc.toString().replace('_', '-');\n        return name.toUpperCase().startsWith(lang.toUpperCase());\n    }", "childIterator": "\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.childIterator(test, reverse, startWith);\n    }", "attributeIterator": "\n    public NodeIterator attributeIterator(QName qname) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.attributeIterator(qname);\n    }", "namespaceIterator": "\n    public NodeIterator namespaceIterator() {\n        return null;\n    }", "namespacePointer": "\n    public NodePointer namespacePointer(String namespace) {\n        return null;\n    }", "getNamespaceURI": "\n    public String getNamespaceURI(String prefix) {\n        return null;\n    }", "isDefaultNamespace": "\n    protected boolean isDefaultNamespace(String prefix) {\n        if (prefix == null) {\n            return true;\n        }\n\n        String namespace = getNamespaceURI(prefix);\n        return namespace != null && namespace.equals(getDefaultNamespaceURI());\n    }", "getDefaultNamespaceURI": "\n    protected String getDefaultNamespaceURI() {\n        return null;\n    }", "getPointerByID": "\n    public Pointer getPointerByID(JXPathContext context, String id) {\n        return context.getPointerByID(id);\n    }", "getPointerByKey": "\n    public Pointer getPointerByKey(\n        JXPathContext context,\n        String key,\n        String value) \n    {\n        return context.getPointerByKey(key, value);\n    }", "asPath": "\n    public String asPath() {\n        // If the parent of this node is a container, it is responsible\n        // for appended this node's part of the path.\n        if (parent != null && parent.isContainer()) {\n            return parent.asPath();\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n\n        if (buffer.length() == 0\n            || buffer.charAt(buffer.length() - 1) != '/') {\n            buffer.append('/');\n        }\n        if (attribute) {\n            buffer.append('@');\n        }\n        buffer.append(getName());\n\n        if (index != WHOLE_COLLECTION && isCollection()) {\n            buffer.append('[').append(index + 1).append(']');\n        }\n        return buffer.toString();\n    }", "clone": "\n    public Object clone() {\n        try {\n            NodePointer ptr = (NodePointer) super.clone();\n            if (parent != null) {\n                ptr.parent = (NodePointer) parent.clone();\n            }\n            return ptr;\n        }\n        catch (CloneNotSupportedException ex) {\n            // Of course it is supported\n            ex.printStackTrace();\n        }\n        return null;\n    }", "toString": "\n    public String toString() {\n        return asPath();\n    }", "compareTo": "\n    public int compareTo(Object object) {\n        // Let it throw a ClassCastException\n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        // Task 1: find the common parent\n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }", "compareNodePointers": "\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }", "printPointerChain": "\n    public void printPointerChain() {\n        printDeep(this, \"\");\n    }", "printDeep": "\n    private static void printDeep(NodePointer pointer, String indent) {\n        if (indent.length() == 0) {\n            System.err.println(\n                \"POINTER: \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        else {\n            System.err.println(\n                indent\n                    + \" of \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        if (pointer.getImmediateParentPointer() != null) {\n            printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n        }\n    }"}