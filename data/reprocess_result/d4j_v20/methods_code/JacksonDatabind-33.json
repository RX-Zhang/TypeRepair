{"version": "\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "isAnnotationBundle": "\n    public boolean isAnnotationBundle(Annotation ann) {\n        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n    }", "findEnumValue": "\n    public String findEnumValue(Enum<?> value)\n    {\n        // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming.\n        //   Unfortunately can not quite use standard AnnotatedClass here (due to various\n        //   reasons, including odd representation JVM uses); has to do for now\n        try {\n            // We know that values are actually static fields with matching name so:\n            Field f = value.getClass().getField(value.name());\n            if (f != null) {\n                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n                if (prop != null) {\n                    String n = prop.value();\n                    if (n != null && !n.isEmpty()) {\n                        return n;\n                    }\n                }\n            }\n        } catch (SecurityException e) {\n            // 17-Sep-2015, tatu: Anything we could/should do here?\n        } catch (NoSuchFieldException e) {\n            // 17-Sep-2015, tatu: should not really happen. But... can we do anything?\n        }\n        return value.name();\n    }", "findRootName": "\n    public PropertyName findRootName(AnnotatedClass ac)\n    {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }", "findPropertiesToIgnore": "\n    public String[] findPropertiesToIgnore(Annotated ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.value();\n    }", "findIgnoreUnknownProperties": "\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n        return (ignore == null) ? null : ignore.ignoreUnknown();\n    }", "isIgnorableType": "\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }", "findFilterId": "\n    public Object findFilterId(AnnotatedClass ac) {\n        return _findFilterId(ac);\n    }", "_findFilterId": "\n    protected final Object _findFilterId(Annotated a)\n    {\n        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n        if (ann != null) {\n            String id = ann.value();\n            // Empty String is same as not having annotation, to allow overrides\n            if (id.length() > 0) {\n                return id;\n            }\n        }\n        return null;\n    }", "findNamingStrategy": "\n    public Object findNamingStrategy(AnnotatedClass ac)\n    {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    } ", "findAutoDetectVisibility": "\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n        VisibilityChecker<?> checker)\n    {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }", "findImplicitPropertyName": "\n    public String findImplicitPropertyName(AnnotatedMember param) {\n        // not known by default (until JDK8) for creators; default \n        //\n        return null;\n    }", "hasIgnoreMarker": "\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }", "hasRequiredMarker": "\n    public Boolean hasRequiredMarker(AnnotatedMember m)\n    {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }", "findPropertyAccess": "\n    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }", "findPropertyDescription": "\n    public String findPropertyDescription(Annotated ann) {\n        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n        return (desc == null) ? null : desc.value();\n    }", "findPropertyIndex": "\n    public Integer findPropertyIndex(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop != null) {\n          int ix = prop.index();\n          if (ix != JsonProperty.INDEX_UNKNOWN) {\n               return Integer.valueOf(ix);\n          }\n        }\n        return null;\n    }", "findPropertyDefaultValue": "\n    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        // Since annotations do not allow nulls, need to assume empty means \"none\"\n        return str.isEmpty() ? null : str;\n    }", "findFormat": "\n    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }", "findReferenceType": "\n    public ReferenceProperty findReferenceType(AnnotatedMember member)\n    {\n        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n        if (ref1 != null) {\n            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n        }\n        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n        if (ref2 != null) {\n            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n        }\n        return null;\n    }", "findUnwrappingNameTransformer": "\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n    {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        // if not enabled, just means annotation is not enabled; not necessarily\n        // that unwrapping should not be done (relevant when using chained introspectors)\n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }", "findInjectableValueId": "\n    public Object findInjectableValueId(AnnotatedMember m)\n    {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        /* Empty String means that we should use name of declared\n         * value class.\n         */\n        String id = ann.value();\n        if (id.length() == 0) {\n            // slight complication; for setters, type \n            if (!(m instanceof AnnotatedMethod)) {\n                return m.getRawType().getName();\n            }\n            AnnotatedMethod am = (AnnotatedMethod) m;\n            if (am.getParameterCount() == 0) {\n                return m.getRawType().getName();\n            }\n            return am.getRawParameterType(0).getName();\n        }\n        return id;\n    }", "findViews": "\n    public Class<?>[] findViews(Annotated a)\n    {\n        JsonView ann = _findAnnotation(a, JsonView.class);\n        return (ann == null) ? null : ann.value();\n    }", "findTypeResolver": "\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType)\n    {\n        return _findTypeResolver(config, ac, baseType);\n    }", "findPropertyTypeResolver": "\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType)\n    {\n        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n         * (collection, map) types, not container types themselves:\n         */\n        if (baseType.isContainerType()) return null;\n        // No per-member type overrides (yet)\n        return _findTypeResolver(config, am, baseType);\n    }", "findPropertyContentTypeResolver": "\n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType)\n    {\n        /* First: let's ensure property is a container type: caller should have\n         * verified but just to be sure\n         */\n        if (!containerType.isContainerType()) {\n            throw new IllegalArgumentException(\"Must call method with a container type (got \"+containerType+\")\");\n        }\n        return _findTypeResolver(config, am, containerType);\n    }", "findSubtypes": "\n    public List<NamedType> findSubtypes(Annotated a)\n    {\n        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n        if (t == null) return null;\n        JsonSubTypes.Type[] types = t.value();\n        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n        for (JsonSubTypes.Type type : types) {\n            result.add(new NamedType(type.value(), type.name()));\n        }\n        return result;\n    }", "findTypeName": "\n    public String findTypeName(AnnotatedClass ac)\n    {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }", "isTypeId": "\n    public Boolean isTypeId(AnnotatedMember member) {\n        return _hasAnnotation(member, JsonTypeId.class);\n    }", "findObjectIdInfo": "\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n        if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n            return null;\n        }\n        // In future may need to allow passing namespace?\n        PropertyName name = PropertyName.construct(info.property());\n        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n    }", "findObjectReferenceInfo": "\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n        if (ref != null) {\n            objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n        }\n        return objectIdInfo;\n    }", "findSerializer": "\n    public Object findSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        /* 18-Oct-2010, tatu: [JACKSON-351] @JsonRawValue handled just here, for now;\n         *  if we need to get raw indicator from other sources need to add\n         *  separate accessor within {@link AnnotationIntrospector} interface.\n         */\n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            // let's construct instance with nominal type:\n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }", "findKeySerializer": "\n    public Object findKeySerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }", "findContentSerializer": "\n    public Object findContentSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }", "findNullSerializer": "\n    public Object findNullSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }", "findSerializationInclusion": "\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include v = inc.value();\n            if (v != JsonInclude.Include.USE_DEFAULTS) {\n                return v;\n            }\n        }\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            JsonSerialize.Inclusion i2 = ann.include();\n            switch (i2) {\n            case ALWAYS:\n                return JsonInclude.Include.ALWAYS;\n            case NON_NULL:\n                return JsonInclude.Include.NON_NULL;\n            case NON_DEFAULT:\n                return JsonInclude.Include.NON_DEFAULT;\n            case NON_EMPTY:\n                return JsonInclude.Include.NON_EMPTY;\n            case DEFAULT_INCLUSION: // since 2.3 -- fall through, use default\n                break;\n            }\n        }\n        return defValue;\n    }", "findSerializationInclusionForContent": "\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include incl = inc.content();\n            if (incl != JsonInclude.Include.USE_DEFAULTS) {\n                return incl;\n            }\n        }\n        return defValue;\n    }", "findPropertyInclusion": "\n    public JsonInclude.Value findPropertyInclusion(Annotated a)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        JsonInclude.Include valueIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.value();\n        if (valueIncl == JsonInclude.Include.USE_DEFAULTS) {\n            JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n            if (ann != null) {\n                JsonSerialize.Inclusion i2 = ann.include();\n                switch (i2) {\n                case ALWAYS:\n                    valueIncl = JsonInclude.Include.ALWAYS;\n                    break;\n                case NON_NULL:\n                    valueIncl = JsonInclude.Include.NON_NULL;\n                    break;\n                case NON_DEFAULT:\n                    valueIncl = JsonInclude.Include.NON_DEFAULT;\n                    break;\n                case NON_EMPTY:\n                    valueIncl = JsonInclude.Include.NON_EMPTY;\n                    break;\n                case DEFAULT_INCLUSION:\n                default:\n                }\n            }\n        }\n        JsonInclude.Include contentIncl = (inc == null) ? JsonInclude.Include.USE_DEFAULTS : inc.content();\n        return JsonInclude.Value.construct(valueIncl, contentIncl);\n    }", "findSerializationType": "\n    public Class<?> findSerializationType(Annotated am)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }", "findSerializationKeyType": "\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }", "findSerializationContentType": "\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }", "findSerializationTyping": "\n    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }", "findSerializationConverter": "\n    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }", "findSerializationContentConverter": "\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }", "findSerializationPropertyOrder": "\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }", "findSerializationSortAlphabetically": "\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }", "_findSortAlpha": "\n    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        /* 23-Jun-2015, tatu: as per [databind#840], let's only consider\n         *  `true` to have any significance.\n         */\n        if ((order != null) && order.alphabetic()) {\n            return Boolean.TRUE;\n        }\n        return null;\n    }", "findAndAddVirtualProperties": "\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        // First: any attribute-backed properties?\n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        // Then: general-purpose virtual properties?\n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }", "_constructVirtualProperty": "\n    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n    {\n        PropertyMetadata metadata = attr.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        // could add Index, Description in future, if those matter\n        String attrName = attr.value();\n\n        // allow explicit renaming; if none, default to attribute name\n        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n        if (!propName.hasSimpleName()) {\n            propName = PropertyName.construct(attrName);\n        }\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                attrName, type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, attr.include());\n        // can construct the property writer\n        return AttributePropertyWriter.construct(attrName, propDef,\n                ac.getAnnotations(), type);\n    }", "findNameForSerialization": "\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }", "hasAsValueAnnotation": "\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        // value of 'false' means disabled...\n        return (ann != null && ann.value());\n    }", "findDeserializer": "\n    public Object findDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }", "findKeyDeserializer": "\n    public Object findKeyDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }", "findContentDeserializer": "\n    public Object findContentDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }", "findDeserializationType": "\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }", "findDeserializationKeyType": "\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }", "findDeserializationContentType": "\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n    {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }", "findDeserializationConverter": "\n    public Object findDeserializationConverter(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }", "findDeserializationContentConverter": "\n    public Object findDeserializationContentConverter(AnnotatedMember a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }", "findValueInstantiator": "\n    public Object findValueInstantiator(AnnotatedClass ac)\n    {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        // no 'null' marker yet, so:\n        return (ann == null) ? null : ann.value();\n    }", "findPOJOBuilder": "\n    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n    {\n        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.builder());\n    }", "findPOJOBuilderConfig": "\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n    {\n        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n    }", "findNameForDeserialization": "\n    public PropertyName findNameForDeserialization(Annotated a)\n    {\n        String name;\n\n        // @JsonSetter has precedence over @JsonProperty, being more specific\n        // @JsonDeserialize implies that there is a property, but no name\n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            name = js.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonDeserialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                    name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }", "hasAnySetterAnnotation": "\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }", "hasAnyGetterAnnotation": "\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (handled separately\n         */\n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }", "hasCreatorAnnotation": "\n    public boolean hasCreatorAnnotation(Annotated a)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);\n    }", "findCreatorBinding": "\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }", "_isIgnorable": "\n    protected boolean _isIgnorable(Annotated a)\n    {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        return (ann != null && ann.value());\n    }", "_classIfExplicit": "\n    protected Class<?> _classIfExplicit(Class<?> cls) {\n        if (cls == null || ClassUtil.isBogusClass(cls)) {\n            return null;\n        }\n        return cls;\n    }", "_propertyName": "\n    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }", "_findTypeResolver": "\n    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n            Annotated ann, JavaType baseType)\n    {\n        // First: maybe we have explicit type resolver?\n        TypeResolverBuilder<?> b;\n        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n        \n        if (resAnn != null) {\n            if (info == null) {\n                return null;\n            }\n            /* let's not try to force access override (would need to pass\n             * settings through if we did, since that's not doable on some\n             * platforms)\n             */\n            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n        } else { // if not, use standard one, if indicated by annotations\n            if (info == null) {\n                return null;\n            }\n            // bit special; must return 'marker' to block use of default typing:\n            if (info.use() == JsonTypeInfo.Id.NONE) {\n                return _constructNoTypeResolverBuilder();\n            }\n            b = _constructStdTypeResolverBuilder();\n        }\n        // Does it define a custom type id resolver?\n        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n        TypeIdResolver idRes = (idResInfo == null) ? null\n                : config.typeIdResolverInstance(ann, idResInfo.value());\n        if (idRes != null) { // [JACKSON-359]\n            idRes.init(baseType);\n        }\n        b = b.init(info.use(), idRes);\n        /* 13-Aug-2011, tatu: One complication wrt [JACKSON-453]; external id\n         *   only works for properties; so if declared for a Class, we will need\n         *   to map it to \"PROPERTY\" instead of \"EXTERNAL_PROPERTY\"\n         */\n        JsonTypeInfo.As inclusion = info.include();\n        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n            inclusion = JsonTypeInfo.As.PROPERTY;\n        }\n        b = b.inclusion(inclusion);\n        b = b.typeProperty(info.property());\n        Class<?> defaultImpl = info.defaultImpl();\n\n        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n        //   valid use (can not instantiate as default)\n        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n            b = b.defaultImpl(defaultImpl);\n        }\n        b = b.typeIdVisibility(info.visible());\n        return b;\n    }", "_constructStdTypeResolverBuilder": "\n    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }", "_constructNoTypeResolverBuilder": "\n    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }"}