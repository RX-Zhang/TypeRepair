{"version": "\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "_new": "\n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n        return new ObjectReader(base, f);\n    }", "_newIterator": "\n    protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt,\n            JsonDeserializer<?> deser, boolean parserManaged)\n    {\n        return new MappingIterator<T>(_valueType, p, ctxt,\n                deser, parserManaged, _valueToUpdate);\n    }", "_initForReading": "\n    protected JsonToken _initForReading(JsonParser p) throws IOException\n    {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = p.getCurrentToken();\n        if (t == null) { // and then we must get something...\n            t = p.nextToken();\n            if (t == null) {\n                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }", "_initForMultiRead": "\n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n    }", "with": "\n    public ObjectReader with(DeserializationFeature feature) {\n        return _with(_config.with(feature));\n    }", "withFeatures": "\n    public ObjectReader withFeatures(DeserializationFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    ", "without": "\n    public ObjectReader without(DeserializationFeature feature) {\n        return _with(_config.without(feature)); \n    }", "withoutFeatures": "\n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }    ", "withRootName": "\n    public ObjectReader withRootName(String rootName) {\n        return _with(_config.withRootName(rootName));\n    }", "withoutRootName": "\n    public ObjectReader withoutRootName() {\n        return _with(_config.withRootName(PropertyName.NO_NAME));\n    }", "forType": "\n    public ObjectReader forType(JavaType valueType)\n    {\n        if (valueType != null && valueType.equals(_valueType)) {\n            return this;\n        }\n        JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(valueType);\n        // type is stored here, no need to make a copy of config\n        DataFormatReaders det = _dataFormatReaders;\n        if (det != null) {\n            det = det.withType(valueType);\n        }\n        return _new(this, _config, valueType, rootDeser,\n                _valueToUpdate, _schema, _injectableValues, det);\n    }    ", "withType": "\n    public ObjectReader withType(JavaType valueType) {\n        return forType(valueType);\n    }", "withValueToUpdate": "\n    public ObjectReader withValueToUpdate(Object value)\n    {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        /* no real benefit from pre-fetching, as updating readers are much\n         * less likely to be reused, and value type may also be forced\n         * with a later chained call...\n         */\n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }", "withView": "\n    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }", "withHandler": "\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }", "withFormatDetection": "\n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n        return withFormatDetection(new DataFormatReaders(readers));\n    }", "withAttributes": "\n    public ObjectReader withAttributes(Map<?,?> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }", "withAttribute": "\n    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }", "withoutAttribute": "\n    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }", "_with": "\n    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }", "isEnabled": "\n    public boolean isEnabled(DeserializationFeature f) {\n        return _config.isEnabled(f);\n    }", "getConfig": "\n    public DeserializationConfig getConfig() {\n        return _config;\n    }", "getFactory": "\n    public JsonFactory getFactory() {\n        return _parserFactory;\n    }", "getTypeFactory": "\n    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }", "getAttributes": "\n    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }", "getInjectableValues": "\n    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }", "readValue": "\n    public <T> T readValue(JsonParser p) throws IOException\n    {\n        return (T) _bind(p, _valueToUpdate);\n    }", "readValues": "\n    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException {\n        return forType(valueType).readValues(p);\n    }", "createArrayNode": "\n    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }", "createObjectNode": "\n    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }", "treeAsTokens": "\n    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }", "readTree": "\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n        return (T) _bindAsTree(p);\n    }", "writeTree": "\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }", "treeToValue": "\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n    {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    ", "writeValue": "\n    public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }", "_bind": "\n    protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException\n    {\n        /* First: may need to read the next token, to initialize state (either\n         * before first read from parser, or after previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                result = _findRootDeserializer(ctxt).getNullValue(ctxt);\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(p, ctxt);\n                } else {\n                    deser.deserialize(p, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        // Need to consume the token too\n        p.clearCurrentToken();\n        return result;\n    }", "_considerFilter": "\n    protected JsonParser _considerFilter(final JsonParser p, boolean multiValue) {\n        // 26-Mar-2016, tatu: Need to allow multiple-matches at least if we have\n        //    have a multiple-value read (that is, \"readValues()\").\n        return ((_filter == null) || FilteringParserDelegate.class.isInstance(p))\n                ? p : new FilteringParserDelegate(p, _filter, false, multiValue);\n    }", "_bindAndClose": "\n    protected Object _bindAndClose(JsonParser p) throws IOException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n                if (_valueToUpdate == null) {\n                    DeserializationContext ctxt = createDeserializationContext(p);\n                    result = _findRootDeserializer(ctxt).getNullValue(ctxt);\n                } else {\n                    result = _valueToUpdate;\n                }\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = _valueToUpdate;\n            } else {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n                if (_unwrapRoot) {\n                    result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);\n                } else {\n                    if (_valueToUpdate == null) {\n                        result = deser.deserialize(p, ctxt);\n                    } else {\n                        deser.deserialize(p, ctxt, _valueToUpdate);\n                        result = _valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) { }\n        }\n    }", "_bindAndCloseAsTree": "\n    protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException {\n        try {\n            return _bindAsTree(p);\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) { }\n        }\n    }", "_bindAsTree": "\n    protected JsonNode _bindAsTree(JsonParser p) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(p, ctxt);\n            }\n        }\n        // Need to consume the token too\n        p.clearCurrentToken();\n        return result;\n    }", "_bindAndReadValues": "\n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException\n    {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }", "_unwrapAndDeserialize": "\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt,\n            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n    {\n        PropertyName expRootName = _config.findRootName(rootType);\n        // 12-Jun-2015, tatu: Should try to support namespaces etc but...\n        String expSimpleName = expRootName.getSimpleName();\n\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        p.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n            result = deser.deserialize(p, ctxt);\n        } else {\n            deser.deserialize(p, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        // and last, verify that we now get matching END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }", "_detectBindAndClose": "\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(p);\n    }", "_detectBindAndReadValues": "\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException, JsonProcessingException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndReadValues(p);\n    }", "_detectBindAndCloseAsTree": "\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }", "_reportUnkownFormat": "\n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException\n    {\n        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:\n        throw new JsonParseException(null, \"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString());\n    }", "_verifySchemaType": "\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }", "createDeserializationContext": "\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser p) {\n        return _context.createInstance(_config, p, _injectableValues);\n    }", "_reportUndetectableSource": "\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n    {\n        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:\n        throw new JsonParseException(null, \"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\");\n    }", "_inputStream": "\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }", "_findRootDeserializer": "\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        // Sanity check: must have actual type...\n        JavaType t = _valueType;\n        if (t == null) {\n            throw JsonMappingException.from(ctxt, \"No value type configured for ObjectReader\");\n        }\n        \n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(t);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(t);\n        if (deser == null) { // can this happen?\n            throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type \"+t);\n        }\n        _rootDeserializers.put(t, deser);\n        return deser;\n    }", "_findTreeDeserializer": "\n    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n        if (deser == null) {\n            // Nope: need to ask provider to resolve it\n            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n            if (deser == null) { // can this happen?\n                throw JsonMappingException.from(ctxt,\n                        \"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n            }\n            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n        }\n        return deser;\n    }", "_prefetchRootDeserializer": "\n    protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType)\n    {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        // already cached?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                // If not, need to resolve; for which we need a temporary context as well:\n                DeserializationContext ctxt = createDeserializationContext(null);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n            } catch (JsonProcessingException e) {\n                // need to swallow?\n            }\n        }\n        return deser;\n    }", "at": "\n    public ObjectReader at(final String value) {\n        return new ObjectReader(this, new JsonPointerBasedFilter(value));\n    }"}