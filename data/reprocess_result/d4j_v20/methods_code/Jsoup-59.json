{"tokenType": "\n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }", "reset": "\n    abstract Token reset();\n\n    static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }", "getName": "\n        String getName() {\n            return name.toString();\n        }", "getPubSysKey": "\n        String getPubSysKey() {\n            return pubSysKey;\n        }", "getPublicIdentifier": "\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }", "getSystemIdentifier": "\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }", "isForceQuirks": "\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }", "newAttribute": "\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                    Attribute attribute;\n                    if (hasPendingAttributeValue)\n                        attribute = new Attribute(pendingAttributeName,\n                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                    else if (hasEmptyAttributeValue)\n                        attribute = new Attribute(pendingAttributeName, \"\");\n                    else\n                        attribute = new BooleanAttribute(pendingAttributeName);\n                    attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }", "finaliseTag": "\n        final void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }", "name": "\n        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }", "normalName": "\n        final String normalName() { // loses case, used in tree building for working out where in tree it should go\n            return normalName;\n        }", "isSelfClosing": "\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }", "getAttributes": "\n        final Attributes getAttributes() {\n            return attributes;\n        }", "appendTagName": "\n        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = tagName.toLowerCase();\n        }", "appendAttributeName": "\n        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }", "appendAttributeValue": "\n        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }", "setEmptyAttributeValue": "\n        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }", "ensureAttributeValue": "\n        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }", "nameAttr": "\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = tagName.toLowerCase();\n            return this;\n        }", "toString": "\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }", "getData": "\n        String getData() {\n            return data.toString();\n        }", "data": "\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }", "isDoctype": "\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }", "asDoctype": "\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }", "isStartTag": "\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }", "asStartTag": "\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }", "isEndTag": "\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }", "asEndTag": "\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }", "isComment": "\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }", "asComment": "\n    final Comment asComment() {\n        return (Comment) this;\n    }", "isCharacter": "\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }", "asCharacter": "\n    final Character asCharacter() {\n        return (Character) this;\n    }", "isEOF": "\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }"}