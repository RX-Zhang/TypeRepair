{"parseOctal": "\n    public static long parseOctal(byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) { // Found trailing null\n                break;\n            }\n\n            // Ignore leading spaces ('0' can be ignored anyway)\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                    continue;\n                }\n\n                if (currentByte == (byte) ' ') { // Found trailing space\n                    break;\n                }\n            }\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        \"Invalid octal digit at position \"+i+\" in '\"+new String(buffer, offset, length)+\"'\");\n            }\n            result = (result << 3) + (currentByte - '0');// TODO needs to reject invalid bytes\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }", "parseName": "\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) buffer[i]);\n        }\n\n        return result.toString();\n    }", "formatNameBytes": "\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        // copy until end of input or output is reached.\n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        // Pad any remaining output bytes with NUL\n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }", "formatUnsignedOctalString": "\n    public static void formatUnsignedOctalString(final long value, byte[] buffer,\n            final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                // CheckStyle:MagicNumber OFF\n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                // CheckStyle:MagicNumber ON\n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { // leading zeros\n            buffer[offset + remaining] = (byte) '0';\n        }\n    }", "formatOctalBytes": "\n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // For space and trailing null\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; // Trailing space\n        buf[offset + idx]   = 0; // Trailing null\n\n        return offset + length;\n    }", "formatLongOctalBytes": "\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; // For space\n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }", "formatCheckSumOctalBytes": "\n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // for NUL and space\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; // Trailing null\n        buf[offset + idx]     = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }", "computeCheckSum": "\n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }"}