{"buildTypeDeserializer": "\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }", "buildTypeSerializer": "\n        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }", "useForType": "\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }", "copy": "\n    public ObjectMapper copy()\n    {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }", "_checkInvalidCopy": "\n    protected void _checkInvalidCopy(Class<?> exp)\n    {\n        if (getClass() != exp) {\n            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n        }\n    }", "version": "\n    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "registerModule": "\n    public ObjectMapper registerModule(Module module)\n    {\n        /* Let's ensure we have access to name and version information, \n         * even if we do not have immediate use for either. This way we know\n         * that they will be available from beginning\n         */\n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        // And then call registration\n        module.setupModule(new Module.SetupContext()\n        {\n            // // // Accessors\n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                // why do we need the cast here?!?\n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            // // // Methods for registering handlers: deserializers\n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            // // // Methods for registering handlers: serializers\n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            // // // Methods for registering handlers: other\n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixInAnnotations(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }", "registerModules": "\n    public ObjectMapper registerModules(Module... modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }", "findModules": "\n    public static List<Module> findModules() {\n        return findModules(null);\n    }", "findAndRegisterModules": "\n    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }", "getSerializationConfig": "\n    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }", "getDeserializationConfig": "\n    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }", "getDeserializationContext": "\n    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }", "setSerializerFactory": "\n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }", "getSerializerFactory": "\n    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }", "setSerializerProvider": "\n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }", "getSerializerProvider": "\n    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }", "setMixInAnnotations": "\n    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n    {\n        _mixInAnnotations.clear();\n        if (sourceMixins != null && sourceMixins.size() > 0) {\n            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n                _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n            }\n        }\n    }", "addMixInAnnotations": "\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n    {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n    }", "addMixIn": "\n    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n    {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n        return this;\n    }", "findMixInClassFor": "\n    public final Class<?> findMixInClassFor(Class<?> cls) {\n        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n    }", "mixInCount": "\n    public final int mixInCount() {\n        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n    }", "getVisibilityChecker": "\n    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }", "setVisibilityChecker": "\n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n    }", "setVisibility": "\n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n    {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }", "getSubtypeResolver": "\n    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }", "setSubtypeResolver": "\n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }", "setAnnotationIntrospector": "\n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }", "setAnnotationIntrospectors": "\n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n            AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }", "setPropertyNamingStrategy": "\n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }", "setSerializationInclusion": "\n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }", "enableDefaultTyping": "\n    public ObjectMapper enableDefaultTyping() {\n        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n    }", "enableDefaultTypingAsProperty": "\n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }", "disableDefaultTyping": "\n    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }", "setDefaultTyping": "\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }", "registerSubtypes": "\n    public void registerSubtypes(Class<?>... classes) {\n        getSubtypeResolver().registerSubtypes(classes);\n    }", "getTypeFactory": "\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }", "setTypeFactory": "\n    public ObjectMapper setTypeFactory(TypeFactory f)\n    {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }", "constructType": "\n    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }", "setNodeFactory": "\n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }", "addHandler": "\n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n        _deserializationConfig = _deserializationConfig.withHandler(h);\n        return this;\n    }", "clearProblemHandlers": "\n    public ObjectMapper clearProblemHandlers() {\n        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n        return this;\n    }", "setConfig": "\n    public ObjectMapper setConfig(DeserializationConfig config) {\n    \t_deserializationConfig = config;\n    \treturn this;\n    }", "setFilters": "\n    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }", "setBase64Variant": "\n    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }", "getFactory": "\n    public JsonFactory getFactory() { return _jsonFactory; }", "getJsonFactory": "\n    public JsonFactory getJsonFactory() { return getFactory(); }", "setDateFormat": "\n    public ObjectMapper setDateFormat(DateFormat dateFormat)\n    {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }", "setHandlerInstantiator": "\n    public Object setHandlerInstantiator(HandlerInstantiator hi)\n    {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }", "setInjectableValues": "\n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }", "setLocale": "\n    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }", "setTimeZone": "\n    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }", "configure": "\n    public ObjectMapper configure(MapperFeature f, boolean state) {\n        _serializationConfig = state ?\n                _serializationConfig.with(f) : _serializationConfig.without(f);\n        _deserializationConfig = state ?\n                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n        return this;\n    }", "enable": "\n    public ObjectMapper enable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }", "disable": "\n    public ObjectMapper disable(MapperFeature... f) {\n        _deserializationConfig = _deserializationConfig.without(f);\n        _serializationConfig = _serializationConfig.without(f);\n        return this;\n    }", "isEnabled": "\n    public boolean isEnabled(MapperFeature f) {\n        // ok to use either one, should be kept in sync\n        return _serializationConfig.isEnabled(f);\n    }", "getNodeFactory": "\n    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }", "readValue": "\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } ", "readTree": "\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        /* 02-Mar-2009, tatu: One twist; deserialization provider\n         *   will map JSON null straight into Java null. But what\n         *   we want to return is the \"null node\" instead.\n         */\n        /* 05-Aug-2011, tatu: Also, must check for EOF here before\n         *   calling readValue(), since that'll choke on it otherwise\n         */\n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            t = jp.nextToken();\n            if (t == null) {\n                return null;\n            }\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n            n = getNodeFactory().nullNode();\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }", "readValues": "\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, (JavaType) valueType);\n    }", "writeValue": "\n    public void writeValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(jgen, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(jgen, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n        }\n    }", "writeTree": "\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }", "createObjectNode": "\n    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }", "createArrayNode": "\n    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }", "treeAsTokens": "\n    public JsonParser treeAsTokens(TreeNode n)\n    {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }", "treeToValue": "\n    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n        throws JsonProcessingException\n    {\n        try {\n            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n            // ... one caveat; while everything is Object.class, let's not take shortcut\n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }", "valueToTree": "\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } ", "canSerialize": "\n    public boolean canSerialize(Class<?> type) {\n        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n    }", "canDeserialize": "\n    public boolean canDeserialize(JavaType type)\n    {\n        return createDeserializationContext(null,\n                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n    }", "writeValueAsString": "\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException\n    {        \n        // alas, we have to pull the recycler directly here...\n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }", "writeValueAsBytes": "\n    public byte[] writeValueAsBytes(Object value)\n        throws JsonProcessingException\n    {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }", "writer": "\n    public ObjectWriter writer() {\n        return new ObjectWriter(this, getSerializationConfig());\n    }", "writerWithView": "\n    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n    }", "writerWithType": "\n    public ObjectWriter writerWithType(Class<?> rootType) {\n        return new ObjectWriter(this, getSerializationConfig(),\n                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                /*PrettyPrinter*/null);\n    }", "writerWithDefaultPrettyPrinter": "\n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        return new ObjectWriter(this, getSerializationConfig(),\n                /*root type*/ null, _defaultPrettyPrinter());\n    }", "reader": "\n    public ObjectReader reader() {\n        return new ObjectReader(this, getDeserializationConfig())\n            .with(_injectableValues);\n    }", "readerForUpdating": "\n    public ObjectReader readerForUpdating(Object valueToUpdate)\n    {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }", "readerWithView": "\n    public ObjectReader readerWithView(Class<?> view) {\n        return new ObjectReader(this, getDeserializationConfig().withView(view));\n    }", "convertValue": "\n    public <T> T convertValue(Object fromValue, Class<T> toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } ", "_convert": "\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        /* Then use TokenBuffer, which is a JsonGenerator:\n         * (see [JACKSON-175])\n         */\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }", "generateJsonSchema": "\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)\n            throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }", "acceptJsonFormatVisitor": "\n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }", "_serializerProvider": "\n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n        return _serializerProvider.createInstance(config, _serializerFactory);\n    }", "_defaultPrettyPrinter": "\n    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }", "_configAndWriteValue": "\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig();\n        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            /* won't try to close twice; also, must catch exception (so it \n             * will not mask exception that is pending)\n             */\n            if (!closed) {\n                /* 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                 *    structures, which typically causes more damage.\n                 */\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }", "_configAndWriteCloseable": "\n    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            JsonGenerator tmpJgen = jgen;\n            jgen = null;\n            tmpJgen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            /* Need to close both generator and value, as long as they haven't yet\n             * been closed\n             */\n            if (jgen != null) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }", "_writeCloseableValue": "\n    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }", "createDeserializationContext": "\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg)\n    {\n        return _deserializationContext.createInstance(cfg,\n                jp, _injectableValues);\n    }", "_readValue": "\n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: may need to read the next token, to initialize\n         * state (either before first read from parser, or after\n         * previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            result = _findRootDeserializer(ctxt, valueType).getNullValue();\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            // ok, let's get the value\n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }", "_readMapAndClose": "\n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n                DeserializationContext ctxt = createDeserializationContext(jp,\n                        getDeserializationConfig());\n                result = _findRootDeserializer(ctxt, valueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            // Need to consume the token too\n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) { }\n        }\n    }", "_initForReading": "\n    protected JsonToken _initForReading(JsonParser jp)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            // and then we must get something...\n            t = jp.nextToken();\n            if (t == null) {\n                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                 *   not an actual parsing problem\n                 */\n                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }", "_unwrapAndDeserialize": "\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n            DeserializationConfig config,\n            JavaType rootType, JsonDeserializer<Object> deser)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        String expName = config.getRootName();\n        if (expName == null) {\n            PropertyName pname = _rootNames.findRootName(rootType, config);\n            expName = pname.getSimpleName();\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        jp.nextToken();\n        Object result = deser.deserialize(jp, ctxt);\n        // and last, verify that we now get matching END_OBJECT\n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }", "_findRootDeserializer": "\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }", "_verifySchemaType": "\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }"}