{"withResolved": "\n    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd,\n            JsonDeserializer<?> vd, TypeDeserializer vtd,\n            Boolean unwrapSingle)\n    {\n        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)\n                && (_unwrapSingle == unwrapSingle)) {\n            return this;\n        }\n        return new CollectionDeserializer(_collectionType,\n                (JsonDeserializer<Object>) vd, vtd,\n                _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);\n    }", "isCachable": "\n    public boolean isCachable() {\n        // 26-Mar-2015, tatu: As per [databind#735], need to be careful\n        return (_valueDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_delegateDeserializer == null)\n                ;\n    }", "createContextual": "\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        // also, often value deserializer is resolved here:\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        // and finally, type deserializer needs context as well\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }", "getContentType": "\n    public JavaType getContentType() {\n        return _collectionType.getContentType();\n    }", "getContentDeserializer": "\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }", "deserialize": "\n    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n            return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(p, ctxt));\n        }\n        /* Empty String may be ok; bit tricky to check, however, since\n         * there is also possibility of \"auto-wrapping\" of single-element arrays.\n         * Hence we only accept empty String here.\n         */\n        if (p.hasToken(JsonToken.VALUE_STRING)) {\n            String str = p.getText();\n            if (str.length() == 0) {\n                return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n            }\n        }\n        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n    }", "deserializeWithType": "\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }", "handleNonArray": "\n    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt,\n            Collection<Object> result)\n        throws IOException\n    {\n        // Implicit arrays from single values?\n        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||\n                ((_unwrapSingle == null) &&\n                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));\n        if (!canWrap) {\n            throw ctxt.mappingException(_collectionType.getRawClass());\n        }\n        JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        JsonToken t = p.getCurrentToken();\n\n        Object value;\n\n        try {\n            if (t == JsonToken.VALUE_NULL) {\n                value = valueDes.getNullValue(ctxt);\n            } else if (typeDeser == null) {\n                value = valueDes.deserialize(p, ctxt);\n            } else {\n                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n            }\n        } catch (Exception e) {\n            // note: pass Object.class, not Object[].class, as we need element type for error info\n            throw JsonMappingException.wrapWithPath(e, Object.class, result.size());\n        }\n        result.add(value);\n        return result;\n    }", "add": "\n        public void add(Object value)\n        {\n            if (_accumulator.isEmpty()) {\n                _result.add(value);\n            } else {\n                CollectionReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.add(value);\n            }\n        }", "handleUnresolvedReference": "\n        public Referring handleUnresolvedReference(UnresolvedForwardReference reference)\n        {\n            CollectionReferring id = new CollectionReferring(this, reference, _elementType);\n            _accumulator.add(id);\n            return id;\n        }", "resolveForwardReference": "\n        public void resolveForwardReference(Object id, Object value) throws IOException\n        {\n            Iterator<CollectionReferring> iterator = _accumulator.iterator();\n            // Resolve ordering after resolution of an id. This mean either:\n            // 1- adding to the result collection in case of the first unresolved id.\n            // 2- merge the content of the resolved id with its previous unresolved id.\n            Collection<Object> previous = _result;\n            while (iterator.hasNext()) {\n                CollectionReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.add(value);\n                    previous.addAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }", "handleResolvedForwardReference": "\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }"}