{"getEncoding": "\n    public String getEncoding() {\n        return encoding;\n    }", "close": "\n    public void close() throws IOException {\n        // this flag is only written here and read in finalize() which\n        // can never be run in parallel.\n        // no synchronization needed.\n        closed = true;\n\n        archive.close();\n    }", "closeQuietly": "\n    public static void closeQuietly(ZipFile zipfile) {\n        if (zipfile != null) {\n            try {\n                zipfile.close();\n            } catch (IOException e) { // NOPMD\n                //ignore, that's why the method is called \"quietly\"\n            }\n        }\n    }", "getEntries": "\n    public Enumeration<ZipArchiveEntry> getEntries() {\n        return Collections.enumeration(entries.keySet());\n    }", "getEntriesInPhysicalOrder": "\n    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n        ZipArchiveEntry[] allEntries =\n            entries.keySet().toArray(new ZipArchiveEntry[0]);\n        Arrays.sort(allEntries, OFFSET_COMPARATOR);\n        return Collections.enumeration(Arrays.asList(allEntries));\n    }", "getEntry": "\n    public ZipArchiveEntry getEntry(String name) {\n        return nameMap.get(name);\n    }", "canReadEntryData": "\n    public boolean canReadEntryData(ZipArchiveEntry ze) {\n        return ZipUtil.canHandleEntryData(ze);\n    }", "getInputStream": "\n    public InputStream getInputStream(ZipArchiveEntry ze)\n        throws IOException, ZipException {\n        OffsetEntry offsetEntry = entries.get(ze);\n        if (offsetEntry == null) {\n            return null;\n        }\n        ZipUtil.checkRequestedFeatures(ze);\n        long start = offsetEntry.dataOffset;\n        BoundedInputStream bis =\n            new BoundedInputStream(start, ze.getCompressedSize());\n        switch (ze.getMethod()) {\n            case ZipArchiveEntry.STORED:\n                return bis;\n            case ZipArchiveEntry.DEFLATED:\n                bis.addDummy();\n                final Inflater inflater = new Inflater(true);\n                return new InflaterInputStream(bis, inflater) {\n                    @Override\n                    public void close() throws IOException {\n                        super.close();\n                        inflater.end();\n                    }\n                };\n            default:\n                throw new ZipException(\"Found unsupported compression method \"\n                                       + ze.getMethod());\n        }\n    }", "finalize": "\n    protected void finalize() throws Throwable {\n        try {\n            if (!closed) {\n                System.err.println(\"Cleaning up unclosed ZipFile for archive \"\n                                   + archiveName);\n                close();\n            }\n        } finally {\n            super.finalize();\n        }\n    }", "populateFromCentralDirectory": "\n    private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n        throws IOException {\n        HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n            new HashMap<ZipArchiveEntry, NameAndComment>();\n\n        positionAtCentralDirectory();\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n\n        if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n\n        while (sig == CFH_SIG) {\n            readCentralDirectoryEntry(noUTF8Flag);\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n        }\n        return noUTF8Flag;\n    }", "readCentralDirectoryEntry": "\n    private void\n        readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n        throws IOException {\n        byte[] cfh = new byte[CFH_LEN];\n\n        archive.readFully(cfh);\n        int off = 0;\n        ZipArchiveEntry ze = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(cfh, off);\n        off += SHORT;\n        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n        off += SHORT; // skip version info\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding =\n            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        ze.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        ze.setMethod(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n        ze.setTime(time);\n        off += WORD;\n\n        ze.setCrc(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        int fileNameLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int commentLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int diskStart = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        byte[] fileName = new byte[fileNameLen];\n        archive.readFully(fileName);\n        ze.setName(entryEncoding.decode(fileName), fileName);\n\n        // LFH offset,\n        OffsetEntry offset = new OffsetEntry();\n        offset.headerOffset = ZipLong.getValue(cfh, off);\n        // data offset will be filled later\n        entries.put(ze, offset);\n\n        nameMap.put(ze.getName(), ze);\n\n        byte[] cdExtraData = new byte[extraLen];\n        archive.readFully(cdExtraData);\n        ze.setCentralDirectoryExtra(cdExtraData);\n\n        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\n        byte[] comment = new byte[commentLen];\n        archive.readFully(comment);\n        ze.setComment(entryEncoding.decode(comment));\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n        }\n    }", "setSizesAndOffsetFromZip64Extra": "\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }", "positionAtCentralDirectory": "\n    private void positionAtCentralDirectory()\n        throws IOException {\n        boolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n                                             MAX_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n                                             ZipArchiveOutputStream\n                                             .ZIP64_EOCD_LOC_SIG);\n        if (!found) {\n            // not a ZIP64 archive\n            positionAtCentralDirectory32();\n        } else {\n            positionAtCentralDirectory64();\n        }\n    }", "positionAtCentralDirectory64": "\n    private void positionAtCentralDirectory64()\n        throws IOException {\n        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n        byte[] zip64EocdOffset = new byte[DWORD];\n        archive.readFully(zip64EocdOffset);\n        archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n        byte[] sig = new byte[WORD];\n        archive.readFully(sig);\n        if (sig[POS_0] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_0]\n            || sig[POS_1] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_1]\n            || sig[POS_2] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_2]\n            || sig[POS_3] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_3]\n            ) {\n            throw new ZipException(\"archive's ZIP64 end of central \"\n                                   + \"directory locator is corrupt.\");\n        }\n        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                  - WORD /* signature has already been read */);\n        byte[] cfdOffset = new byte[DWORD];\n        archive.readFully(cfdOffset);\n        archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n    }", "positionAtCentralDirectory32": "\n    private void positionAtCentralDirectory32()\n        throws IOException {\n        boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n                                             ZipArchiveOutputStream.EOCD_SIG);\n        if (!found) {\n            throw new ZipException(\"archive is not a ZIP archive\");\n        }\n        skipBytes(CFD_LOCATOR_OFFSET);\n        byte[] cfdOffset = new byte[WORD];\n        archive.readFully(cfdOffset);\n        archive.seek(ZipLong.getValue(cfdOffset));\n    }", "tryToLocateSignature": "\n    private boolean tryToLocateSignature(long minDistanceFromEnd,\n                                         long maxDistanceFromEnd,\n                                         byte[] sig) throws IOException {\n        boolean found = false;\n        long off = archive.length() - minDistanceFromEnd;\n        final long stopSearching =\n            Math.max(0L, archive.length() - maxDistanceFromEnd);\n        if (off >= 0) {\n            for (; off >= stopSearching; off--) {\n                archive.seek(off);\n                int curr = archive.read();\n                if (curr == -1) {\n                    break;\n                }\n                if (curr == sig[POS_0]) {\n                    curr = archive.read();\n                    if (curr == sig[POS_1]) {\n                        curr = archive.read();\n                        if (curr == sig[POS_2]) {\n                            curr = archive.read();\n                            if (curr == sig[POS_3]) {\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (found) {\n            archive.seek(off);\n        }\n        return found;\n    }", "skipBytes": "\n    private void skipBytes(final int count) throws IOException {\n        int totalSkipped = 0;\n        while (totalSkipped < count) {\n            int skippedNow = archive.skipBytes(count - totalSkipped);\n            if (skippedNow <= 0) {\n                throw new EOFException();\n            }\n            totalSkipped += skippedNow;\n        }\n    }", "resolveLocalFileHeaderData": "\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }", "startsWithLocalFileHeader": "\n    private boolean startsWithLocalFileHeader() throws IOException {\n        archive.seek(0);\n        final byte[] start = new byte[WORD];\n        archive.readFully(start);\n        for (int i = 0; i < start.length; i++) {\n            if (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "read": "\n        public int read() throws IOException {\n            if (remaining-- <= 0) {\n                if (addDummyByte) {\n                    addDummyByte = false;\n                    return 0;\n                }\n                return -1;\n            }\n            synchronized (archive) {\n                archive.seek(loc++);\n                return archive.read();\n            }\n        }", "addDummy": "\n        void addDummy() {\n            addDummyByte = true;\n        }"}