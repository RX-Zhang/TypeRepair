{"defaultSettings": "\n    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }", "initialiseParse": "\n    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }", "parseFragment": "\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }", "process": "\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }", "transition": "\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }", "state": "\n    HtmlTreeBuilderState state() {\n        return state;\n    }", "markInsertionMode": "\n    void markInsertionMode() {\n        originalState = state;\n    }", "originalState": "\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }", "framesetOk": "\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }", "getDocument": "\n    Document getDocument() {\n        return doc;\n    }", "getBaseUri": "\n    String getBaseUri() {\n        return baseUri;\n    }", "maybeSetBaseUri": "\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }", "isFragmentParsing": "\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }", "error": "\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }", "insert": "\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }", "insertStartTag": "\n    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }", "insertEmpty": "\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }", "insertForm": "\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }", "insertNode": "\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }", "pop": "\n    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }", "push": "\n    void push(Element element) {\n        stack.add(element);\n    }", "getStack": "\n    ArrayList<Element> getStack() {\n        return stack;\n    }", "onStack": "\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }", "isElementInQueue": "\n    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }", "getFromStack": "\n    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }", "removeFromStack": "\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }", "popStackToClose": "\n    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.nodeName().equals(elName))\n                break;\n        }\n    }", "popStackToBefore": "\n    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }", "clearStackToTableContext": "\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }", "clearStackToTableBodyContext": "\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }", "clearStackToTableRowContext": "\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }", "clearStackToContext": "\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }", "aboveOnStack": "\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }", "insertOnStackAfter": "\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }", "replaceOnStack": "\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }", "replaceInQueue": "\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }", "resetInsertionMode": "\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }", "inSpecificScope": "\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }", "inScope": "\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }", "inListItemScope": "\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }", "inButtonScope": "\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }", "inTableScope": "\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }", "inSelectScope": "\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }", "setHeadElement": "\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }", "getHeadElement": "\n    Element getHeadElement() {\n        return headElement;\n    }", "isFosterInserts": "\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }", "setFosterInserts": "\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }", "getFormElement": "\n    FormElement getFormElement() {\n        return formElement;\n    }", "setFormElement": "\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }", "newPendingTableCharacters": "\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }", "getPendingTableCharacters": "\n    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }", "setPendingTableCharacters": "\n    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }", "generateImpliedEndTags": "\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                inSorted(currentElement().nodeName(), TagSearchEndTags))\n            pop();\n    }", "isSpecial": "\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return inSorted(name, TagSearchSpecial);\n    }", "lastFormattingElement": "\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }", "removeLastFormattingElement": "\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }", "pushActiveFormattingElements": "\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }", "isSameFormattingElement": "\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }", "reconstructFormattingElements": "\n    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }", "clearFormattingElementsToLastMarker": "\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }", "removeFromActiveFormattingElements": "\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }", "isInActiveFormattingElements": "\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }", "getActiveFormattingElement": "\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }", "replaceActiveFormattingElement": "\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }", "insertMarkerToFormattingElements": "\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }", "insertInFosterParent": "\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }", "toString": "\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }"}