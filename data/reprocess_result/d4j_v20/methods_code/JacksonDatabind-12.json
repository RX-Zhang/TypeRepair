{"withResolved": "\n    protected MapDeserializer withResolved(KeyDeserializer keyDeser,\n            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser,\n            HashSet<String> ignorable)\n    {\n        \n        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n                && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) {\n            return this;\n        }\n        return new MapDeserializer(this,\n                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable);\n    }", "_isStdKeyDeser": "\n    protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser)\n    {\n        if (keyDeser == null) {\n            return true;\n        }\n        JavaType keyType = mapType.getKeyType();\n        if (keyType == null) { // assumed to be Object\n            return true;\n        }\n        Class<?> rawKeyType = keyType.getRawClass();\n        return ((rawKeyType == String.class || rawKeyType == Object.class)\n                && isDefaultKeyDeserializer(keyDeser));\n    }", "setIgnorableProperties": "\n    public void setIgnorableProperties(String[] ignorable) {\n        _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n            null : ArrayBuilders.arrayToSet(ignorable);\n    }", "resolve": "\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n    {\n        // May need to resolve types for delegate- and/or property-based creators:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_mapType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            /* Theoretically should be able to get CreatorProperty for delegate\n             * parameter to pass; but things get tricky because DelegateCreator\n             * may contain injectable values. So, for now, let's pass nothing.\n             */\n            _delegateDeserializer = findDeserializer(ctxt, delegateType, null);\n        }\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n    }", "createContextual": "\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n        } else {\n            if (kd instanceof ContextualKeyDeserializer) {\n                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n            }\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        // #125: May have a content converter\n        vd = findConvertingContentDeserializer(ctxt, property, vd);\n        if (vd == null) {\n            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            vd = ctxt.handleSecondaryContextualization(vd, property);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n            vtd = vtd.forProperty(property);\n        }\n        HashSet<String> ignored = _ignorableProperties;\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null && property != null) {\n            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n            if (moreToIgnore != null) {\n                ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n                for (String str : moreToIgnore) {\n                    ignored.add(str);\n                }\n            }\n        }\n        return withResolved(kd, vtd, vd, ignored);\n    }", "getContentType": "\n    public JavaType getContentType() {\n        return _mapType.getContentType();\n    }", "getContentDeserializer": "\n    public JsonDeserializer<Object> getContentDeserializer() {\n        return _valueDeserializer;\n    }", "isCachable": "\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }", "deserialize": "\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_propertyBasedCreator != null) {\n            return _deserializeUsingCreator(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return (Map<Object,Object>) _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (!_hasDefaultCreator) {\n            throw ctxt.instantiationException(getMapClass(), \"No default constructor found\");\n        }\n        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n            // [JACKSON-620] (empty) String may be ok however:\n            if (t == JsonToken.VALUE_STRING) {\n                return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, jp.getText());\n            }\n            throw ctxt.mappingException(getMapClass());\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringMap(jp, ctxt, result);\n            return result;\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }", "deserializeWithType": "\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException, JsonProcessingException\n    {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n    }", "getMapClass": "\n    public final Class<?> getMapClass() { return (Class<Map<Object,Object>>) _mapType.getRawClass(); }", "getValueType": "\n    @Override public JavaType getValueType() { return _mapType; }", "_readAndBind": "\n    protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final KeyDeserializer keyDes = _keyDeserializer;\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            Object key = keyDes.deserializeKey(fieldName, ctxt);\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try{\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                /* !!! 23-Dec-2008, tatu: should there be an option to verify\n                 *   that there are no duplicate field names? (and/or what\n                 *   to do, keep-first or keep-last)\n                 */\n                if (useObjectId) {\n                    referringAccumulator.put(key, value);\n                } else {\n                    result.put(key, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, key, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }", "_readAndBindStringMap": "\n    protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try {\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                if (useObjectId) {\n                    referringAccumulator.put(fieldName, value);\n                } else {\n                    result.put(fieldName, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n                handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n            } catch (Exception e) {\n                wrapAndThrow(e, result, fieldName);\n            }\n        }\n    }", "_deserializeUsingCreator": "\n    public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        // null -> no ObjectIdReader for Maps (yet?)\n        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null);\n\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = jp.nextToken();\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            t = jp.nextToken(); // to get to value\n            if (_ignorableProperties != null && _ignorableProperties.contains(propName)) {\n                jp.skipChildren(); // and skip it (in case of array/object)\n                continue;\n            }\n            // creator property?\n            SettableBeanProperty prop = creator.findCreatorProperty(propName);\n            if (prop != null) {\n                // Last property to set?\n                Object value = prop.deserialize(jp, ctxt);\n                if (buffer.assignParameter(prop.getCreatorIndex(), value)) {\n                    jp.nextToken();\n                    Map<Object,Object> result;\n                    try {\n                        result = (Map<Object,Object>)creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _mapType.getRawClass(), propName);\n                        return null;\n                    }\n                    _readAndBind(jp, ctxt, result);\n                    return result;\n                }\n                continue;\n            }\n            // other property? needs buffering\n            String fieldName = jp.getCurrentName();\n            Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n            Object value; \n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue();\n                } else if (typeDeser == null) {\n                    value = valueDes.deserialize(jp, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n                wrapAndThrow(e, _mapType.getRawClass(), propName);\n                return null;\n            }\n            buffer.bufferMapProperty(key, value);\n        }\n        // end of JSON object?\n        // if so, can just construct and leave...\n        try {\n            return (Map<Object,Object>)creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapAndThrow(e, _mapType.getRawClass(), null);\n            return null;\n        }\n    }", "wrapAndThrow": "\n    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n        wrapAndThrow(t, ref, null);\n    }", "handleUnresolvedReference": "\n    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n            Object key, UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        if (accumulator == null) {\n            throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n        }\n        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n        reference.getRoid().appendReferring(referring);\n    }", "put": "\n        public void put(Object key, Object value)\n        {\n            if (_accumulator.isEmpty()) {\n                _result.put(key, value);\n            } else {\n                MapReferring ref = _accumulator.get(_accumulator.size() - 1);\n                ref.next.put(key, value);\n            }\n        }", "resolveForwardReference": "\n        public void resolveForwardReference(Object id, Object value) throws IOException\n        {\n            Iterator<MapReferring> iterator = _accumulator.iterator();\n            // Resolve ordering after resolution of an id. This means either:\n            // 1- adding to the result map in case of the first unresolved id.\n            // 2- merge the content of the resolved id with its previous unresolved id.\n            Map<Object,Object> previous = _result;\n            while (iterator.hasNext()) {\n                MapReferring ref = iterator.next();\n                if (ref.hasId(id)) {\n                    iterator.remove();\n                    previous.put(ref.key, value);\n                    previous.putAll(ref.next);\n                    return;\n                }\n                previous = ref.next;\n            }\n\n            throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                    + \"] that wasn't previously seen as unresolved.\");\n        }", "handleResolvedForwardReference": "\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }"}