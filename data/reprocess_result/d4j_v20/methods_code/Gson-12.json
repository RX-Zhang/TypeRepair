{"beginArray": "\n  @Override public void beginArray() throws IOException {\n    expect(JsonToken.BEGIN_ARRAY);\n    JsonArray array = (JsonArray) peekStack();\n    push(array.iterator());\n    pathIndices[stackSize - 1] = 0;\n  }", "endArray": "\n  @Override public void endArray() throws IOException {\n    expect(JsonToken.END_ARRAY);\n    popStack(); // empty iterator\n    popStack(); // array\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }", "beginObject": "\n  @Override public void beginObject() throws IOException {\n    expect(JsonToken.BEGIN_OBJECT);\n    JsonObject object = (JsonObject) peekStack();\n    push(object.entrySet().iterator());\n  }", "endObject": "\n  @Override public void endObject() throws IOException {\n    expect(JsonToken.END_OBJECT);\n    popStack(); // empty iterator\n    popStack(); // object\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }", "hasNext": "\n  @Override public boolean hasNext() throws IOException {\n    JsonToken token = peek();\n    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n  }", "peek": "\n  @Override public JsonToken peek() throws IOException {\n    if (stackSize == 0) {\n      return JsonToken.END_DOCUMENT;\n    }\n\n    Object o = peekStack();\n    if (o instanceof Iterator) {\n      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n      Iterator<?> iterator = (Iterator<?>) o;\n      if (iterator.hasNext()) {\n        if (isObject) {\n          return JsonToken.NAME;\n        } else {\n          push(iterator.next());\n          return peek();\n        }\n      } else {\n        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n      }\n    } else if (o instanceof JsonObject) {\n      return JsonToken.BEGIN_OBJECT;\n    } else if (o instanceof JsonArray) {\n      return JsonToken.BEGIN_ARRAY;\n    } else if (o instanceof JsonPrimitive) {\n      JsonPrimitive primitive = (JsonPrimitive) o;\n      if (primitive.isString()) {\n        return JsonToken.STRING;\n      } else if (primitive.isBoolean()) {\n        return JsonToken.BOOLEAN;\n      } else if (primitive.isNumber()) {\n        return JsonToken.NUMBER;\n      } else {\n        throw new AssertionError();\n      }\n    } else if (o instanceof JsonNull) {\n      return JsonToken.NULL;\n    } else if (o == SENTINEL_CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    } else {\n      throw new AssertionError();\n    }\n  }", "peekStack": "\n  private Object peekStack() {\n    return stack[stackSize - 1];\n  }", "popStack": "\n  private Object popStack() {\n    Object result = stack[--stackSize];\n    stack[stackSize] = null;\n    return result;\n  }", "expect": "\n  private void expect(JsonToken expected) throws IOException {\n    if (peek() != expected) {\n      throw new IllegalStateException(\n          \"Expected \" + expected + \" but was \" + peek() + locationString());\n    }\n  }", "nextName": "\n  @Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = result;\n    push(entry.getValue());\n    return result;\n  }", "nextString": "\n  @Override public String nextString() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n    }\n    String result = ((JsonPrimitive) popStack()).getAsString();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }", "nextBoolean": "\n  @Override public boolean nextBoolean() throws IOException {\n    expect(JsonToken.BOOLEAN);\n    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }", "nextNull": "\n  @Override public void nextNull() throws IOException {\n    expect(JsonToken.NULL);\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }", "nextDouble": "\n  @Override public double nextDouble() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }", "nextLong": "\n  @Override public long nextLong() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    long result = ((JsonPrimitive) peekStack()).getAsLong();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }", "nextInt": "\n  @Override public int nextInt() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    int result = ((JsonPrimitive) peekStack()).getAsInt();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }", "close": "\n  @Override public void close() throws IOException {\n    stack = new Object[] { SENTINEL_CLOSED };\n    stackSize = 1;\n  }", "skipValue": "\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n        pathNames[stackSize - 1] = \"null\";\n    }\n      pathIndices[stackSize - 1]++;\n  }", "toString": "\n  @Override public String toString() {\n    return getClass().getSimpleName();\n  }", "promoteNameToValue": "\n  public void promoteNameToValue() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    push(entry.getValue());\n    push(new JsonPrimitive((String) entry.getKey()));\n  }", "push": "\n  private void push(Object newTop) {\n    if (stackSize == stack.length) {\n      Object[] newStack = new Object[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }", "getPath": "\n  @Override public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      if (stack[i] instanceof JsonArray) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('[').append(pathIndices[i]).append(']');\n        }\n      } else if (stack[i] instanceof JsonObject) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n        }\n      }\n    }\n    return result.toString();\n  }", "locationString": "\n  private String locationString() {\n    return \" at path \" + getPath();\n  }"}