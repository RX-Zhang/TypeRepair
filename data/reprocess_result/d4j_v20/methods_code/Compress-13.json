{"clone": "\n    public Object clone() {\n        ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n\n        e.setInternalAttributes(getInternalAttributes());\n        e.setExternalAttributes(getExternalAttributes());\n        e.setExtraFields(getExtraFields(true));\n        return e;\n    }", "getMethod": "\n    public int getMethod() {\n        return method;\n    }", "setMethod": "\n    public void setMethod(int method) {\n        if (method < 0) {\n            throw new IllegalArgumentException(\n                    \"ZIP compression method can not be negative: \" + method);\n        }\n        this.method = method;\n    }", "getInternalAttributes": "\n    public int getInternalAttributes() {\n        return internalAttributes;\n    }", "setInternalAttributes": "\n    public void setInternalAttributes(int value) {\n        internalAttributes = value;\n    }", "getExternalAttributes": "\n    public long getExternalAttributes() {\n        return externalAttributes;\n    }", "setExternalAttributes": "\n    public void setExternalAttributes(long value) {\n        externalAttributes = value;\n    }", "setUnixMode": "\n    public void setUnixMode(int mode) {\n        // CheckStyle:MagicNumberCheck OFF - no point\n        setExternalAttributes((mode << SHORT_SHIFT)\n                              // MS-DOS read-only attribute\n                              | ((mode & 0200) == 0 ? 1 : 0)\n                              // MS-DOS directory flag\n                              | (isDirectory() ? 0x10 : 0));\n        // CheckStyle:MagicNumberCheck ON\n        platform = PLATFORM_UNIX;\n    }", "getUnixMode": "\n    public int getUnixMode() {\n        return platform != PLATFORM_UNIX ? 0 :\n            (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);\n    }", "getPlatform": "\n    public int getPlatform() {\n        return platform;\n    }", "setPlatform": "\n    protected void setPlatform(int platform) {\n        this.platform = platform;\n    }", "setExtraFields": "\n    public void setExtraFields(ZipExtraField[] fields) {\n        extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n        for (int i = 0; i < fields.length; i++) {\n            if (fields[i] instanceof UnparseableExtraFieldData) {\n                unparseableExtra = (UnparseableExtraFieldData) fields[i];\n            } else {\n                extraFields.put(fields[i].getHeaderId(), fields[i]);\n            }\n        }\n        setExtra();\n    }", "getExtraFields": "\n    public ZipExtraField[] getExtraFields() {\n        return getExtraFields(false);\n    }", "addExtraField": "\n    public void addExtraField(ZipExtraField ze) {\n        if (ze instanceof UnparseableExtraFieldData) {\n            unparseableExtra = (UnparseableExtraFieldData) ze;\n        } else {\n            if (extraFields == null) {\n                extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n            }\n            extraFields.put(ze.getHeaderId(), ze);\n        }\n        setExtra();\n    }", "addAsFirstExtraField": "\n    public void addAsFirstExtraField(ZipExtraField ze) {\n        if (ze instanceof UnparseableExtraFieldData) {\n            unparseableExtra = (UnparseableExtraFieldData) ze;\n        } else {\n            LinkedHashMap<ZipShort, ZipExtraField> copy = extraFields;\n            extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n            extraFields.put(ze.getHeaderId(), ze);\n            if (copy != null) {\n                copy.remove(ze.getHeaderId());\n                extraFields.putAll(copy);\n            }\n        }\n        setExtra();\n    }", "removeExtraField": "\n    public void removeExtraField(ZipShort type) {\n        if (extraFields == null) {\n            throw new java.util.NoSuchElementException();\n        }\n        if (extraFields.remove(type) == null) {\n            throw new java.util.NoSuchElementException();\n        }\n        setExtra();\n    }", "removeUnparseableExtraFieldData": "\n    public void removeUnparseableExtraFieldData() {\n        if (unparseableExtra == null) {\n            throw new java.util.NoSuchElementException();\n        }\n        unparseableExtra = null;\n        setExtra();\n    }", "getExtraField": "\n    public ZipExtraField getExtraField(ZipShort type) {\n        if (extraFields != null) {\n            return extraFields.get(type);\n        }\n        return null;\n    }", "getUnparseableExtraFieldData": "\n    public UnparseableExtraFieldData getUnparseableExtraFieldData() {\n        return unparseableExtra;\n    }", "setExtra": "\n    public void setExtra(byte[] extra) throws RuntimeException {\n        try {\n            ZipExtraField[] local =\n                ExtraFieldUtils.parse(extra, true,\n                                      ExtraFieldUtils.UnparseableExtraField.READ);\n            mergeExtraFields(local, true);\n        } catch (ZipException e) {\n            // actually this is not possible as of Commons Compress 1.1\n            throw new RuntimeException(\"Error parsing extra fields for entry: \"\n                                       + getName() + \" - \" + e.getMessage(), e);\n        }\n    }", "setCentralDirectoryExtra": "\n    public void setCentralDirectoryExtra(byte[] b) {\n        try {\n            ZipExtraField[] central =\n                ExtraFieldUtils.parse(b, false,\n                                      ExtraFieldUtils.UnparseableExtraField.READ);\n            mergeExtraFields(central, false);\n        } catch (ZipException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }", "getLocalFileDataExtra": "\n    public byte[] getLocalFileDataExtra() {\n        byte[] extra = getExtra();\n        return extra != null ? extra : new byte[0];\n    }", "getCentralDirectoryExtra": "\n    public byte[] getCentralDirectoryExtra() {\n        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));\n    }", "getName": "\n    public String getName() {\n        return name == null ? super.getName() : name;\n    }", "isDirectory": "\n    public boolean isDirectory() {\n        return getName().endsWith(\"/\");\n    }", "setName": "\n    protected void setName(String name) {\n        this.name = name;\n    }", "getSize": "\n    public long getSize() {\n        return size;\n    }", "setSize": "\n    public void setSize(long size) {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"invalid entry size\");\n        }\n        this.size = size;\n    }", "getRawName": "\n    public byte[] getRawName() {\n        if (rawName != null) {\n            byte[] b = new byte[rawName.length];\n            System.arraycopy(rawName, 0, b, 0, rawName.length);\n            return b;\n        }\n        return null;\n    }", "hashCode": "\n    public int hashCode() {\n        // this method has severe consequences on performance. We cannot rely\n        // on the super.hashCode() method since super.getName() always return\n        // the empty string in the current implemention (there's no setter)\n        // so it is basically draining the performance of a hashmap lookup\n        return getName().hashCode();\n    }", "getGeneralPurposeBit": "\n    public GeneralPurposeBit getGeneralPurposeBit() {\n        return gpb;\n    }", "setGeneralPurposeBit": "\n    public void setGeneralPurposeBit(GeneralPurposeBit b) {\n        gpb = b;\n    }", "mergeExtraFields": "\n    private void mergeExtraFields(ZipExtraField[] f, boolean local)\n        throws ZipException {\n        if (extraFields == null) {\n            setExtraFields(f);\n        } else {\n            for (int i = 0; i < f.length; i++) {\n                ZipExtraField existing;\n                if (f[i] instanceof UnparseableExtraFieldData) {\n                    existing = unparseableExtra;\n                } else {\n                    existing = getExtraField(f[i].getHeaderId());\n                }\n                if (existing == null) {\n                    addExtraField(f[i]);\n                } else {\n                    if (local) {\n                        byte[] b = f[i].getLocalFileDataData();\n                        existing.parseFromLocalFileData(b, 0, b.length);\n                    } else {\n                        byte[] b = f[i].getCentralDirectoryData();\n                        existing.parseFromCentralDirectoryData(b, 0, b.length);\n                    }\n                }\n            }\n            setExtra();\n        }\n    }", "getLastModifiedDate": "\n    public Date getLastModifiedDate() {\n        return new Date(getTime());\n    }", "equals": "\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        String myName = getName();\n        String otherName = other.getName();\n        if (myName == null) {\n            if (otherName != null) {\n                return false;\n            }\n        } else if (!myName.equals(otherName)) {\n            return false;\n        }\n        String myComment = getComment();\n        String otherComment = other.getComment();\n        if (myComment == null) {\n            if (otherComment != null) {\n                return false;\n            }\n        } else if (!myComment.equals(otherComment)) {\n            return false;\n        }\n        return getTime() == other.getTime()\n            && getInternalAttributes() == other.getInternalAttributes()\n            && getPlatform() == other.getPlatform()\n            && getExternalAttributes() == other.getExternalAttributes()\n            && getMethod() == other.getMethod()\n            && getSize() == other.getSize()\n            && getCrc() == other.getCrc()\n            && getCompressedSize() == other.getCompressedSize()\n            && Arrays.equals(getCentralDirectoryExtra(),\n                             other.getCentralDirectoryExtra())\n            && Arrays.equals(getLocalFileDataExtra(),\n                             other.getLocalFileDataExtra())\n            && gpb.equals(other.gpb);\n    }"}