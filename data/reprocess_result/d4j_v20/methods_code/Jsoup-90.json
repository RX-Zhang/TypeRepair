{"connect": "\n    public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }", "encodeUrl": "\n\tprivate static String encodeUrl(String url) {\n        try {\n            URL u = new URL(url);\n            return encodeUrl(u).toExternalForm();\n        } catch (Exception e) {\n            return url;\n        }\n\t}", "encodeMimeName": "\n    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }", "url": "\n    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }", "proxy": "\n    public Connection proxy(Proxy proxy) {\n        req.proxy(proxy);\n        return this;\n    }", "userAgent": "\n    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(USER_AGENT, userAgent);\n        return this;\n    }", "timeout": "\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }", "maxBodySize": "\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }", "followRedirects": "\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }", "referrer": "\n    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }", "method": "\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }", "ignoreHttpErrors": "\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}", "ignoreContentType": "\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }", "data": "\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }", "sslSocketFactory": "\n    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n\t    req.sslSocketFactory(sslSocketFactory);\n\t    return this;\n    }", "requestBody": "\n    public Connection requestBody(String body) {\n        req.requestBody(body);\n        return this;\n    }", "header": "\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }", "headers": "\n    public Connection headers(Map<String,String> headers) {\n        Validate.notNull(headers, \"Header map must not be null\");\n        for (Map.Entry<String,String> entry : headers.entrySet()) {\n            req.header(entry.getKey(),entry.getValue());\n        }\n        return this;\n    }", "cookie": "\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }", "cookies": "\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }", "parser": "\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }", "get": "\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }", "post": "\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }", "execute": "\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }", "request": "\n    public Connection.Request request() {\n        return req;\n    }", "response": "\n    public Connection.Response response() {\n        return res;\n    }", "postDataCharset": "\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }", "addHeader": "\n        public T addHeader(String name, String value) {\n            Validate.notEmpty(name);\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(fixHeaderEncoding(value));\n\n            return (T) this;\n        }", "fixHeaderEncoding": "\n        private static String fixHeaderEncoding(String val) {\n            try {\n                byte[] bytes = val.getBytes(\"ISO-8859-1\");\n                if (!looksLikeUtf8(bytes))\n                    return val;\n                return new String(bytes, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                // shouldn't happen as these both always exist\n                return val;\n            }\n        }", "looksLikeUtf8": "\n        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }", "hasHeader": "\n        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeadersCaseInsensitive(name).size() != 0;\n        }", "hasHeaderWithValue": "\n        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }", "removeHeader": "\n        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }", "multiHeaders": "\n        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }", "getHeadersCaseInsensitive": "\n        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }", "scanHeaders": "\n        private Map.Entry<String, List<String>> scanHeaders(String name) {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }", "hasCookie": "\n        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }", "removeCookie": "\n        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }", "statusCode": "\n        public int statusCode() {\n            return statusCode;\n        }", "statusMessage": "\n        public String statusMessage() {\n            return statusMessage;\n        }", "charset": "\n        public String charset() {\n            return charset;\n        }", "contentType": "\n        public String contentType() {\n            return contentType;\n        }", "parse": "\n        public Document parse() throws IOException {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            if (byteData != null) { // bytes have been read in to the buffer, parse that\n                bodyStream = new ByteArrayInputStream(byteData.array());\n                inputStreamRead = false; // ok to reparse if in bytes\n            }\n            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n            Document doc = DataUtil.parseInputStream(bodyStream, charset, url.toExternalForm(), req.parser());\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            inputStreamRead = true;\n            safeClose();\n            return doc;\n        }", "prepareByteData": "\n        private void prepareByteData() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            if (byteData == null) {\n                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n                try {\n                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                } finally {\n                    inputStreamRead = true;\n                    safeClose();\n                }\n            }\n        }", "body": "\n        public String body() {\n            prepareByteData();\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body;\n            if (charset == null)\n                body = Charset.forName(DataUtil.defaultCharset).decode(byteData).toString();\n            else\n                body = Charset.forName(charset).decode(byteData).toString();\n            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9\n            return body;\n        }", "bodyAsBytes": "\n        public byte[] bodyAsBytes() {\n            prepareByteData();\n            return byteData.array();\n        }", "bufferUp": "\n        public Connection.Response bufferUp() {\n            prepareByteData();\n            return this;\n        }", "bodyStream": "\n        public BufferedInputStream bodyStream() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            Validate.isFalse(inputStreamRead, \"Request has already been read\");\n            inputStreamRead = true;\n            return ConstrainableInputStream.wrap(bodyStream, DataUtil.bufferSize, req.maxBodySize());\n        }", "createConnection": "\n        private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n            final HttpURLConnection conn = (HttpURLConnection) (\n                req.proxy() == null ?\n                req.url().openConnection() :\n                req.url().openConnection(req.proxy())\n            );\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read\n\n            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)\n                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            if (req.cookies().size() > 0)\n                conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {\n                for (String value : header.getValue()) {\n                    conn.addRequestProperty(header.getKey(), value);\n                }\n            }\n            return conn;\n        }", "safeClose": "\n        private void safeClose() {\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    // no-op\n                } finally {\n                    bodyStream = null;\n                }\n            }\n        }", "setupFromConnection": "\n        private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException {\n            this.conn = conn;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            // if from a redirect, map previous response cookies into this response\n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n                previousResponse.safeClose();\n            }\n        }", "createHeaderMap": "\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }", "processResponseHeaders": "\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                }\n                for (String value : values) {\n                    addHeader(name, value);\n                }\n            }\n        }", "setOutputContentType": "\n        private static String setOutputContentType(final Connection.Request req) {\n            String bound = null;\n            if (req.hasHeader(CONTENT_TYPE)) {\n                // no-op; don't add content type as already set (e.g. for requestBody())\n                // todo - if content type already set, we could add charset\n\n                // if user has set content type to multipart/form-data, auto add boundary.\n                if(req.header(CONTENT_TYPE).contains(MULTIPART_FORM_DATA) &&\n                        !req.header(CONTENT_TYPE).contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }", "writePost": "\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, req.postDataCharset()));\n\n            if (bound != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        w.write(keyVal.contentType() != null ? keyVal.contentType() : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else if (req.requestBody() != null) {\n                // data will be in query string, we're sending a plaintext body\n                w.write(req.requestBody());\n            }\n            else {\n                // regular form data (application/x-www-form-urlencoded)\n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }", "getRequestCookieString": "\n        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = StringUtil.borrowBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                // todo: spec says only ascii, no escaping / encoding defined. validate on set? or escape somehow here?\n            }\n            return StringUtil.releaseBuilder(sb);\n        }", "serialiseRequestUrl": "\n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = StringUtil.borrowBuilder();\n            boolean first = true;\n            // reconstitute the query, ready for appends\n            url\n                .append(in.getProtocol())\n                .append(\"://\")\n                .append(in.getAuthority()) // includes host, port\n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(StringUtil.releaseBuilder(url)));\n            req.data().clear(); // moved into url as get params\n        }", "needsMultipart": "\n    private static boolean needsMultipart(Connection.Request req) {\n        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n        for (Connection.KeyVal keyVal : req.data()) {\n            if (keyVal.hasInputStream())\n                return true;\n        }\n        return false;\n    }", "create": "\n        public static KeyVal create(String key, String value) {\n            return new KeyVal().key(key).value(value);\n        }", "key": "\n        public KeyVal key(String key) {\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            this.key = key;\n            return this;\n        }", "value": "\n        public KeyVal value(String value) {\n            Validate.notNull(value, \"Data value must not be null\");\n            this.value = value;\n            return this;\n        }", "inputStream": "\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNull(value, \"Data input stream must not be null\");\n            this.stream = inputStream;\n            return this;\n        }", "hasInputStream": "\n        public boolean hasInputStream() {\n            return stream != null;\n        }", "toString": "\n        public String toString() {\n            return key + \"=\" + value;\n        }"}