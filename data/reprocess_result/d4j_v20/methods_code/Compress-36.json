{"close": "\n    public void close() throws IOException {\n        if (file != null) {\n            try {\n                file.close();\n            } finally {\n                file = null;\n                if (password != null) {\n                    Arrays.fill(password, (byte) 0);\n                }\n                password = null;\n            }\n        }\n    }", "getNextEntry": "\n    public SevenZArchiveEntry getNextEntry() throws IOException {\n        if (currentEntryIndex >= archive.files.length - 1) {\n            return null;\n        }\n        ++currentEntryIndex;\n        final SevenZArchiveEntry entry = archive.files[currentEntryIndex];\n        buildDecodingStream();\n        return entry;\n    }", "getEntries": "\n    public Iterable<SevenZArchiveEntry> getEntries() {\n        return Arrays.asList(archive.files);\n    }", "readHeaders": "\n    private Archive readHeaders(final byte[] password) throws IOException {\n        final byte[] signature = new byte[6];\n        file.readFully(signature);\n        if (!Arrays.equals(signature, sevenZSignature)) {\n            throw new IOException(\"Bad 7z signature\");\n        }\n        // 7zFormat.txt has it wrong - it's first major then minor\n        final byte archiveVersionMajor = file.readByte();\n        final byte archiveVersionMinor = file.readByte();\n        if (archiveVersionMajor != 0) {\n            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\n                    archiveVersionMajor, archiveVersionMinor));\n        }\n\n        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\n        final StartHeader startHeader = readStartHeader(startHeaderCrc);\n        \n        final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n        if (nextHeaderSizeInt != startHeader.nextHeaderSize) {\n            throw new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n        }\n        file.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n        final byte[] nextHeader = new byte[nextHeaderSizeInt];\n        file.readFully(nextHeader);\n        final CRC32 crc = new CRC32();\n        crc.update(nextHeader);\n        if (startHeader.nextHeaderCrc != crc.getValue()) {\n            throw new IOException(\"NextHeader CRC mismatch\");\n        }\n        \n        final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n        DataInputStream nextHeaderInputStream = new DataInputStream(\n                byteStream);\n        Archive archive = new Archive();\n        int nid = nextHeaderInputStream.readUnsignedByte();\n        if (nid == NID.kEncodedHeader) {\n            nextHeaderInputStream =\n                readEncodedHeader(nextHeaderInputStream, archive, password);\n            // Archive gets rebuilt with the new header\n            archive = new Archive();\n            nid = nextHeaderInputStream.readUnsignedByte();\n        }\n        if (nid == NID.kHeader) {\n            readHeader(nextHeaderInputStream, archive);\n            nextHeaderInputStream.close();\n        } else {\n            throw new IOException(\"Broken or unsupported archive: no Header\");\n        }\n        return archive;\n    }", "readStartHeader": "\n    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n        final StartHeader startHeader = new StartHeader();\n        DataInputStream dataInputStream = null;\n        try {\n             dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n                    new BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\n             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\n             return startHeader;\n        } finally {\n            if (dataInputStream != null) {\n                dataInputStream.close();\n            }\n        }\n    }", "readHeader": "\n    private void readHeader(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kArchiveProperties) {\n            readArchiveProperties(header);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kAdditionalStreamsInfo) {\n            throw new IOException(\"Additional streams unsupported\");\n            //nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kMainStreamsInfo) {\n            readStreamsInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kFilesInfo) {\n            readFilesInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated header, found \" + nid);\n        }\n    }", "readArchiveProperties": "\n    private void readArchiveProperties(final DataInput input) throws IOException {\n        // FIXME: the reference implementation just throws them away?\n        int nid =  input.readUnsignedByte();\n        while (nid != NID.kEnd) {\n            final long propertySize = readUint64(input);\n            final byte[] property = new byte[(int)propertySize];\n            input.readFully(property);\n            nid = input.readUnsignedByte();\n        }\n    }", "readEncodedHeader": "\n    private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\n                                              final byte[] password) throws IOException {\n        readStreamsInfo(header, archive);\n        \n        // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\n        final Folder folder = archive.folders[0];\n        final int firstPackStreamIndex = 0;\n        final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                0;\n        \n        file.seek(folderOffset);\n        InputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\n                archive.packSizes[firstPackStreamIndex]);\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n            }\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n        }\n        if (folder.hasCrc) {\n            inputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,\n                    folder.getUnpackSize(), folder.crc);\n        }\n        final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n        final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\n        try {\n            nextHeaderInputStream.readFully(nextHeader);\n        } finally {\n            nextHeaderInputStream.close();\n        }\n        return new DataInputStream(new ByteArrayInputStream(nextHeader));\n    }", "readStreamsInfo": "\n    private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kPackInfo) {\n            readPackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kUnpackInfo) {\n            readUnpackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        } else {\n            // archive without unpack/coders info\n            archive.folders = new Folder[0];\n        }\n        \n        if (nid == NID.kSubStreamsInfo) {\n            readSubStreamsInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated StreamsInfo\");\n        }\n    }", "readPackInfo": "\n    private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\n        archive.packPos = readUint64(header);\n        final long numPackStreams = readUint64(header);\n        int nid = header.readUnsignedByte();\n        if (nid == NID.kSize) {\n            archive.packSizes = new long[(int)numPackStreams];\n            for (int i = 0; i < archive.packSizes.length; i++) {\n                archive.packSizes[i] = readUint64(header);\n            }\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kCRC) {\n            archive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\n            archive.packCrcs = new long[(int)numPackStreams];\n            for (int i = 0; i < (int)numPackStreams; i++) {\n                if (archive.packCrcsDefined.get(i)) {\n                    archive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n        }\n    }", "readUnpackInfo": "\n    private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        if (nid != NID.kFolder) {\n            throw new IOException(\"Expected kFolder, got \" + nid);\n        }\n        final long numFolders = readUint64(header);\n        final Folder[] folders = new Folder[(int)numFolders];\n        archive.folders = folders;\n        final int external = header.readUnsignedByte();\n        if (external != 0) {\n            throw new IOException(\"External unsupported\");\n        }\n        for (int i = 0; i < (int)numFolders; i++) {\n            folders[i] = readFolder(header);\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid != NID.kCodersUnpackSize) {\n            throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n        }\n        for (final Folder folder : folders) {\n            folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n            for (int i = 0; i < folder.totalOutputStreams; i++) {\n                folder.unpackSizes[i] = readUint64(header);\n            }\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid == NID.kCRC) {\n            final BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\n            for (int i = 0; i < (int)numFolders; i++) {\n                if (crcsDefined.get(i)) {\n                    folders[i].hasCrc = true;\n                    folders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                } else {\n                    folders[i].hasCrc = false;\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated UnpackInfo\");\n        }\n    }", "readSubStreamsInfo": "\n    private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        for (final Folder folder : archive.folders) {\n            folder.numUnpackSubStreams = 1;\n        }\n        int totalUnpackStreams = archive.folders.length;\n        \n        int nid = header.readUnsignedByte();\n        if (nid == NID.kNumUnpackStream) {\n            totalUnpackStreams = 0;\n            for (final Folder folder : archive.folders) {\n                final long numStreams = readUint64(header);\n                folder.numUnpackSubStreams = (int)numStreams;\n                totalUnpackStreams += numStreams;\n            }\n            nid = header.readUnsignedByte();\n        }\n        \n        final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n        subStreamsInfo.crcs = new long[totalUnpackStreams];\n        \n        int nextUnpackStream = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams == 0) {\n                continue;\n            }\n            long sum = 0;\n            if (nid == NID.kSize) {\n                for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {\n                    final long size = readUint64(header);\n                    subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                    sum += size;\n                }\n            }\n            subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n        }\n        if (nid == NID.kSize) {\n            nid = header.readUnsignedByte();\n        }\n        \n        int numDigests = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\n                numDigests += folder.numUnpackSubStreams;\n            }\n        }\n        \n        if (nid == NID.kCRC) {\n            final BitSet hasMissingCrc = readAllOrBits(header, numDigests);\n            final long[] missingCrcs = new long[numDigests];\n            for (int i = 0; i < numDigests; i++) {\n                if (hasMissingCrc.get(i)) {\n                    missingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                }\n            }\n            int nextCrc = 0;\n            int nextMissingCrc = 0;\n            for (final Folder folder: archive.folders) {\n                if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\n                    subStreamsInfo.hasCrc.set(nextCrc, true);\n                    subStreamsInfo.crcs[nextCrc] = folder.crc;\n                    ++nextCrc;\n                } else {\n                    for (int i = 0; i < folder.numUnpackSubStreams; i++) {\n                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\n                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n                        ++nextCrc;\n                        ++nextMissingCrc;\n                    }\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated SubStreamsInfo\");\n        }\n        \n        archive.subStreamsInfo = subStreamsInfo;\n    }", "readFolder": "\n    private Folder readFolder(final DataInput header) throws IOException {\n        final Folder folder = new Folder();\n        \n        final long numCoders = readUint64(header);\n        final Coder[] coders = new Coder[(int)numCoders];\n        long totalInStreams = 0;\n        long totalOutStreams = 0;\n        for (int i = 0; i < coders.length; i++) {\n            coders[i] = new Coder();\n            final int bits = header.readUnsignedByte();\n            final int idSize = bits & 0xf;\n            final boolean isSimple = (bits & 0x10) == 0;\n            final boolean hasAttributes = (bits & 0x20) != 0;\n            final boolean moreAlternativeMethods = (bits & 0x80) != 0;\n            \n            coders[i].decompressionMethodId = new byte[idSize];\n            header.readFully(coders[i].decompressionMethodId);\n            if (isSimple) {\n                coders[i].numInStreams = 1;\n                coders[i].numOutStreams = 1;\n            } else {\n                coders[i].numInStreams = readUint64(header);\n                coders[i].numOutStreams = readUint64(header);\n            }\n            totalInStreams += coders[i].numInStreams;\n            totalOutStreams += coders[i].numOutStreams;\n            if (hasAttributes) {\n                final long propertiesSize = readUint64(header);\n                coders[i].properties = new byte[(int)propertiesSize];\n                header.readFully(coders[i].properties);\n            }\n            // would need to keep looping as above:\n            while (moreAlternativeMethods) {\n                throw new IOException(\"Alternative methods are unsupported, please report. \" +\n                        \"The reference implementation doesn't support them either.\");\n            }\n        }\n        folder.coders = coders;\n        folder.totalInputStreams = totalInStreams;\n        folder.totalOutputStreams = totalOutStreams;\n        \n        if (totalOutStreams == 0) {\n            throw new IOException(\"Total output streams can't be 0\");\n        }\n        final long numBindPairs = totalOutStreams - 1;\n        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];\n        for (int i = 0; i < bindPairs.length; i++) {\n            bindPairs[i] = new BindPair();\n            bindPairs[i].inIndex = readUint64(header);\n            bindPairs[i].outIndex = readUint64(header);\n        }\n        folder.bindPairs = bindPairs;\n        \n        if (totalInStreams < numBindPairs) {\n            throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n        }\n        final long numPackedStreams = totalInStreams - numBindPairs;\n        final long packedStreams[] = new long[(int)numPackedStreams];\n        if (numPackedStreams == 1) {\n            int i;\n            for (i = 0; i < (int)totalInStreams; i++) {\n                if (folder.findBindPairForInStream(i) < 0) {\n                    break;\n                }\n            }\n            if (i == (int)totalInStreams) {\n                throw new IOException(\"Couldn't find stream's bind pair index\");\n            }\n            packedStreams[0] = i;\n        } else {\n            for (int i = 0; i < (int)numPackedStreams; i++) {\n                packedStreams[i] = readUint64(header);\n            }\n        }\n        folder.packedStreams = packedStreams;\n        \n        return folder;\n    }", "readAllOrBits": "\n    private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\n        final int areAllDefined = header.readUnsignedByte();\n        final BitSet bits;\n        if (areAllDefined != 0) {\n            bits = new BitSet(size);\n            for (int i = 0; i < size; i++) {\n                bits.set(i, true);\n            }\n        } else {\n            bits = readBits(header, size);\n        }\n        return bits;\n    }", "readBits": "\n    private BitSet readBits(final DataInput header, final int size) throws IOException {\n        final BitSet bits = new BitSet(size);\n        int mask = 0;\n        int cache = 0;\n        for (int i = 0; i < size; i++) {\n            if (mask == 0) {\n                mask = 0x80;\n                cache = header.readUnsignedByte();\n            }\n            bits.set(i, (cache & mask) != 0);\n            mask >>>= 1;\n        }\n        return bits;\n    }", "readFilesInfo": "\n    private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\n        final long numFiles = readUint64(header);\n        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n        for (int i = 0; i < files.length; i++) {\n            files[i] = new SevenZArchiveEntry();\n        }\n        BitSet isEmptyStream = null;\n        BitSet isEmptyFile = null; \n        BitSet isAnti = null;\n        while (true) {\n            final int propertyType = header.readUnsignedByte();\n            if (propertyType == 0) {\n                break;\n            }\n            final long size = readUint64(header);\n            switch (propertyType) {\n                case NID.kEmptyStream: {\n                    isEmptyStream = readBits(header, files.length);\n                    break;\n                }\n                case NID.kEmptyFile: {\n                    if (isEmptyStream == null) { // protect against NPE\n                        throw new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n                    }\n                    isEmptyFile = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kAnti: {\n                    if (isEmptyStream == null) { // protect against NPE\n                        throw new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n                    }\n                    isAnti = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kName: {\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Not implemented\");\n                    }\n                    if (((size - 1) & 1) != 0) {\n                        throw new IOException(\"File names length invalid\");\n                    }\n                    final byte[] names = new byte[(int)(size - 1)];\n                    header.readFully(names);\n                    int nextFile = 0;\n                    int nextName = 0;\n                    for (int i = 0; i < names.length; i += 2) {\n                        if (names[i] == 0 && names[i+1] == 0) {\n                            files[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\n                            nextName = i + 2;\n                        }\n                    }\n                    if (nextName != names.length || nextFile != files.length) {\n                        throw new IOException(\"Error parsing file names\");\n                    }\n                    break;\n                }\n                case NID.kCTime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasCreationDate(timesDefined.get(i));\n                        if (files[i].getHasCreationDate()) {\n                            files[i].setCreationDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kATime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasAccessDate(timesDefined.get(i));\n                        if (files[i].getHasAccessDate()) {\n                            files[i].setAccessDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kMTime: {\n                    final BitSet timesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasLastModifiedDate(timesDefined.get(i));\n                        if (files[i].getHasLastModifiedDate()) {\n                            files[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kWinAttributes: {\n                    final BitSet attributesDefined = readAllOrBits(header, files.length);\n                    final int external = header.readUnsignedByte();\n                    if (external != 0) {\n                        throw new IOException(\"Unimplemented\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        files[i].setHasWindowsAttributes(attributesDefined.get(i));\n                        if (files[i].getHasWindowsAttributes()) {\n                            files[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n                        }\n                    }\n                    break;\n                }\n                case NID.kStartPos: {\n                    throw new IOException(\"kStartPos is unsupported, please report\");\n                }\n                case NID.kDummy: {\n                    // 7z 9.20 asserts the content is all zeros and ignores the property\n                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n                    \n                    if (skipBytesFully(header, size) < size) {\n                        throw new IOException(\"Incomplete kDummy property\");\n                    }\n                    break;\n                }\n\n                default: {\n                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n                    if (skipBytesFully(header, size) < size) {\n                        throw new IOException(\"Incomplete property of type \" + propertyType);\n                    }\n                    break;\n                }\n            }\n        }\n        int nonEmptyFileCounter = 0;\n        int emptyFileCounter = 0;\n        for (int i = 0; i < files.length; i++) {\n            files[i].setHasStream(isEmptyStream == null ? true : !isEmptyStream.get(i));\n            if (files[i].hasStream()) {\n                files[i].setDirectory(false);\n                files[i].setAntiItem(false);\n                files[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n                files[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n                files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n                ++nonEmptyFileCounter;\n            } else {\n                files[i].setDirectory(isEmptyFile == null ? true : !isEmptyFile.get(emptyFileCounter));\n                files[i].setAntiItem(isAnti == null ? false : isAnti.get(emptyFileCounter));\n                files[i].setHasCrc(false);\n                files[i].setSize(0);\n                ++emptyFileCounter;\n            }\n        }\n        archive.files = files;\n        calculateStreamMap(archive);\n    }", "calculateStreamMap": "\n    private void calculateStreamMap(final Archive archive) throws IOException {\n        final StreamMap streamMap = new StreamMap();\n        \n        int nextFolderPackStreamIndex = 0;\n        final int numFolders = archive.folders != null ? archive.folders.length : 0;\n        streamMap.folderFirstPackStreamIndex = new int[numFolders];\n        for (int i = 0; i < numFolders; i++) {\n            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n        }\n        \n        long nextPackStreamOffset = 0;\n        final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\n        streamMap.packStreamOffsets = new long[numPackSizes];\n        for (int i = 0; i < numPackSizes; i++) {\n            streamMap.packStreamOffsets[i] = nextPackStreamOffset;\n            nextPackStreamOffset += archive.packSizes[i]; \n        }\n        \n        streamMap.folderFirstFileIndex = new int[numFolders];\n        streamMap.fileFolderIndex = new int[archive.files.length];\n        int nextFolderIndex = 0;\n        int nextFolderUnpackStreamIndex = 0;\n        for (int i = 0; i < archive.files.length; i++) {\n            if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\n                streamMap.fileFolderIndex[i] = -1;\n                continue;\n            }\n            if (nextFolderUnpackStreamIndex == 0) {\n                for (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\n                    streamMap.folderFirstFileIndex[nextFolderIndex] = i;\n                    if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\n                        break;\n                    }\n                }\n                if (nextFolderIndex >= archive.folders.length) {\n                    throw new IOException(\"Too few folders in archive\");\n                }\n            }\n            streamMap.fileFolderIndex[i] = nextFolderIndex;\n            if (!archive.files[i].hasStream()) {\n                continue;\n            }\n            ++nextFolderUnpackStreamIndex;\n            if (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n                ++nextFolderIndex;\n                nextFolderUnpackStreamIndex = 0;\n            }\n        }\n        \n        archive.streamMap = streamMap;\n    }", "buildDecodingStream": "\n    private void buildDecodingStream() throws IOException {\n        final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n        if (folderIndex < 0) {\n            deferredBlockStreams.clear();\n            // TODO: previously it'd return an empty stream?\n            // new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);\n            return;\n        }\n        final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n        if (currentFolderIndex == folderIndex) {\n            // (COMPRESS-320).\n            // The current entry is within the same (potentially opened) folder. The\n            // previous stream has to be fully decoded before we can start reading\n            // but don't do it eagerly -- if the user skips over the entire folder nothing\n            // is effectively decompressed.\n\n            file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\n        } else {\n            // We're opening a new folder. Discard any queued streams/ folder stream.\n            currentFolderIndex = folderIndex;\n            deferredBlockStreams.clear();\n            if (currentFolderInputStream != null) {\n                currentFolderInputStream.close();\n                currentFolderInputStream = null;\n            }\n            \n            final Folder folder = archive.folders[folderIndex];\n            final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n            final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                    archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n            currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n        }\n\n        InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\n        if (file.getHasCrc()) {\n            fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n        }\n        \n        deferredBlockStreams.add(fileStream);\n    }", "buildDecoderStack": "\n    private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\n                final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n        file.seek(folderOffset);\n        InputStream inputStreamStack =\n            new BufferedInputStream(\n              new BoundedRandomAccessFileInputStream(file,\n                  archive.packSizes[firstPackStreamIndex]));\n        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n            }\n            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n            methods.addFirst(new SevenZMethodConfiguration(method,\n                     Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));\n        }\n        entry.setContentMethods(methods);\n        if (folder.hasCrc) {\n            return new CRC32VerifyingInputStream(inputStreamStack,\n                    folder.getUnpackSize(), folder.crc);\n        }\n        return inputStreamStack;\n    }", "read": "\n    public int read() throws IOException {\n        return getCurrentStream().read();\n    }", "getCurrentStream": "\n    private InputStream getCurrentStream() throws IOException {\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }", "readUint64": "\n    private static long readUint64(final DataInput in) throws IOException {\n        // long rather than int as it might get shifted beyond the range of an int\n        final long firstByte = in.readUnsignedByte();\n        int mask = 0x80;\n        long value = 0;\n        for (int i = 0; i < 8; i++) {\n            if ((firstByte & mask) == 0) {\n                return value | ((firstByte & (mask - 1)) << (8 * i));\n            }\n            final long nextByte = in.readUnsignedByte();\n            value |= nextByte << (8 * i);\n            mask >>>= 1;\n        }\n        return value;\n    }", "matches": "\n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < sevenZSignature.length) {\n            return false;\n        }\n\n        for (int i = 0; i < sevenZSignature.length; i++) {\n            if (signature[i] != sevenZSignature[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "skipBytesFully": "\n    private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException {\n        if (bytesToSkip < 1) {\n            return 0;\n        }\n        long skipped = 0;\n        while (bytesToSkip > Integer.MAX_VALUE) {\n            final long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        while (bytesToSkip > 0) {\n            final int skippedNow = input.skipBytes((int) bytesToSkip);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        return skipped;\n    }", "toString": "\n    public String toString() {\n      return archive.toString();\n    }"}