{"getHeaderId": "\n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }", "getLocalFileDataLength": "\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(size != null ? 2 * DWORD : 0);\n    }", "getCentralDirectoryLength": "\n    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort((size != null ? DWORD : 0)\n                            + (compressedSize != null ? DWORD : 0)\n                            + (relativeHeaderOffset != null ? DWORD : 0)\n                            + (diskStart != null ? WORD : 0));\n    }", "getLocalFileDataData": "\n    public byte[] getLocalFileDataData() {\n        if (size != null || compressedSize != null) {\n            if (size == null || compressedSize == null) {\n                throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n            }\n            byte[] data = new byte[2 * DWORD];\n            addSizes(data);\n            return data;\n        }\n        return EMPTY;\n    }", "getCentralDirectoryData": "\n    public byte[] getCentralDirectoryData() {\n        byte[] data = new byte[getCentralDirectoryLength().getValue()];\n        int off = addSizes(data);\n        if (relativeHeaderOffset != null) {\n            System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        if (diskStart != null) {\n            System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);\n            off += WORD;\n        }\n        return data;\n    }", "parseFromLocalFileData": "\n    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n        throws ZipException {\n        if (length == 0) {\n            // no local file data at all, may happen if an archive\n            // only holds a ZIP64 extended information extra field\n            // inside the central directory but not inside the local\n            // file header\n            return;\n        }\n        if (length < 2 * DWORD) {\n            throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n        }\n        size = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        compressedSize = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        int remaining = length - 2 * DWORD;\n        if (remaining >= DWORD) {\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            remaining -= DWORD;\n        }\n        if (remaining >= WORD) {\n            diskStart = new ZipLong(buffer, offset);\n            offset += WORD;\n            remaining -= WORD;\n        }\n    }", "parseFromCentralDirectoryData": "\n    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                              int length)\n        throws ZipException {\n        // store for processing in reparseCentralDirectoryData\n        rawCentralDirectoryData = new byte[length];\n        System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n\n        // if there is no size information in here, we are screwed and\n        // can only hope things will get resolved by LFH data later\n        // But there are some cases that can be detected\n        // * all data is there\n        // * length == 24 -> both sizes and offset\n        // * length % 8 == 4 -> at least we can identify the diskStart field\n        if (length >= 3 * DWORD + WORD) {\n            parseFromLocalFileData(buffer, offset, length);\n        } else if (length == 3 * DWORD) {\n            size = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            compressedSize = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n        } else if (length % DWORD == WORD) {\n            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }", "reparseCentralDirectoryData": "\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }", "getSize": "\n    public ZipEightByteInteger getSize() {\n        return size;\n    }", "setSize": "\n    public void setSize(ZipEightByteInteger size) {\n        this.size = size;\n    }", "getCompressedSize": "\n    public ZipEightByteInteger getCompressedSize() {\n        return compressedSize;\n    }", "setCompressedSize": "\n    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n        this.compressedSize = compressedSize;\n    }", "getRelativeHeaderOffset": "\n    public ZipEightByteInteger getRelativeHeaderOffset() {\n        return relativeHeaderOffset;\n    }", "setRelativeHeaderOffset": "\n    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n        relativeHeaderOffset = rho;\n    }", "getDiskStartNumber": "\n    public ZipLong getDiskStartNumber() {\n        return diskStart;\n    }", "setDiskStartNumber": "\n    public void setDiskStartNumber(ZipLong ds) {\n        diskStart = ds;\n    }", "addSizes": "\n    private int addSizes(byte[] data) {\n        int off = 0;\n        if (size != null) {\n            System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n            off += DWORD;\n        }\n        if (compressedSize != null) {\n            System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        return off;\n    }"}