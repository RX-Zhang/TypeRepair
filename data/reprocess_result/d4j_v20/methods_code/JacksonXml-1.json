{"version": "\n    public Version version() {\n        return PackageVersion.VERSION;\n    }", "getCodec": "\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }", "setCodec": "\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }", "setXMLTextElementName": "\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }", "requiresCustomCodec": "\n    public boolean requiresCustomCodec() {\n        return true;\n    }", "enable": "\n    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }", "disable": "\n    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }", "isEnabled": "\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }", "configure": "\n    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }", "getFormatFeatures": "\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }", "overrideFormatFeatures": "\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }", "getStaxReader": "\n    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }", "addVirtualWrapping": "\n    public void addVirtualWrapping(Set<String> namesToWrap)\n    {\n        /* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n         *   problems with Lists-in-Lists properties\n         */\n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }", "getCurrentName": "\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }", "overrideCurrentName": "\n    public void overrideCurrentName(String name)\n    {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }", "close": "\n    public void close() throws IOException\n    {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }", "isClosed": "\n    public boolean isClosed() { return _closed; }", "getParsingContext": "\n    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }", "getTokenLocation": "\n    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }", "getCurrentLocation": "\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }", "isExpectedStartArrayToken": "\n    public boolean isExpectedStartArrayToken()\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            // Ok: must replace current context with array as well\n            _parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n            // And just in case a field name was to be returned, wipe it\n            _nextToken = null;\n            // and last thing, [dataformat-xml#33], better ignore attributes\n            _xmlTokens.skipAttributes();\n            return true;\n        }\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n        return (t == JsonToken.START_ARRAY);\n    }", "nextToken": "\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                    //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                /* One more refinement (pronunced like \"hack\") is that if\n                 * we had an empty String (or all white space), and we are\n                 * deserializing an array, we better hide the empty text.\n                 */\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        \n        // should never get here\n        _throwInternal();\n        return null;\n    }", "nextTextValue": "\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }", "_updateState": "\n    private void _updateState(JsonToken t)\n    {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }", "getText": "\n    public String getText() throws IOException\n    {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }", "getValueAsString": "\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }", "getTextCharacters": "\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }", "getTextLength": "\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }", "getTextOffset": "\n    public int getTextOffset() throws IOException {\n        return 0;\n    }", "hasTextCharacters": "\n    public boolean hasTextCharacters()\n    {\n        return false;\n    }", "getEmbeddedObject": "\n    public Object getEmbeddedObject() throws IOException {\n        // no way to embed POJOs for now...\n        return null;\n    }", "getBinaryValue": "\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }", "_decodeBase64": "\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }", "getBigIntegerValue": "\n    public BigInteger getBigIntegerValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "getDecimalValue": "\n    public BigDecimal getDecimalValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "getDoubleValue": "\n    public double getDoubleValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getFloatValue": "\n    public float getFloatValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getIntValue": "\n    public int getIntValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getLongValue": "\n    public long getLongValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getNumberType": "\n    public NumberType getNumberType() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "getNumberValue": "\n    public Number getNumberValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "_handleEOF": "\n    protected void _handleEOF() throws JsonParseException\n    {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }", "_releaseBuffers": "\n    protected void _releaseBuffers() throws IOException {\n        // anything we can/must release? Underlying parser should do all of it, for now?\n    }", "_getByteArrayBuilder": "\n    protected ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }", "_isEmpty": "\n    protected boolean _isEmpty(String str)\n    {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }"}