{"getDeserializer": "\n    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)\n    {\n        if (nodeClass == ObjectNode.class) {\n            return ObjectDeserializer.getInstance();\n        }\n        if (nodeClass == ArrayNode.class) {\n            return ArrayDeserializer.getInstance();\n        }\n        // For others, generic one works fine\n        return instance;\n    }", "getNullValue": "\n    public JsonNode getNullValue(DeserializationContext ctxt) {\n        return NullNode.getInstance();\n    }", "deserialize": "\n    public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n        default:\n            return deserializeAny(p, ctxt, ctxt.getNodeFactory());\n        }\n    }", "getInstance": "\n        public static ObjectDeserializer getInstance() { return _instance; }", "deserializeWithType": "\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        /* Output can be as JSON Object, Array or scalar: no way to know\n         * a priori. So:\n         */\n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }", "isCachable": "\n    public boolean isCachable() { return true; }", "_reportProblem": "\n    protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException {\n        throw new JsonMappingException(msg, p.getTokenLocation());\n    }", "_handleDuplicateField": "\n    protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory,\n            String fieldName, ObjectNode objectNode,\n            JsonNode oldValue, JsonNode newValue)\n        throws JsonProcessingException\n    {\n        // [Issue#237]: Report an error if asked to do so:\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {\n            _reportProblem(p, \"Duplicate field '\"+fieldName+\"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled\");\n        }\n    }", "deserializeObject": "\n    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ObjectNode node = nodeFactory.objectNode();\n        String key;\n        if (p.isExpectedStartObjectToken()) {\n            key = p.nextFieldName();\n        } else {\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.END_OBJECT) {\n                return node;\n            }\n            if (t != JsonToken.FIELD_NAME) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key = p.getCurrentName();\n        }\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken t = p.nextToken();\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = nodeFactory.nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, nodeFactory);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, nodeFactory,\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }", "deserializeArray": "\n    protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ArrayNode node = nodeFactory.arrayNode();\n        while (true) {\n            JsonToken t = p.nextToken();\n            if (t == null) {\n                throw ctxt.mappingException(\"Unexpected end-of-input when binding data into ArrayNode\");\n            }\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                node.add(deserializeObject(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                node.add(deserializeArray(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_END_ARRAY:\n                return node;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                node.add(_fromEmbedded(p, ctxt, nodeFactory));\n            case JsonTokenId.ID_STRING:\n                node.add(nodeFactory.textNode(p.getText()));\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                node.add(_fromInt(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_TRUE:\n                node.add(nodeFactory.booleanNode(true));\n                break;\n            case JsonTokenId.ID_FALSE:\n                node.add(nodeFactory.booleanNode(false));\n                break;\n            case JsonTokenId.ID_NULL:\n                node.add(nodeFactory.nullNode());\n                break;\n            default:\n                node.add(deserializeAny(p, ctxt, nodeFactory));\n                break;\n            }\n        }\n    }", "deserializeAny": "\n    protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_END_OBJECT: // for empty JSON Objects we may point to this\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return _fromEmbedded(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_STRING:\n            return nodeFactory.textNode(p.getText());\n        case JsonTokenId.ID_NUMBER_INT:\n            return _fromInt(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return _fromFloat(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_TRUE:\n            return nodeFactory.booleanNode(true);\n        case JsonTokenId.ID_FALSE:\n            return nodeFactory.booleanNode(false);\n        case JsonTokenId.ID_NULL:\n            return nodeFactory.nullNode();\n            \n            // These states can not be mapped; input stream is\n            // off by an event or two\n\n        //case END_OBJECT:\n        //case END_ARRAY:\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }", "_fromInt": "\n    protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt;\n        int feats = ctxt.getDeserializationFeatures();\n        if ((feats & F_MASK_INT_COERCIONS) != 0) {\n            if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.BIG_INTEGER;\n            } else if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.LONG;\n            } else {\n                nt = p.getNumberType();\n            }\n        } else {\n            nt = p.getNumberType();\n        }\n        if (nt == JsonParser.NumberType.INT) {\n            return nodeFactory.numberNode(p.getIntValue());\n        }\n        if (nt == JsonParser.NumberType.LONG) {\n            return nodeFactory.numberNode(p.getLongValue());\n        }\n        return nodeFactory.numberNode(p.getBigIntegerValue());\n    }", "_fromFloat": "\n    protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt = p.getNumberType();\n        if (nt == JsonParser.NumberType.BIG_DECIMAL\n            || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            return nodeFactory.numberNode(p.getDecimalValue());\n        }\n        return nodeFactory.numberNode(p.getDoubleValue());\n    }", "_fromEmbedded": "\n    protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        // [JACKSON-796]\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) { // should this occur?\n            return nodeFactory.nullNode();\n        }\n        Class<?> type = ob.getClass();\n        if (type == byte[].class) { // most common special case\n            return nodeFactory.binaryNode((byte[]) ob);\n        }\n        // [databind#743]: Don't forget RawValue\n        if (ob instanceof RawValue) {\n            return nodeFactory.rawValueNode((RawValue) ob);\n        }\n        if (ob instanceof JsonNode) {\n            // [Issue#433]: but could also be a JsonNode hiding in there!\n            return (JsonNode) ob;\n        }\n        // any other special handling needed?\n        return nodeFactory.pojoNode(ob);\n    }"}