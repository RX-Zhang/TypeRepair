{"parse": "\n    Document parse(String input, String baseUri, ParseErrorList errors) {\n        state = HtmlTreeBuilderState.Initial;\n        return super.parse(input, baseUri, errors);\n    }", "parseFragment": "\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(inputFragment, baseUri, errors);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\"), baseUri);\n            doc.appendChild(root);\n            stack.push(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }", "process": "\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }", "transition": "\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }", "state": "\n    HtmlTreeBuilderState state() {\n        return state;\n    }", "markInsertionMode": "\n    void markInsertionMode() {\n        originalState = state;\n    }", "originalState": "\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }", "framesetOk": "\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }", "getDocument": "\n    Document getDocument() {\n        return doc;\n    }", "getBaseUri": "\n    String getBaseUri() {\n        return baseUri;\n    }", "maybeSetBaseUri": "\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }", "isFragmentParsing": "\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }", "error": "\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }", "insert": "\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }", "insertEmpty": "\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error\n            } else {\n                // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error\n            }\n        }\n        return el;\n    }", "insertForm": "\n    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name());\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }", "insertNode": "\n    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }", "pop": "\n    Element pop() {\n        // todo - dev, remove validation check\n        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n            Validate.isFalse(true, \"pop td not in cell\");\n        if (stack.peekLast().nodeName().equals(\"html\"))\n            Validate.isFalse(true, \"popping html!\");\n        return stack.pollLast();\n    }", "push": "\n    void push(Element element) {\n        stack.add(element);\n    }", "getStack": "\n    DescendableLinkedList<Element> getStack() {\n        return stack;\n    }", "onStack": "\n    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }", "isElementInQueue": "\n    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n        Iterator<Element> it = queue.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }", "getFromStack": "\n    Element getFromStack(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }", "removeFromStack": "\n    boolean removeFromStack(Element el) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                return true;\n            }\n        }\n        return false;\n    }", "popStackToClose": "\n    void popStackToClose(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                it.remove();\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }", "popStackToBefore": "\n    void popStackToBefore(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }", "clearStackToTableContext": "\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }", "clearStackToTableBodyContext": "\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }", "clearStackToTableRowContext": "\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }", "clearStackToContext": "\n    private void clearStackToContext(String... nodeNames) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                it.remove();\n        }\n    }", "aboveOnStack": "\n    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                return it.next();\n            }\n        }\n        return null;\n    }", "insertOnStackAfter": "\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }", "replaceOnStack": "\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }", "replaceInQueue": "\n    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.remove(i);\n        queue.add(i, in);\n    }", "resetInsertionMode": "\n    void resetInsertionMode() {\n        boolean last = false;\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element node = it.next();\n            if (!it.hasNext()) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }", "inSpecificScope": "\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n    }", "inScope": "\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, null);\n    }", "inListItemScope": "\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, new String[]{\"ol\", \"ul\"});\n    }", "inButtonScope": "\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, new String[]{\"button\"});\n    }", "inTableScope": "\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, new String[]{\"html\", \"table\"}, null);\n    }", "inSelectScope": "\n    boolean inSelectScope(String targetName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element el = it.next();\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, \"optgroup\", \"option\")) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }", "setHeadElement": "\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }", "getHeadElement": "\n    Element getHeadElement() {\n        return headElement;\n    }", "isFosterInserts": "\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }", "setFosterInserts": "\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }", "getFormElement": "\n    FormElement getFormElement() {\n        return formElement;\n    }", "setFormElement": "\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }", "newPendingTableCharacters": "\n    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<Token.Character>();\n    }", "getPendingTableCharacters": "\n    List<Token.Character> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }", "setPendingTableCharacters": "\n    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n        this.pendingTableCharacters = pendingTableCharacters;\n    }", "generateImpliedEndTags": "\n    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n                StringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\n            pop();\n    }", "isSpecial": "\n    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.nodeName();\n        return StringUtil.in(name, \"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n                \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n                \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n                \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n                \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n                \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n                \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n                \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\");\n    }", "pushActiveFormattingElements": "\n    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        Iterator<Element> iter = formattingElements.descendingIterator();\n        while (iter.hasNext()) {\n            Element el =  iter.next();\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                iter.remove();\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }", "isSameFormattingElement": "\n    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }", "reconstructFormattingElements": "\n    void reconstructFormattingElements() {\n        int size = formattingElements.size();\n        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n            return;\n\n        Element entry = formattingElements.getLast();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.add(pos, newEl);\n            formattingElements.remove(pos + 1);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }", "clearFormattingElementsToLastMarker": "\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = formattingElements.peekLast();\n            formattingElements.removeLast();\n            if (el == null)\n                break;\n        }\n    }", "removeFromActiveFormattingElements": "\n    void removeFromActiveFormattingElements(Element el) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                break;\n            }\n        }\n    }", "isInActiveFormattingElements": "\n    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }", "getActiveFormattingElement": "\n    Element getActiveFormattingElement(String nodeName) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }", "replaceActiveFormattingElement": "\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }", "insertMarkerToFormattingElements": "\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }", "insertInFosterParent": "\n    void insertInFosterParent(Node in) {\n        Element fosterParent = null;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }", "toString": "\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }"}