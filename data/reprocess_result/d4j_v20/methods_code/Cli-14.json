{"canProcess": "\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        // if arg does not require bursting\n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        // filter\n        final Map tailMap = optionMap.tailMap(arg);\n\n        // check if bursting is required\n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (commandLine.looksLikeOption(arg)) {\n            return false;\n        }\n\n        // anonymous argument(s) means we can process it\n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }", "getPrefixes": "\n    public Set getPrefixes() {\n        return prefixes;\n    }", "getTriggers": "\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }", "process": "\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (commandLine.looksLikeOption(arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }", "validate": "\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n            if (validate) {\n                option.validate(commandLine);\n            }\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }", "getPreferredName": "\n    public String getPreferredName() {\n        return name;\n    }", "getDescription": "\n    public String getDescription() {\n        return description;\n    }", "appendUsage": "\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }", "helpLines": "\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }", "getOptions": "\n    public List getOptions() {\n        return options;\n    }", "getAnonymous": "\n    public List getAnonymous() {\n        return anonymous;\n    }", "findOption": "\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }", "getMinimum": "\n    public int getMinimum() {\n        return minimum;\n    }", "getMaximum": "\n    public int getMaximum() {\n        return maximum;\n    }", "isRequired": "\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }", "defaults": "\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }", "getInstance": "\n    public static final Comparator getInstance() {\n        return instance;\n    }", "compare": "\n    public int compare(final Object o1,\n                       final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }"}