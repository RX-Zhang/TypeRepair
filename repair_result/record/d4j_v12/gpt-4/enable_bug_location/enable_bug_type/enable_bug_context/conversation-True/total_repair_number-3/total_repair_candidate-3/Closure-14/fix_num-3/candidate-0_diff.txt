--- 
+++ 
@@ -44,7 +44,6 @@
       } else {
         return computeFollowNode(fromNode, parent, cfa);
       }
-      break;
     case Token.FOR:
       if (NodeUtil.isForIn(parent)) {
         return parent;
@@ -58,19 +57,20 @@
       // If we are coming out of the TRY block...
       if (parent.getFirstChild() == node) {
         if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
-          return computeFallThrough(parent.getLastChild());
+          // Changed here: use computeFallThrough(node.getNext()) instead of computeFallThrough(parent.getLastChild())
+          return computeFallThrough(node.getNext());
         } else { // and have no FINALLY.
           return computeFollowNode(fromNode, parent, cfa);
         }
       // CATCH block.
-      } else if (NodeUtil.getCatchBlock(parent) == node){
+      } else if (NodeUtil.getCatchBlock(parent) == node) {
         if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.
           return computeFallThrough(node.getNext());
         } else {
           return computeFollowNode(fromNode, parent, cfa);
         }
       // If we are coming out of the FINALLY block...
-      } else if (parent.getLastChild() == node){
+      } else if (parent.getLastChild() == node) {
         if (cfa != null) {
           for (Node finallyNode : cfa.finallyMap.get(parent)) {
             cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
@@ -96,3 +96,4 @@
     return computeFollowNode(fromNode, parent, cfa);
   }
 }
+
