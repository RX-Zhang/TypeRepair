--- 
+++ 
@@ -53,6 +53,11 @@
         }
         hNew = initializeStep(forward, getOrder(), scale,
                               stepStart, y, yDotK[0], yTmp, yDotK[1]);
+        // Fix: constrain the initial step size hNew to be smaller than the integration interval 
+        final double maxStep = FastMath.abs(t - stepStart);
+        if (FastMath.abs(hNew) > maxStep) {
+          hNew = forward ? maxStep : -maxStep;
+        }
         firstTime = false;
       }
 
@@ -87,8 +92,8 @@
       if (error >= 1.0) {
         // reject the step and attempt to reduce error by stepsize control
         final double factor =
-            FastMath.min(maxGrowth,
-                         FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
+            FastMath.min(getMaxGrowth(),
+                         FastMath.max(getMinReduction(), getSafety() * FastMath.pow(error, exp)));
         hNew = filterStep(stepSize * factor, forward, false);
       }
 
@@ -113,7 +118,7 @@
 
         // stepsize control for next step
         final double factor =
-            FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
+            FastMath.min(getMaxGrowth(), FastMath.max(getMinReduction(), getSafety() * FastMath.pow(error, exp)));
         final double  scaledH    = stepSize * factor;
         final double  nextT      = stepStart + scaledH;
         final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
@@ -136,3 +141,4 @@
   resetInternalState();
 
 }
+
