--- 
+++ 
@@ -11,6 +11,7 @@
         double ta = t0;
         double ga = g0;
         double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
+
         for (int i = 0; i < n; ++i) {
 
             // evaluate handler value at the end of the substep
@@ -22,15 +23,14 @@
             if (g0Positive ^ (gb >= 0)) {
                 // there is a sign change: an event is expected during this step
 
-                    // this is a corner case:
-                    // - there was an event near ta,
-                    // - there is another event between ta and tb
-                    // - when ta was computed, convergence was reached on the "wrong side" of the interval
-                    // this implies that the real sign of ga is the same as gb, so we need to slightly
-                    // shift ta to make sure ga and gb get opposite signs and the solver won't complain
-                    // about bracketing
-                        // this should never happen
-                     
+                // fix for the corner case:
+                // If ga and gb have same sign, need to shift ta slightly
+                if ((ga >= 0) == (gb >= 0)) {
+                    ta += (forward ? convergence : -convergence);
+                    interpolator.setInterpolatedTime(ta);
+                    ga = handler.g(ta, interpolator.getInterpolatedState());
+                }
+
                 // variation direction, with respect to the integration direction
                 increasing = gb >= ga;
 
@@ -95,3 +95,4 @@
     }
 
 }
+
