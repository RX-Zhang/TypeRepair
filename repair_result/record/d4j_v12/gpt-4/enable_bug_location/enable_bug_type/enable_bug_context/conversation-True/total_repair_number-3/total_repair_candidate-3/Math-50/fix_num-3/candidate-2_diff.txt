--- 
+++ 
@@ -42,7 +42,7 @@
 
         // Update the bounds with the new approximation.
         if (f1 * fx < 0) {
-            // The value of x1 has switched to the other bound, thus inverting
+            // The value of x0 has switched to the other bound, thus inverting
             // the interval.
             x0 = x1;
             f0 = f1;
@@ -58,8 +58,8 @@
             case REGULA_FALSI:
                 // Nothing.
                 if (x == x1) {
-                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
-                    f0 = computeObjectiveValue(x0);
+                    x1 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x1), atol));
+                    f1 = computeObjectiveValue(x1);
                 }
                 break;
             default:
@@ -68,8 +68,12 @@
             }
         }
         // Update from [x0, x1] to [x0, x].
-        x1 = x;
-        f1 = fx;
+        // Note: after the adjustment in REGULA_FALSI, x1 and f1 are updated there,
+        // else we need to update them here.
+        if (!(method == Method.REGULA_FALSI && x == x1)) {
+            x1 = x;
+            f1 = fx;
+        }
 
         // If the function value of the last approximation is too small,
         // given the function value accuracy, then we can't get closer to
@@ -124,3 +128,4 @@
         }
     }
 }
+
