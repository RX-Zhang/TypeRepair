--- 
+++ 
@@ -42,7 +42,7 @@
 
         // Update the bounds with the new approximation.
         if (f1 * fx < 0) {
-            // The value of x1 has switched to the other bound, thus inverting
+            // The value of x0 has switched to the other bound, thus inverting
             // the interval.
             x0 = x1;
             f0 = f1;
@@ -58,8 +58,8 @@
             case REGULA_FALSI:
                 // Nothing.
                 if (x == x1) {
-                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
-                    f0 = computeObjectiveValue(x0);
+                    x1 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x1), atol));
+                    f1 = computeObjectiveValue(x1);
                 }
                 break;
             default:
@@ -67,9 +67,9 @@
                 throw new MathInternalError();
             }
         }
-        // Update from [x0, x1] to [x0, x].
-        x1 = x;
-        f1 = fx;
+        // Update from [x0, x1] to [x, x1].
+        x0 = x;
+        f0 = fx;
 
         // If the function value of the last approximation is too small,
         // given the function value accuracy, then we can't get closer to
@@ -124,3 +124,4 @@
         }
     }
 }
+
