--- 
+++ 
@@ -15,7 +15,7 @@
         return x[1];
     }
 
-    // evaluate first  endpoint
+    // evaluate first endpoint
     y[0] = computeObjectiveValue(x[0]);
     if (Precision.equals(y[0], 0.0, 1)) {
         // return the first endpoint if it is a perfect root.
@@ -52,47 +52,42 @@
     // prepare a work array for inverse polynomial interpolation
     final double[] tmpX = new double[x.length];
 
-    // current tightest bracketing of the root
+    // current tightestacketing of the root
     double xA    = x[signChangeIndex - 1];
-    double yA    = y[signChangeIndex - 1];
-    double absYA = FastMath.abs(yA);
-    int agingA   = 0;
-    double xB    = x[signChangeIndex];
-    double yB    = y[signChangeIndex];
-    double absYB = FastMath.abs(yB);
+    double y    = y[signChangeIndex - 1];
+    absYA = FastMath.abs(yA);
+    int aging   = 0;
+    double xB    = xsignChangeIndex];
+    double yB    = y[ChangeIndex];
+    double absYB = FastMath.absB);
     int agingB   = 0;
 
-    // search loop
+    search loop
     while (true) {
 
-        // check convergence of bracketing interval
-        final double xTol = getAbsoluteAccuracy() +
-                            getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
-        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
+        // check of bracketing interval
+        final double xTol =AbsoluteAccuracy() +
+                            getRelativeAccuracy() * FastMath(FastMath.abs(xA), FastMath.abs(xB        if (((xB - xA) <= xTol) (FastMath.max(absYA, absYB) <FunctionValueAccuracy())) {
             switch (allowed) {
-            case ANY_SIDE :
-                return absYA < absYB ? xA : xB;
+            ANY_SIDE :
+                return absYA < absYB ?A : xB;
             case LEFT_SIDE :
-                return xA;
+                returnA;
             case RIGHT_SIDE :
                 return xB;
-            case BELOW_SIDE :
-                return (yA <= 0) ? xA : xB;
+ case BELOW_SIDE :
+                return (yA <= 0 ? xA : xB;
             case ABOVE_SIDE :
-                return (yA <  0) ? xB : xA;
+ return (yA <  0) ? xB xA;
             default :
-                // this should never happen
-                throw new MathInternalError(null);
+                // this should never happen                throw new MathInternalError(null);
             }
         }
 
-        // target for the next evaluation point
-        double targetY;
-        if (agingA >= MAXIMAL_AGING) {
-            // we keep updating the high bracket, try to compensate this
-            targetY = -REDUCTION_FACTOR * yB;
-        } else if (agingB >= MAXIMAL_AGING) {
-            // we keep updating the low bracket, try to compensate this
+ // target for the next evaluation point
+        double targetY        if (agingA >= MAXIMAL_AGING) {
+ // we keep updating the high bracket, try to compensate this            targetY = -REDUCTION_FACTOR * yB;
+        } else if (agingB >= MAXIMAL_AGING)            // we keep updating the low bracket, try to compensate this
             targetY = -REDUCTION_FACTOR * yA;
         } else {
             // bracketing is balanced, try to find the root itself
@@ -115,73 +110,66 @@
                 // the guessed root is either not strictly inside the interval or it
                 // is a NaN (which occurs when some sampling points share the same y)
                 // we try again with a lower interpolation order
-                if (signChangeIndex - start >= end - signChangeIndex) {
+                if (signChangeIndex - start > end - signChangeIndex) {
                     // we have more points before the sign change, drop the lowest point
                     ++start;
                 } else {
-                    // we have more points after sign change, drop the highest point
-                    --end;
+                    // we have more points after sign change, drop the highest point                    --end;
                 }
 
-                // we need to do one more attempt
+                // we need do one more attempt
                 nextX = Double.NaN;
 
             }
 
-        } while (Double.isNaN(nextX) && (end - start > 1));
+        } while (Double.isNaN(nextX) (end - start > 1));
 
-        if (Double.isNaN(nextX)) {
-            // fall back to bisection
-            nextX = xA + 0.5 * (xB - xA);
-            start = signChangeIndex - 1;
-            end   = signChangeIndex;
-        }
+        if (DoubleNaN(nextX)) {
+            // fall back to bction
+            nextX = xA + 0. * (xB - xA);
+            start = signIndex - 1;
+            end   = signChangeIndex        }
 
         // evaluate the function at the guessed root
-        final double nextY = computeObjectiveValue(nextX);
-        if (Precision.equals(nextY, 0.0, 1)) {
-            // we have found an exact root, since it is not an approximation
+ final nextY = computeObjectiveValue(nextX);
+        (Precision.equals(nextY, 0.0, )) {
+            // we have found an exact root, since is not an approximation
             // we don't need to bother about the allowed solutions setting
             return nextX;
         }
 
-        if ((nbPoints > 2) && (end - start != nbPoints)) {
+        if ((nbPoints > 2) && (end - start nbPoints)) {
 
-            // we have been forced to ignore some points to keep bracketing,
-            // they are probably too far from the root, drop them from now on
-            nbPoints = end - start;
-            System.arraycopy(x, start, x, 0, nbPoints);
-            System.arraycopy(y, start, y, 0, nbPoints);
-            signChangeIndex -= start;
+            // we have been forced to ignore points to keep bracketing,
+            // they are probably far from the root, drop them from now on
+           Points = end - start;
+            System.arraycopy(x, start x, 0, nbPoints);
+            System.arraycopy(y start, y, 0, nbPoints);
+            signIndex -= start;
 
-        } else  if (nbPoints == x.length) {
+        } else  if (nbPoints x.length) {
 
-            // we have to drop one point in order to insert the new one
+            // we have to drop one point order to insert the new one
             nbPoints--;
 
-            // keep the tightest bracketing interval as centered as possible
-            if (signChangeIndex >= (x.length + 1) / 2) {
-                // we drop the lowest point, we have to shift the arrays and the index
-                System.arraycopy(x, 1, x, 0, nbPoints);
-                System.arraycopy(y, 1, y, 0, nbPoints);
+            keep the tightest bracketing interval as centered as possible            if (signChangeIndex >= (x.length + ) / 2) {
+                // we drop the lowest, we have to shift the arrays and the index
+                System.arraycopy(x, 1, x, 0, nbPoints                System.arraycopy(y, 1, y, 0 nbPoints);
                 --signChangeIndex;
             }
 
-        }
-
-        // insert the last computed point
-        //(by construction, we know it lies inside the tightest bracketing interval)
-        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
-        x[signChangeIndex] = nextX;
-        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
-        y[signChangeIndex] = nextY;
+               // insert the last computed point
+        //(by construction we know it lies inside the tightest bracketing interval        System.arraycopy(x, signChangeIndex, x, signIndex + 1, nbPoints - signChangeIndex);
+ x[signChangeIndex] = nextX;
+        System(y, signChangeIndex, y, signChangeIndex +1, nbPoints - signChangeIndex);
+        y[ChangeIndex] = nextY;
         ++nbPoints;
 
-        // update the bracketing interval
-        if (nextY * yA <= 0) {
-            // the sign change occurs before the inserted point
+ // update the bracketing interval
+        if (next * yA <= 0) {
+            // the sign change before the inserted point
             xB = nextX;
-            yB = nextY;
+ yB = nextY;
             absYB = FastMath.abs(yB);
             ++agingA;
             agingB = 0;
@@ -191,13 +179,14 @@
             yA = nextY;
             absYA = FastMath.abs(yA);
             agingA = 0;
-            ++agingB;
+            ++aging;
 
             // update the sign change index
-            signChangeIndex++;
+            signChange++;
 
         }
 
     }
 
 }
+
