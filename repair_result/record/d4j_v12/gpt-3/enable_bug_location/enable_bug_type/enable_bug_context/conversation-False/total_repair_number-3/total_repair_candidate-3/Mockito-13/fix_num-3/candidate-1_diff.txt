--- 
+++ 
@@ -1,4 +1,12 @@
 public Object handle(Invocation invocation) throws Throwable {
+    if (invocationContainerImpl == null) {
+        throw new IllegalStateException("InvocationContainerImpl is not initialized.");
+    }
+
+    if (mockingProgress == null) {
+        throw new IllegalStateException("MockingProgress is not initialized.");
+    }
+
     if (invocationContainerImpl.hasAnswersForStubbing()) {
         // stubbing voids with stubVoid() or doAnswer() style
         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
@@ -6,6 +14,7 @@
         invocationContainerImpl.setMethodForStubbing(invocationMatcher);
         return null;
     }
+    
     VerificationMode verificationMode = mockingProgress.pullVerificationMode();
 
     InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
@@ -23,6 +32,8 @@
             return null;
             // this means there is an invocation on a different mock. Re-adding verification mode 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
+        } else {
+            throw new RuntimeException("Verification mode mismatch: expected mock does not match the invoked mock.");
         }
     }
     
@@ -47,3 +58,4 @@
         return ret;
     }
 }
+
