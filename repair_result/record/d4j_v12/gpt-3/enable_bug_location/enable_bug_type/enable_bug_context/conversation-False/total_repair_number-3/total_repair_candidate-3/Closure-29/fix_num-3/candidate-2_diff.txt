--- 
+++ 
@@ -16,14 +16,7 @@
         return false;
       }
 
-      // NOTE(nicksantos): This pass's object-splitting algorithm has
-      // a blind spot. It assumes that if a property isn't defined on an
-      // object, then the value is undefined. This is not true, because
-      // Object.prototype can have arbitrary properties on it.
-      //
-      // We short-circuit this problem by bailing out if we see a reference
-      // to a property that isn't defined on the object literal. This
-      // isn't a perfect algorithm, but it should catch most cases.
+      // Short-circuiting for properties not defined on the object literal.
       continue;
     }
 
@@ -43,14 +36,8 @@
       return false;
     }
 
-    // Make sure that the value is not self-refential. IOW,
+    // Make sure that the value is not self-referential. IOW,
     // disallow things like x = {b: x.a}.
-    //
-    // TODO: Only exclude unorderable self-referential
-    // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
-    // but x = {a: 1, b: x.a} is.
-    //
-    // Also, ES5 getters/setters aren't handled by this pass.
     for (Node child = val.getFirstChild(); child != null;
          child = child.getNext()) {
       if (child.isGetterDef() ||
@@ -58,7 +45,6 @@
         // ES5 get/set not supported.
         return false;
       }
-
 
       Node childVal = child.getFirstChild();
       // Check if childVal is the parent of any of the passed in
@@ -76,7 +62,6 @@
       }
     }
 
-
     // We have found an acceptable object literal assignment. As
     // long as there are no other assignments that mess things up,
     // we can inline.
@@ -84,3 +69,4 @@
   }
   return ret;
 }
+
