--- 
+++ 
@@ -8,7 +8,7 @@
         Element meta = doc.select("meta[http-equiv=content-type], meta[charset]").first();
         if (meta != null) { // if not found, will keep utf-8 as best attempt
             String foundCharset = meta.hasAttr("http-equiv") ? getCharsetFromContentType(meta.attr("content")) : meta.attr("charset");
-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharsetIgnoreCase(defaultCharset)) { // need to re-decode
                 charsetName = foundCharset;
                 byteData.rewind();
                 docData = Charset.forName(foundCharset).decode(byteData).toString();
@@ -16,16 +16,19 @@
             }
         }
     } else { // specified by content type header (or by user on file load)
-        Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML");
+        Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. to null to attempt to detect from HTML");
         docData = Charset.forName(charsetName).decode(byteData).toString();
     }
     if (doc == null) {
         // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present
         // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight
         // into head mode
-
+        if (docData.length() > 0 && docData.charAt(0) == '\uFEFF') {
+            docData = docData.substring(1);
+        }
         doc = parser.parseInput(docData, baseUri);
         doc.outputSettings().charset(charsetName);
     }
     return doc;
 }
+
