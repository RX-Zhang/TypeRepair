--- 
+++ 
@@ -1,8 +1,9 @@
+```java
 boolean process(Token t, TreeBuilder tb) {
     switch (t.type) {
         case Character: {
             Token.Character c = t.asCharacter();
-            if (c.getData().equals(nullString)) {
+            if (c.getData() == nullString) {
                 // todo confirm that check
                 tb.error(this);
                 return false;
@@ -257,260 +258,4 @@
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
-                tb.reconstructFormattingElements();
-                tb.framesetOk(false);
-                handleRawtext(startTag, tb);
-            } else if (name.equals("iframe")) {
-                tb.framesetOk(false);
-                handleRawtext(startTag, tb);
-            } else if (name.equals("noembed")) {
-                // also handle noscript if script enabled
-                handleRawtext(startTag, tb);
-            } else if (name.equals("select")) {
-                tb.reconstructFormattingElements();
-                tb.insert(startTag);
-                tb.framesetOk(false);
-
-                TreeBuilderState state = tb.state();
-                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
-                    tb.transition(InSelectInTable);
-                else
-                    tb.transition(InSelect);
-            } else if (StringUtil.in("optgroup", "option")) {
-                if (tb.currentElement().nodeName().equals("option"))
-                    tb.process(new Token.EndTag("option"));
-                tb.reconstructFormattingElements();
-                tb.insert(startTag);
-            } else if (StringUtil.in("rp", "rt")) {
-                if (tb.inScope("ruby")) {
-                    tb.generateImpliedEndTags();
-                    if (!tb.currentElement().nodeName().equals("ruby")) {
-                        tb.error(this);
-                        tb.popStackToBefore("ruby"); // i.e. close up to but not include name
-                    }
-                    tb.insert(startTag);
-                }
-            } else if (name.equals("math")) {
-                tb.reconstructFormattingElements();
-                // todo: handle A start tag whose tag name is "math" (i.e. foreign, mathml)
-                tb.insert(startTag);
-                tb.tokeniser.acknowledgeSelfClosingFlag();
-            } else if (name.equals("svg")) {
-                tb.reconstructFormattingElements();
-                // todo: handle A start tag whose tag name is "svg" (xlink, svg)
-                tb.insert(startTag);
-                tb.tokeniser.acknowledgeSelfClosingFlag();
-            } else if (StringUtil.in(name,
-                    "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr")) {
-                tb.error(this);
-                return false;
-            } else {
-                tb.reconstructFormattingElements();
-                tb.insert(startTag);
-            }
-            break;
-
-        case EndTag:
-            Token.EndTag endTag = t.asEndTag();
-            name = endTag.name();
-            if (name.equals("body")) {
-                if (!tb.inScope("body")) {
-                    tb.error(this);
-                    return false;
-                } else {
-                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
-                    tb.transition(AfterBody);
-                }
-            } else if (name.equals("html")) {
-                boolean notIgnored = tb.process(new Token.EndTag("body"));
-                if (notIgnored)
-                    return tb.process(endTag);
-            } else if (StringUtil.in(name,
-                    "address", "article", "aside", "blockquote", "button", "center", "details", "dir", "div",
-                    "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "menu",
-                    "nav", "ol", "pre", "section", "summary", "ul")) {
-                // todo: refactor these lookups
-                if (!tb.inScope(name)) {
-                    // nothing to close
-                    tb.error(this);
-                    return false;
-                } else {
-                    tb.generateImpliedEndTags();
-                    if (!tb.currentElement().nodeName().equals(name))
-                        tb.error(this);
-                    tb.popStackToClose(name);
-                }
-            } else if (name.equals("form")) {
-                Element currentForm = tb.getFormElement();
-                tb.setFormElement(null);
-                if (currentForm == null || !tb.inScope(name)) {
-                    tb.error(this);
-                    return false;
-                } else {
-                    tb.generateImpliedEndTags();
-                    if (!tb.currentElement().nodeName().equals(name))
-                        tb.error(this);
-                    // remove currentForm from stack. will shift anything under up.
-                    tb.removeFromStack(currentForm);
-                }
-            } else if (name.equals("p")) {
-                if (!tb.inButtonScope(name)) {
-                    tb.error(this);
-                    tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>
-                    return tb.process(endTag);
-                } else {
-                    tb.generateImpliedEndTags(name);
-                    if (!tb.currentElement().nodeName().equals(name))
-                        tb.error(this);
-                    tb.popStackToClose(name);
-                }
-            } else if (name.equals("li")) {
-                if (!tb.inListItemScope(name)) {
-                    tb.error(this);
-                    return false;
-                } else {
-                    tb.generateImpliedEndTags(name);
-                    if (!tb.currentElement().nodeName().equals(name))
-                        tb.error(this);
-                    tb.popStackToClose(name);
-                }
-            } else if (StringUtil.in(name, "dd", "dt")) {
-                if (!tb.inScope(name)) {
-                    tb.error(this);
-                    return false;
-                } else {
-                    tb.generateImpliedEndTags(name);
-                    if (!tb.currentElement().nodeName().equals(name))
-                        tb.error(this);
-                    tb.popStackToClose(name);
-                }
-            } else if (StringUtil.in(name, "h1", "h2", "h3", "h4", "h5", "h6")) {
-                if (!tb.inScope(new String[]{"h1", "h2", "h3", "h4", "h5", "h6"})) {
-                    tb.error(this);
-                    return false;
-                } else {
-                    tb.generateImpliedEndTags(name);
-                    if (!tb.currentElement().nodeName().equals(name))
-                        tb.error(this);
-                    tb.popStackToClose("h1", "h2", "h3", "h4", "h5", "h6");
-                }
-            } else if (name.equals("sarcasm")) {
-                // *sigh*
-                return anyOtherEndTag(t, tb);
-            } else if (StringUtil.in(name,
-                    "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u")) {
-                // Adoption Agency Algorithm.
-                OUTER:
-                for (int i = 0; i < 8; i++) {
-                    Element formatEl = tb.getActiveFormattingElement(name);
-                    if (formatEl == null)
-                        return anyOtherEndTag(t, tb);
-                    else if (!tb.onStack(formatEl)) {
-                        tb.error(this);
-                        tb.removeFromActiveFormattingElements(formatEl);
-                        return true;
-                    } else if (!tb.inScope(formatEl.nodeName())) {
-                        tb.error(this);
-                        return false;
-                    } else if (tb.currentElement() != formatEl)
-                        tb.error(this);
-
-                    Element furthestBlock = null;
-                    Element commonAncestor = null;
-                    boolean seenFormattingElement = false;
-                    LinkedList<Element> stack = tb.getStack();
-                    for (int si = 0; si < stack.size(); si++) {
-                        Element el = stack.get(si);
-                        if (el == formatEl) {
-                            commonAncestor = stack.get(si - 1);
-                            seenFormattingElement = true;
-                        } else if (seenFormattingElement && tb.isSpecial(el)) {
-                            furthestBlock = el;
-                            break;
-                        }
-                    }
-                    if (furthestBlock == null) {
-                        tb.popStackToClose(formatEl.nodeName());
-                        tb.removeFromActiveFormattingElements(formatEl);
-                        return true;
-                    }
-
-                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
-                    // does that mean: int pos of format el in list?
-                    Element node = furthestBlock;
-                    Element lastNode = furthestBlock;
-                    INNER:
-                    for (int j = 0; j < 3; j++) {
-                        if (tb.onStack(node))
-                            node = tb.aboveOnStack(node);
-                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
-                            tb.removeFromStack(node);
-                            continue INNER;
-                        } else if (node == formatEl)
-                            break INNER;
-
-                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
-                        tb.replaceActiveFormattingElement(node, replacement);
-                        tb.replaceOnStack(node, replacement);
-                        node = replacement;
-
-                        if (lastNode == furthestBlock) {
-                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
-                            // not getting how this bookmark both straddles the element above, but is inbetween here...
-                        }
-                        if (lastNode.parent() != null)
-                            lastNode.remove();
-                        node.appendChild(lastNode);
-
-                        lastNode = node;
-                    }
-
-                    if (StringUtil.in(commonAncestor.nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {
-                        if (lastNode.parent() != null)
-                            lastNode.remove();
-                        tb.insertInFosterParent(lastNode);
-                    } else {
-                        if (lastNode.parent() != null)
-                            lastNode.remove();
-                        commonAncestor.appendChild(lastNode);
-                    }
-
-                    Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());
-                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);
-                    for (Node childNode : childNodes) {
-                        adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.
-                    }
-                    furthestBlock.appendChild(adopter);
-                    tb.removeFromActiveFormattingElements(formatEl);
-                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
-                    tb.removeFromStack(formatEl);
-                    tb.insertOnStackAfter(furthestBlock, adopter);
-                }
-            } else if (StringUtil.in(name, "applet", "marquee", "object")) {
-                if (!tb.inScope("name")) {
-                    if (!tb.inScope(name)) {
-                        tb.error(this);
-                        return false;
-                    }
-                    tb.generateImpliedEndTags();
-                    if (!tb.currentElement().nodeName().equals(name))
-                        tb.error(this);
-                    tb.popStackToClose(name);
-                    tb.clearFormattingElementsToLastMarker();
-                }
-            } else if (name.equals("br")) {
-                tb.error(this);
-                tb.process(new Token.StartTag("br"));
-                return false;
-            } else {
-                return anyOtherEndTag(t, tb);
-            }
-
-            break;
-        case EOF:
-            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
-            // stop parsing
-            break;
-    }
-    return true;
-}
+
