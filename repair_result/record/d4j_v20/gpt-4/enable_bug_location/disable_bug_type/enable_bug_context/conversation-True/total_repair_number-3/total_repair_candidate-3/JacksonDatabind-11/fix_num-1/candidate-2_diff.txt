--- 
+++ 
@@ -15,28 +15,17 @@
         if (actualType != null) {
             return actualType;
         }
+
+        // Fix: attempt to resolve using constructType with current context to resolve bound types
+        Type[] bounds = type.getBounds();
+        if (bounds != null && bounds.length > 0) {
+            // Add placeholder before constructing to handle recursive types
+            context._addPlaceholder(name);
+            return _constructType(bounds[0], context);
+        }
     }
 
-    /* 29-Jan-2010, tatu: We used to throw exception here, if type was
-     *   bound: but the problem is that this can occur for generic "base"
-     *   method, overridden by sub-class. If so, we will want to ignore
-     *   current type (for method) since it will be masked.
-     */
-    Type[] bounds = type.getBounds();
+    // If no context and no bounds, fallback to unknown type
+    return _unknownType();
+}
 
-    // With type variables we must use bound information.
-    // Theoretically this gets tricky, as there may be multiple
-    // bounds ("... extends A & B"); and optimally we might
-    // want to choose the best match. Also, bounds are optional;
-    // but here we are lucky in that implicit "Object" is
-    // added as bounds if so.
-    // Either way let's just use the first bound, for now, and
-    // worry about better match later on if there is need.
-
-    /* 29-Jan-2010, tatu: One more problem are recursive types
-     *   (T extends Comparable<T>). Need to add "placeholder"
-     *   for resolution to catch those.
-     */
-    context._addPlaceholder(name);
-    return _constructType(bounds[0], context);
-}
