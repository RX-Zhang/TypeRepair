--- 
+++ 
@@ -5,46 +5,67 @@
     if (inAvail < 0) {
         eof = true;
     }
-    for (int i = 0; i < inAvail; i++) {
-        if (buffer == null || buffer.length - pos < decodeSize) {
-            resizeBuffer();
-        }
-        byte b = in[inPos++];
-        if (b == PAD) {
-            // We're done.
-            eof = true;
-            break;
-        } else {
-            if (b >= 0 && b < DECODE_TABLE.length) {
-                int result = DECODE_TABLE[b];
-                if (result >= 0) {
-                    modulus = (++modulus) % 4;
-                    x = (x << 6) + result;
-                    if (modulus == 0) {
-                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
-                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
-                        buffer[pos++] = (byte) (x & MASK_8BITS);
+    try {
+        for (int i = 0; i < inAvail; i++) {
+            if (buffer == null || buffer.length - pos < decodeSize) {
+                resizeBuffer();
+            }
+            // Boundary check to avoid ArrayIndexOutOfBoundsException
+            if (inPos >= in.length) {
+                eof = true;
+                break;
+            }
+            byte b = in[inPos++];
+            if (b == PAD) {
+                // We're done.
+                eof = true;
+                break;
+            } else {
+                if (b >= 0 && b < DECODE_TABLE.length) {
+                    int result = DECODE_TABLE[b];
+                    if (result >= 0) {
+                        modulus = (++modulus) % 4;
+                        x = (x << 6) + result;
+                        if (modulus == 0) {
+                            if (buffer == null || pos + 3 > buffer.length) {
+                                resizeBuffer();
+                            }
+                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
+                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
+                            buffer[pos++] = (byte) (x & MASK_8BITS);
+                        }
                     }
                 }
             }
         }
-    }
 
-    // Two forms of EOF as far as base64 decoder is concerned: actual
-    // EOF (-1) and first time '=' character is encountered in stream.
-    // This approach makes the '=' padding characters completely optional.
-    if (eof && modulus != 0) {
-        
-        x = x << 6;
-        switch (modulus) {
-            case 2 :
-                x = x << 6;
-                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
-                break;
-            case 3 :
-                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
-                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
-                break;
+        // Two forms of EOF as far as base64 decoder is concerned: actual
+        // EOF (-1) and first time '=' character is encountered in stream.
+        // This approach makes the '=' padding characters completely optional.
+        if (eof && modulus != 0) {
+            x = x << 6;
+            switch (modulus) {
+                case 2:
+                    if (buffer == null || pos + 1 > buffer.length) {
+                        resizeBuffer();
+                    }
+                    x = x << 6;
+                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
+                    break;
+                case 3:
+                    if (buffer == null || pos + 2 > buffer.length) {
+                        resizeBuffer();
+                    }
+                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
+                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
+                    break;
+            }
         }
+    } catch (ArrayIndexOutOfBoundsException | NullPointerException e) {
+        // Reset state to avoid corrupted internal state
+        reset();
+        eof = true;
+        throw new IllegalArgumentException("Invalid Base64 input data", e);
     }
 }
+
