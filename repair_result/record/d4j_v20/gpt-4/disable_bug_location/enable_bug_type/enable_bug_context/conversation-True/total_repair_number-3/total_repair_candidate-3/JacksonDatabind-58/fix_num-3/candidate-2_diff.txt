--- 
+++ 
@@ -6,13 +6,16 @@
     // need to ensure method is callable (for non-public)
     AnnotatedMember mutator = propDef.getNonConstructorMutator();
 
-    if (ctxt.canOverrideAccessModifiers()) {
-        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;
-        // never needed and attempts may cause problems on some platforms.
-        // !!! NOTE: should be handled better for 2.8 and later
-            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
+    if (mutator != null) {
+        if (ctxt.canOverrideAccessModifiers()) {
+            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;
+            // never needed and attempts may cause problems on some platforms.
+            if (!"cause".equals(propDef.getName()) || !Throwable.class.isAssignableFrom(beanDesc.getBeanClass())) {
+                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
+            }
+        }
     }
-    // note: this works since we know there's exactly one argument for methods
+
     BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),
             propType0, propDef.getWrapperName(),
             beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());
@@ -30,9 +33,12 @@
     if (mutator instanceof AnnotatedMethod) {
         prop = new MethodProperty(propDef, type, typeDeser,
                 beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);
-    } else {
+    } else if (mutator instanceof AnnotatedField) {
         prop = new FieldProperty(propDef, type, typeDeser,
                 beanDesc.getClassAnnotations(), (AnnotatedField) mutator);
+    } else {
+        // fallback, should not happen, but defensive
+        throw new IllegalArgumentException("Invalid mutator type for property: " + propDef.getName());
     }
     if (propDeser != null) {
         prop = prop.withValueDeserializer(propDeser);
@@ -48,3 +54,4 @@
     }
     return prop;
 }
+
