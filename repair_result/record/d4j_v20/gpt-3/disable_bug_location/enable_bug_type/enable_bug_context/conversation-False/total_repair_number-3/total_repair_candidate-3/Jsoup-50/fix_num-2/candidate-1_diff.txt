--- 
+++ 
@@ -3,6 +3,42 @@
     Document doc = null;
 
     // look for BOM - overrides any other header or input
+    // rewind buffer before checking BOM to ensure start from beginning
+    byteData.rewind();
+    if (byteData.remaining() >= 3) { // check UTF-8 BOM specifically 
+        if ((byteData.get(0) & 0xFF) == 0xEF && (byteData.get(1) & 0xFF) == 0xBB && (byteData.get(2) & 0xFF) == 0xBF) {
+            charsetName = "UTF-8";
+            // skip BOM bytes
+            byteData.position(3);
+        } else if (byteData.remaining() >= 4) {
+            // Check UTF-16BE BOM 0xFEFF
+            if ((byteData.get(0) & 0xFF) == 0xFE && (byteData.get(1) & 0xFF) == 0xFF) {
+                charsetName = "UTF-16BE";
+                byteData.position(2);
+            }
+            // Check UTF-16LE BOM 0xFFFE
+            else if ((byteData.get(0) & 0xFF) == 0xFF && (byteData.get(1) & 0xFF) == 0xFE) {
+                charsetName = "UTF-16LE";
+                byteData.position(2);
+            }
+            // Check UTF-32BE BOM 00 00 FE FF
+            else if ((byteData.get(0) & 0xFF) == 0x00 && (byteData.get(1) & 0xFF) == 0x00 && (byteData.get(2) & 0xFF) == 0xFE && (byteData.get(3) & 0xFF) == 0xFF) {
+                charsetName = "UTF-32BE";
+                byteData.position(4);
+            }
+            // Check UTF-32LE BOM FF FE 00 00
+            else if ((byteData.get(0) & 0xFF) == 0xFF && (byteData.get(1) & 0xFF) == 0xFE && (byteData.get(2) & 0xFF) == 0x00 && (byteData.get(3) & 0xFF) == 0x00) {
+                charsetName = "UTF-32LE";
+                byteData.position(4);
+            } else {
+                byteData.rewind();
+            }
+        } else {
+            byteData.rewind();
+        }
+    } else {
+        byteData.rewind();
+    }
 
     if (charsetName == null) { // determine from meta. safe parse as UTF-8
         // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">
@@ -34,18 +70,20 @@
         }
     } else { // specified by content type header (or by user on file load)
         Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML");
+        byteData.rewind();
         docData = Charset.forName(charsetName).decode(byteData).toString();
     }
+
     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {
-        byteData.rewind();
-        docData = Charset.forName(defaultCharset).decode(byteData).toString();
         docData = docData.substring(1);
         charsetName = defaultCharset;
         doc = null;
     }
+
     if (doc == null) {
         doc = parser.parseInput(docData, baseUri);
         doc.outputSettings().charset(charsetName);
     }
     return doc;
 }
+
