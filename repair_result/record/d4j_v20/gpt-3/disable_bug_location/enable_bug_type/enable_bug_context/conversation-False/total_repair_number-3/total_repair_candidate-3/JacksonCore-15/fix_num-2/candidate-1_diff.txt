--- 
+++ 
@@ -1,12 +1,9 @@
 public JsonToken nextToken() throws IOException
 {
-	//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken
-	// check for no buffered context _exposedContext - null
-	//If all the conditions matches then check for scalar / non-scalar property
-		//if not scalar and ended successfully, then return null
-		//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once
-		// then return null 
-    // Anything buffered?
+	// Check for _allowMultipleMatches - if false and at least one match found (_matchCount > 0),
+	// and no buffered tokens (_exposedContext == null), then stop further matches according to filter rules.
+
+    // First, if there are buffered tokens exposed, return tokens from there first.
     TokenFilterContext ctxt = _exposedContext;
 
     if (ctxt != null) {
@@ -19,56 +16,72 @@
             // all done with buffered stuff?
             if (ctxt == _headContext) {
                 _exposedContext = null;
-                if (ctxt.inArray()) {
-                    t = delegate.getCurrentToken();
-s this guaranteed to work without further checks?
-                      if (t != JsonToken.START_ARRAY) {
-                    _currToken = t;
-                    return t;
-                }
-
-                // Almost! Most likely still have the current token;
-                // with the sole exception of 
-                /*
-                t = delegate.getCurrentToken();
-                if (t != JsonToken.FIELD_NAME) {
-                    _currToken = t;
-                    return t;
-                }
-                */
+
+                // Need to handle possible situation where current token is still valid
+                // Note: delegate.getCurrentToken() may return null
+                JsonToken t2 = delegate.getCurrentToken();
+                if (t2 != JsonToken.START_ARRAY && t2 != JsonToken.START_OBJECT) {
+                    _currToken = t2;
+                    return t2;
+                }
+                // else fall through to continue normal token processing
                 break;
             }
-            // If not, traverse down the context chain
+            // If not done, traverse down the chain to find next token to read
             ctxt = _headContext.findChildOf(ctxt);
             _exposedContext = ctxt;
-            if (ctxt == null) { // should never occur
+            if (ctxt == null) {
                 throw _constructError("Unexpected problem: chain of filtered context broken");
             }
         }
     }
 
-    // If not, need to read more. If we got any:
+    // If multiple matches are not allowed and at least one match was found, and no buffering,
+    // then skip further matching tokens and return null
+    if (!_allowMultipleMatches && _matchCount > 0 && _exposedContext == null) {
+        // Skip tokens until matching end or EOF
+        while (true) {
+            JsonToken t = delegate.nextToken();
+            if (t == null) {
+                _currToken = null;
+                return null;
+            }
+            // If this token is structural end, and matches context, may end early
+            if (t.isStructEnd()) {
+                // If context stack is empty already, no more tokens to process
+                if (_headContext == null || _headContext.getParent() == null) {
+                    _currToken = null;
+                    return null;
+                }
+                // else move up context (simulate)
+                _headContext = _headContext.getParent();
+            }
+            // Keep skipping otherwise
+        }
+    }
+
+    // Otherwise, get next token from delegate
     JsonToken t = delegate.nextToken();
     if (t == null) {
-        // no strict need to close, since we have no state here
-        return (_currToken = t);
-    }
-
-    // otherwise... to include or not?
+        return (_currToken = null);
+    }
+
     TokenFilter f;
-    
+
     switch (t.id()) {
     case ID_START_ARRAY:
         f = _itemFilter;
         if (f == TokenFilter.INCLUDE_ALL) {
             _headContext = _headContext.createChildArrayContext(f, true);
-            return (_currToken = t);
-        }
-        if (f == null) { // does this occur?
-            delegate.skipChildren();
-            break;
-        }
-        // Otherwise still iffy, need to check
+            if (!_allowMultipleMatches) {
+                _matchCount++;
+            }
+            return (_currToken = t);
+        }
+        if (f == null) {
+            delegate.skipChildren();
+            break;
+        }
         f = _headContext.checkValue(f);
         if (f == null) {
             delegate.skipChildren();
@@ -80,11 +93,13 @@
         _itemFilter = f;
         if (f == TokenFilter.INCLUDE_ALL) {
             _headContext = _headContext.createChildArrayContext(f, true);
+            if (!_allowMultipleMatches) {
+                _matchCount++;
+            }
             return (_currToken = t);
         }
         _headContext = _headContext.createChildArrayContext(f, false);
-        
-        // Also: only need buffering if parent path to be included
+
         if (_includePath) {
             t = _nextTokenWithBuffering(_headContext);
             if (t != null) {
@@ -98,13 +113,15 @@
         f = _itemFilter;
         if (f == TokenFilter.INCLUDE_ALL) {
             _headContext = _headContext.createChildObjectContext(f, true);
-            return (_currToken = t);
-        }
-        if (f == null) { // does this occur?
-            delegate.skipChildren();
-            break;
-        }
-        // Otherwise still iffy, need to check
+            if (!_allowMultipleMatches) {
+                _matchCount++;
+            }
+            return (_currToken = t);
+        }
+        if (f == null) {
+            delegate.skipChildren();
+            break;
+        }
         f = _headContext.checkValue(f);
         if (f == null) {
             delegate.skipChildren();
@@ -116,10 +133,13 @@
         _itemFilter = f;
         if (f == TokenFilter.INCLUDE_ALL) {
             _headContext = _headContext.createChildObjectContext(f, true);
+            if (!_allowMultipleMatches) {
+                _matchCount++;
+            }
             return (_currToken = t);
         }
         _headContext = _headContext.createChildObjectContext(f, false);
-        // Also: only need buffering if parent path to be included
+
         if (_includePath) {
             t = _nextTokenWithBuffering(_headContext);
             if (t != null) {
@@ -127,8 +147,6 @@
                 return t;
             }
         }
-        // note: inclusion of surrounding Object handled separately via
-        // FIELD_NAME
         break;
 
     case ID_END_ARRAY:
@@ -140,7 +158,7 @@
                 f.filterFinishArray();
             }
             _headContext = _headContext.getParent();
-            _itemFilter = _headContext.getFilter();
+            _itemFilter = _headContext == null ? null : _headContext.getFilter();
             if (returnEnd) {
                 return (_currToken = t);
             }
@@ -150,15 +168,16 @@
     case ID_FIELD_NAME:
         {
             final String name = delegate.getCurrentName();
-            // note: this will also set 'needToHandleName'
             f = _headContext.setFieldName(name);
             if (f == TokenFilter.INCLUDE_ALL) {
                 _itemFilter = f;
+                // Count match if multiple matches not allowed
+                if (!_allowMultipleMatches) {
+                    _matchCount++;
+                }
                 if (!_includePath) {
-                    // Minor twist here: if parent NOT included, may need to induce output of
-                    // surrounding START_OBJECT/END_OBJECT
                     if (_includeImmediateParent && !_headContext.isStartHandled()) {
-                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled
+                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but marks it handled
                         _exposedContext = _headContext;
                     }
                 }
@@ -177,6 +196,9 @@
             }
             _itemFilter = f;
             if (f == TokenFilter.INCLUDE_ALL) {
+                if (!_allowMultipleMatches) {
+                    _matchCount++;
+                }
                 if (_includePath) {
                     return (_currToken = t);
                 }
@@ -188,18 +210,24 @@
                     return t;
                 }
             }
-            break;
-        }
-
-    default: // scalar value
+        }
+        break;
+
+    default:
         f = _itemFilter;
         if (f == TokenFilter.INCLUDE_ALL) {
+            if (!_allowMultipleMatches) {
+                _matchCount++;
+            }
             return (_currToken = t);
         }
         if (f != null) {
             f = _headContext.checkValue(f);
             if ((f == TokenFilter.INCLUDE_ALL)
                     || ((f != null) && f.includeValue(delegate))) {
+                if (!_allowMultipleMatches) {
+                    _matchCount++;
+                }
                 return (_currToken = t);
             }
         }
@@ -207,6 +235,7 @@
         break;
     }
 
-    // We get here if token was not yet found; offlined handling
+    // If token was not returned, try to get it from the buffered chain or next token method
     return _nextToken2();
 }
+
